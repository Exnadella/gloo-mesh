// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./snapshot.go -destination mocks/snapshot.go

// The Input Snapshot contains the set of all:
// * CertificatesMeshGlooSoloIov1Alpha2IssuedCertificates
// * CertificatesMeshGlooSoloIov1Alpha2CertificateRequests
// * CertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives
// * V1Secrets
// * V1Pods
// read from a given cluster or set of clusters, across all namespaces.
//
// A snapshot can be constructed from either a single Manager (for a single cluster)
// or a ClusterWatcher (for multiple clusters) using the SnapshotBuilder.
//
// Resources in a MultiCluster snapshot will have their ClusterName set to the
// name of the cluster from which the resource was read.

package input

import (
	"context"
	"encoding/json"

	"github.com/solo-io/skv2/pkg/verifier"
	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/hashicorp/go-multierror"

	"github.com/solo-io/skv2/pkg/controllerutils"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/manager"

	certificates_mesh_gloo_solo_io_v1alpha2 "github.com/solo-io/gloo-mesh/pkg/api/certificates.mesh.gloo.solo.io/v1alpha2"
	certificates_mesh_gloo_solo_io_v1alpha2_sets "github.com/solo-io/gloo-mesh/pkg/api/certificates.mesh.gloo.solo.io/v1alpha2/sets"

	v1 "github.com/solo-io/external-apis/pkg/api/k8s/core/v1"
	v1_sets "github.com/solo-io/external-apis/pkg/api/k8s/core/v1/sets"
)

// the snapshot of input resources consumed by translation
type Snapshot interface {

	// return the set of input CertificatesMeshGlooSoloIov1Alpha2IssuedCertificates
	CertificatesMeshGlooSoloIov1Alpha2IssuedCertificates() certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet
	// return the set of input CertificatesMeshGlooSoloIov1Alpha2CertificateRequests
	CertificatesMeshGlooSoloIov1Alpha2CertificateRequests() certificates_mesh_gloo_solo_io_v1alpha2_sets.CertificateRequestSet
	// return the set of input CertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives
	CertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives() certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet

	// return the set of input V1Secrets
	V1Secrets() v1_sets.SecretSet
	// return the set of input V1Pods
	V1Pods() v1_sets.PodSet
	// update the status of all input objects which support
	// the Status subresource (in the local cluster)
	SyncStatuses(ctx context.Context, c client.Client, opts SyncStatusOptions) error
	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)
}

// options for syncing input object statuses
type SyncStatusOptions struct {

	// sync status of CertificatesMeshGlooSoloIov1Alpha2IssuedCertificate objects
	CertificatesMeshGlooSoloIov1Alpha2IssuedCertificate bool
	// sync status of CertificatesMeshGlooSoloIov1Alpha2CertificateRequest objects
	CertificatesMeshGlooSoloIov1Alpha2CertificateRequest bool
	// sync status of CertificatesMeshGlooSoloIov1Alpha2PodBounceDirective objects
	CertificatesMeshGlooSoloIov1Alpha2PodBounceDirective bool

	// sync status of V1Secret objects
	V1Secret bool
	// sync status of V1Pod objects
	V1Pod bool
}

type snapshot struct {
	name string

	certificatesMeshGlooSoloIov1Alpha2IssuedCertificates  certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet
	certificatesMeshGlooSoloIov1Alpha2CertificateRequests certificates_mesh_gloo_solo_io_v1alpha2_sets.CertificateRequestSet
	certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet

	v1Secrets v1_sets.SecretSet
	v1Pods    v1_sets.PodSet
}

func NewSnapshot(
	name string,

	certificatesMeshGlooSoloIov1Alpha2IssuedCertificates certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet,
	certificatesMeshGlooSoloIov1Alpha2CertificateRequests certificates_mesh_gloo_solo_io_v1alpha2_sets.CertificateRequestSet,
	certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet,

	v1Secrets v1_sets.SecretSet,
	v1Pods v1_sets.PodSet,

) Snapshot {
	return &snapshot{
		name: name,

		certificatesMeshGlooSoloIov1Alpha2IssuedCertificates:  certificatesMeshGlooSoloIov1Alpha2IssuedCertificates,
		certificatesMeshGlooSoloIov1Alpha2CertificateRequests: certificatesMeshGlooSoloIov1Alpha2CertificateRequests,
		certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives: certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives,
		v1Secrets: v1Secrets,
		v1Pods:    v1Pods,
	}
}

func (s snapshot) CertificatesMeshGlooSoloIov1Alpha2IssuedCertificates() certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet {
	return s.certificatesMeshGlooSoloIov1Alpha2IssuedCertificates
}

func (s snapshot) CertificatesMeshGlooSoloIov1Alpha2CertificateRequests() certificates_mesh_gloo_solo_io_v1alpha2_sets.CertificateRequestSet {
	return s.certificatesMeshGlooSoloIov1Alpha2CertificateRequests
}

func (s snapshot) CertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives() certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet {
	return s.certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives
}

func (s snapshot) V1Secrets() v1_sets.SecretSet {
	return s.v1Secrets
}

func (s snapshot) V1Pods() v1_sets.PodSet {
	return s.v1Pods
}

func (s snapshot) SyncStatuses(ctx context.Context, c client.Client, opts SyncStatusOptions) error {
	var errs error

	if opts.CertificatesMeshGlooSoloIov1Alpha2IssuedCertificate {
		for _, obj := range s.CertificatesMeshGlooSoloIov1Alpha2IssuedCertificates().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.CertificatesMeshGlooSoloIov1Alpha2CertificateRequest {
		for _, obj := range s.CertificatesMeshGlooSoloIov1Alpha2CertificateRequests().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.CertificatesMeshGlooSoloIov1Alpha2PodBounceDirective {
		for _, obj := range s.CertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	return errs
}

func (s snapshot) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	snapshotMap["certificatesMeshGlooSoloIov1Alpha2IssuedCertificates"] = s.certificatesMeshGlooSoloIov1Alpha2IssuedCertificates.List()
	snapshotMap["certificatesMeshGlooSoloIov1Alpha2CertificateRequests"] = s.certificatesMeshGlooSoloIov1Alpha2CertificateRequests.List()
	snapshotMap["certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives"] = s.certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives.List()
	snapshotMap["v1Secrets"] = s.v1Secrets.List()
	snapshotMap["v1Pods"] = s.v1Pods.List()
	return json.Marshal(snapshotMap)
}

// builds the input snapshot from API Clients.
type Builder interface {
	BuildSnapshot(ctx context.Context, name string, opts BuildOptions) (Snapshot, error)
}

// Options for building a snapshot
type BuildOptions struct {

	// List options for composing a snapshot from CertificatesMeshGlooSoloIov1Alpha2IssuedCertificates
	CertificatesMeshGlooSoloIov1Alpha2IssuedCertificates ResourceBuildOptions
	// List options for composing a snapshot from CertificatesMeshGlooSoloIov1Alpha2CertificateRequests
	CertificatesMeshGlooSoloIov1Alpha2CertificateRequests ResourceBuildOptions
	// List options for composing a snapshot from CertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives
	CertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives ResourceBuildOptions

	// List options for composing a snapshot from V1Secrets
	V1Secrets ResourceBuildOptions
	// List options for composing a snapshot from V1Pods
	V1Pods ResourceBuildOptions
}

// Options for reading resources of a given type
type ResourceBuildOptions struct {

	// List options for composing a snapshot from a resource type
	ListOptions []client.ListOption

	// If provided, ensure the resource has been verified before adding it to snapshots
	Verifier verifier.ServerResourceVerifier
}

// build a snapshot from resources in a single cluster
type singleClusterBuilder struct {
	mgr manager.Manager
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewSingleClusterBuilder(
	mgr manager.Manager,
) Builder {
	return &singleClusterBuilder{
		mgr: mgr,
	}
}

func (b *singleClusterBuilder) BuildSnapshot(ctx context.Context, name string, opts BuildOptions) (Snapshot, error) {

	certificatesMeshGlooSoloIov1Alpha2IssuedCertificates := certificates_mesh_gloo_solo_io_v1alpha2_sets.NewIssuedCertificateSet()
	certificatesMeshGlooSoloIov1Alpha2CertificateRequests := certificates_mesh_gloo_solo_io_v1alpha2_sets.NewCertificateRequestSet()
	certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives := certificates_mesh_gloo_solo_io_v1alpha2_sets.NewPodBounceDirectiveSet()

	v1Secrets := v1_sets.NewSecretSet()
	v1Pods := v1_sets.NewPodSet()

	var errs error

	if err := b.insertCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates(ctx, certificatesMeshGlooSoloIov1Alpha2IssuedCertificates, opts.CertificatesMeshGlooSoloIov1Alpha2IssuedCertificates); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertCertificatesMeshGlooSoloIov1Alpha2CertificateRequests(ctx, certificatesMeshGlooSoloIov1Alpha2CertificateRequests, opts.CertificatesMeshGlooSoloIov1Alpha2CertificateRequests); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives(ctx, certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives, opts.CertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertV1Secrets(ctx, v1Secrets, opts.V1Secrets); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertV1Pods(ctx, v1Pods, opts.V1Pods); err != nil {
		errs = multierror.Append(errs, err)
	}

	outputSnap := NewSnapshot(
		name,

		certificatesMeshGlooSoloIov1Alpha2IssuedCertificates,
		certificatesMeshGlooSoloIov1Alpha2CertificateRequests,
		certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives,
		v1Secrets,
		v1Pods,
	)

	return outputSnap, errs
}

func (b *singleClusterBuilder) insertCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates(ctx context.Context, certificatesMeshGlooSoloIov1Alpha2IssuedCertificates certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet, opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "IssuedCertificate",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	certificatesMeshGlooSoloIov1Alpha2IssuedCertificateList, err := certificates_mesh_gloo_solo_io_v1alpha2.NewIssuedCertificateClient(b.mgr.GetClient()).ListIssuedCertificate(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range certificatesMeshGlooSoloIov1Alpha2IssuedCertificateList.Items {
		item := item // pike
		certificatesMeshGlooSoloIov1Alpha2IssuedCertificates.Insert(&item)
	}

	return nil
}
func (b *singleClusterBuilder) insertCertificatesMeshGlooSoloIov1Alpha2CertificateRequests(ctx context.Context, certificatesMeshGlooSoloIov1Alpha2CertificateRequests certificates_mesh_gloo_solo_io_v1alpha2_sets.CertificateRequestSet, opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "CertificateRequest",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	certificatesMeshGlooSoloIov1Alpha2CertificateRequestList, err := certificates_mesh_gloo_solo_io_v1alpha2.NewCertificateRequestClient(b.mgr.GetClient()).ListCertificateRequest(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range certificatesMeshGlooSoloIov1Alpha2CertificateRequestList.Items {
		item := item // pike
		certificatesMeshGlooSoloIov1Alpha2CertificateRequests.Insert(&item)
	}

	return nil
}
func (b *singleClusterBuilder) insertCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives(ctx context.Context, certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet, opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "PodBounceDirective",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	certificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveList, err := certificates_mesh_gloo_solo_io_v1alpha2.NewPodBounceDirectiveClient(b.mgr.GetClient()).ListPodBounceDirective(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range certificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveList.Items {
		item := item // pike
		certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives.Insert(&item)
	}

	return nil
}

func (b *singleClusterBuilder) insertV1Secrets(ctx context.Context, v1Secrets v1_sets.SecretSet, opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Secret",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	v1SecretList, err := v1.NewSecretClient(b.mgr.GetClient()).ListSecret(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range v1SecretList.Items {
		item := item // pike
		v1Secrets.Insert(&item)
	}

	return nil
}
func (b *singleClusterBuilder) insertV1Pods(ctx context.Context, v1Pods v1_sets.PodSet, opts ResourceBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Pod",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	v1PodList, err := v1.NewPodClient(b.mgr.GetClient()).ListPod(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range v1PodList.Items {
		item := item // pike
		v1Pods.Insert(&item)
	}

	return nil
}
