// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./snapshot.go -destination mocks/snapshot.go

// Definitions for Output Snapshots
package istio

import (
	"context"
	"encoding/json"
	"sort"

	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/solo-io/go-utils/contextutils"
	"github.com/solo-io/skv2/pkg/multicluster"

	"github.com/rotisserie/eris"
	"github.com/solo-io/skv2/contrib/pkg/output"
	"github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"sigs.k8s.io/controller-runtime/pkg/client"

	certificates_mesh_gloo_solo_io_v1alpha2 "github.com/solo-io/gloo-mesh/pkg/api/certificates.mesh.gloo.solo.io/v1alpha2"
	certificates_mesh_gloo_solo_io_v1alpha2_sets "github.com/solo-io/gloo-mesh/pkg/api/certificates.mesh.gloo.solo.io/v1alpha2/sets"

	xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1 "github.com/solo-io/gloo-mesh/pkg/api/xds.agent.enterprise.mesh.gloo.solo.io/v1alpha1"
	xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets "github.com/solo-io/gloo-mesh/pkg/api/xds.agent.enterprise.mesh.gloo.solo.io/v1alpha1/sets"

	networking_istio_io_v1alpha3_sets "github.com/solo-io/external-apis/pkg/api/istio/networking.istio.io/v1alpha3/sets"
	networking_istio_io_v1alpha3 "istio.io/client-go/pkg/apis/networking/v1alpha3"

	security_istio_io_v1beta1_sets "github.com/solo-io/external-apis/pkg/api/istio/security.istio.io/v1beta1/sets"
	security_istio_io_v1beta1 "istio.io/client-go/pkg/apis/security/v1beta1"

	v1_sets "github.com/solo-io/external-apis/pkg/api/k8s/core/v1/sets"
	v1 "k8s.io/api/core/v1"
)

// this error can occur if constructing a Partitioned Snapshot from a resource
// that is missing the partition label
var MissingRequiredLabelError = func(labelKey, resourceKind string, obj ezkube.ResourceId) error {
	return eris.Errorf("expected label %v not on labels of %v %v", labelKey, resourceKind, sets.Key(obj))
}

// the snapshot of output resources produced by a translation
type Snapshot interface {

	// return the set of CertificatesMeshGlooSoloIov1Alpha2IssuedCertificates with a given set of labels
	CertificatesMeshGlooSoloIov1Alpha2IssuedCertificates() []LabeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet
	// return the set of CertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives with a given set of labels
	CertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives() []LabeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet
	// return the set of XdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs with a given set of labels
	XdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs() []LabeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet
	// return the set of NetworkingIstioIov1Alpha3DestinationRules with a given set of labels
	NetworkingIstioIov1Alpha3DestinationRules() []LabeledNetworkingIstioIov1Alpha3DestinationRuleSet
	// return the set of NetworkingIstioIov1Alpha3EnvoyFilters with a given set of labels
	NetworkingIstioIov1Alpha3EnvoyFilters() []LabeledNetworkingIstioIov1Alpha3EnvoyFilterSet
	// return the set of NetworkingIstioIov1Alpha3Gateways with a given set of labels
	NetworkingIstioIov1Alpha3Gateways() []LabeledNetworkingIstioIov1Alpha3GatewaySet
	// return the set of NetworkingIstioIov1Alpha3ServiceEntries with a given set of labels
	NetworkingIstioIov1Alpha3ServiceEntries() []LabeledNetworkingIstioIov1Alpha3ServiceEntrySet
	// return the set of NetworkingIstioIov1Alpha3VirtualServices with a given set of labels
	NetworkingIstioIov1Alpha3VirtualServices() []LabeledNetworkingIstioIov1Alpha3VirtualServiceSet
	// return the set of SecurityIstioIov1Beta1AuthorizationPolicies with a given set of labels
	SecurityIstioIov1Beta1AuthorizationPolicies() []LabeledSecurityIstioIov1Beta1AuthorizationPolicySet
	// return the set of V1ConfigMaps with a given set of labels
	V1ConfigMaps() []LabeledV1ConfigMapSet

	// apply the snapshot to the local cluster, garbage collecting stale resources
	ApplyLocalCluster(ctx context.Context, clusterClient client.Client, errHandler output.ErrorHandler)

	// apply resources from the snapshot across multiple clusters, garbage collecting stale resources
	ApplyMultiCluster(ctx context.Context, multiClusterClient multicluster.Client, errHandler output.ErrorHandler)

	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)
}

type snapshot struct {
	name string

	certificatesMeshGlooSoloIov1Alpha2IssuedCertificates  []LabeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet
	certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives []LabeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet
	xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs    []LabeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet
	networkingIstioIov1Alpha3DestinationRules             []LabeledNetworkingIstioIov1Alpha3DestinationRuleSet
	networkingIstioIov1Alpha3EnvoyFilters                 []LabeledNetworkingIstioIov1Alpha3EnvoyFilterSet
	networkingIstioIov1Alpha3Gateways                     []LabeledNetworkingIstioIov1Alpha3GatewaySet
	networkingIstioIov1Alpha3ServiceEntries               []LabeledNetworkingIstioIov1Alpha3ServiceEntrySet
	networkingIstioIov1Alpha3VirtualServices              []LabeledNetworkingIstioIov1Alpha3VirtualServiceSet
	securityIstioIov1Beta1AuthorizationPolicies           []LabeledSecurityIstioIov1Beta1AuthorizationPolicySet
	v1ConfigMaps                                          []LabeledV1ConfigMapSet
	clusters                                              []string
}

func NewSnapshot(
	name string,

	certificatesMeshGlooSoloIov1Alpha2IssuedCertificates []LabeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet,
	certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives []LabeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet,
	xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs []LabeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet,
	networkingIstioIov1Alpha3DestinationRules []LabeledNetworkingIstioIov1Alpha3DestinationRuleSet,
	networkingIstioIov1Alpha3EnvoyFilters []LabeledNetworkingIstioIov1Alpha3EnvoyFilterSet,
	networkingIstioIov1Alpha3Gateways []LabeledNetworkingIstioIov1Alpha3GatewaySet,
	networkingIstioIov1Alpha3ServiceEntries []LabeledNetworkingIstioIov1Alpha3ServiceEntrySet,
	networkingIstioIov1Alpha3VirtualServices []LabeledNetworkingIstioIov1Alpha3VirtualServiceSet,
	securityIstioIov1Beta1AuthorizationPolicies []LabeledSecurityIstioIov1Beta1AuthorizationPolicySet,
	v1ConfigMaps []LabeledV1ConfigMapSet,
	clusters ...string, // the set of clusters to apply the snapshot to. only required for multicluster snapshots.
) Snapshot {
	return &snapshot{
		name: name,

		certificatesMeshGlooSoloIov1Alpha2IssuedCertificates:  certificatesMeshGlooSoloIov1Alpha2IssuedCertificates,
		certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives: certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives,
		xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs:    xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs,
		networkingIstioIov1Alpha3DestinationRules:             networkingIstioIov1Alpha3DestinationRules,
		networkingIstioIov1Alpha3EnvoyFilters:                 networkingIstioIov1Alpha3EnvoyFilters,
		networkingIstioIov1Alpha3Gateways:                     networkingIstioIov1Alpha3Gateways,
		networkingIstioIov1Alpha3ServiceEntries:               networkingIstioIov1Alpha3ServiceEntries,
		networkingIstioIov1Alpha3VirtualServices:              networkingIstioIov1Alpha3VirtualServices,
		securityIstioIov1Beta1AuthorizationPolicies:           securityIstioIov1Beta1AuthorizationPolicies,
		v1ConfigMaps: v1ConfigMaps,
		clusters:     clusters,
	}
}

// automatically partitions the input resources
// by the presence of the provided label.
func NewLabelPartitionedSnapshot(
	name,
	labelKey string, // the key by which to partition the resources

	certificatesMeshGlooSoloIov1Alpha2IssuedCertificates certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet,
	certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet,

	xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet,

	networkingIstioIov1Alpha3DestinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet,
	networkingIstioIov1Alpha3EnvoyFilters networking_istio_io_v1alpha3_sets.EnvoyFilterSet,
	networkingIstioIov1Alpha3Gateways networking_istio_io_v1alpha3_sets.GatewaySet,
	networkingIstioIov1Alpha3ServiceEntries networking_istio_io_v1alpha3_sets.ServiceEntrySet,
	networkingIstioIov1Alpha3VirtualServices networking_istio_io_v1alpha3_sets.VirtualServiceSet,

	securityIstioIov1Beta1AuthorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet,

	v1ConfigMaps v1_sets.ConfigMapSet,
	clusters ...string, // the set of clusters to apply the snapshot to. only required for multicluster snapshots.
) (Snapshot, error) {

	partitionedCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates, err := partitionCertificatesMeshGlooSoloIov1Alpha2IssuedCertificatesByLabel(labelKey, certificatesMeshGlooSoloIov1Alpha2IssuedCertificates)
	if err != nil {
		return nil, err
	}
	partitionedCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives, err := partitionCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectivesByLabel(labelKey, certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives)
	if err != nil {
		return nil, err
	}
	partitionedXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs, err := partitionXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigsByLabel(labelKey, xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs)
	if err != nil {
		return nil, err
	}
	partitionedNetworkingIstioIov1Alpha3DestinationRules, err := partitionNetworkingIstioIov1Alpha3DestinationRulesByLabel(labelKey, networkingIstioIov1Alpha3DestinationRules)
	if err != nil {
		return nil, err
	}
	partitionedNetworkingIstioIov1Alpha3EnvoyFilters, err := partitionNetworkingIstioIov1Alpha3EnvoyFiltersByLabel(labelKey, networkingIstioIov1Alpha3EnvoyFilters)
	if err != nil {
		return nil, err
	}
	partitionedNetworkingIstioIov1Alpha3Gateways, err := partitionNetworkingIstioIov1Alpha3GatewaysByLabel(labelKey, networkingIstioIov1Alpha3Gateways)
	if err != nil {
		return nil, err
	}
	partitionedNetworkingIstioIov1Alpha3ServiceEntries, err := partitionNetworkingIstioIov1Alpha3ServiceEntriesByLabel(labelKey, networkingIstioIov1Alpha3ServiceEntries)
	if err != nil {
		return nil, err
	}
	partitionedNetworkingIstioIov1Alpha3VirtualServices, err := partitionNetworkingIstioIov1Alpha3VirtualServicesByLabel(labelKey, networkingIstioIov1Alpha3VirtualServices)
	if err != nil {
		return nil, err
	}
	partitionedSecurityIstioIov1Beta1AuthorizationPolicies, err := partitionSecurityIstioIov1Beta1AuthorizationPoliciesByLabel(labelKey, securityIstioIov1Beta1AuthorizationPolicies)
	if err != nil {
		return nil, err
	}
	partitionedV1ConfigMaps, err := partitionV1ConfigMapsByLabel(labelKey, v1ConfigMaps)
	if err != nil {
		return nil, err
	}

	return NewSnapshot(
		name,

		partitionedCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates,
		partitionedCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives,
		partitionedXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs,
		partitionedNetworkingIstioIov1Alpha3DestinationRules,
		partitionedNetworkingIstioIov1Alpha3EnvoyFilters,
		partitionedNetworkingIstioIov1Alpha3Gateways,
		partitionedNetworkingIstioIov1Alpha3ServiceEntries,
		partitionedNetworkingIstioIov1Alpha3VirtualServices,
		partitionedSecurityIstioIov1Beta1AuthorizationPolicies,
		partitionedV1ConfigMaps,
		clusters...,
	), nil
}

// simplified constructor for a snapshot
// with a single label partition (i.e. all resources share a single set of labels).
func NewSinglePartitionedSnapshot(
	name string,
	snapshotLabels map[string]string, // a single set of labels shared by all resources

	certificatesMeshGlooSoloIov1Alpha2IssuedCertificates certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet,
	certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet,

	xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet,

	networkingIstioIov1Alpha3DestinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet,
	networkingIstioIov1Alpha3EnvoyFilters networking_istio_io_v1alpha3_sets.EnvoyFilterSet,
	networkingIstioIov1Alpha3Gateways networking_istio_io_v1alpha3_sets.GatewaySet,
	networkingIstioIov1Alpha3ServiceEntries networking_istio_io_v1alpha3_sets.ServiceEntrySet,
	networkingIstioIov1Alpha3VirtualServices networking_istio_io_v1alpha3_sets.VirtualServiceSet,

	securityIstioIov1Beta1AuthorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet,

	v1ConfigMaps v1_sets.ConfigMapSet,
	clusters ...string, // the set of clusters to apply the snapshot to. only required for multicluster snapshots.
) (Snapshot, error) {

	labeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificate, err := NewLabeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet(certificatesMeshGlooSoloIov1Alpha2IssuedCertificates, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirective, err := NewLabeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet(certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfig, err := NewLabeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet(xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledNetworkingIstioIov1Alpha3DestinationRule, err := NewLabeledNetworkingIstioIov1Alpha3DestinationRuleSet(networkingIstioIov1Alpha3DestinationRules, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledNetworkingIstioIov1Alpha3EnvoyFilter, err := NewLabeledNetworkingIstioIov1Alpha3EnvoyFilterSet(networkingIstioIov1Alpha3EnvoyFilters, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledNetworkingIstioIov1Alpha3Gateway, err := NewLabeledNetworkingIstioIov1Alpha3GatewaySet(networkingIstioIov1Alpha3Gateways, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledNetworkingIstioIov1Alpha3ServiceEntry, err := NewLabeledNetworkingIstioIov1Alpha3ServiceEntrySet(networkingIstioIov1Alpha3ServiceEntries, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledNetworkingIstioIov1Alpha3VirtualService, err := NewLabeledNetworkingIstioIov1Alpha3VirtualServiceSet(networkingIstioIov1Alpha3VirtualServices, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledSecurityIstioIov1Beta1AuthorizationPolicy, err := NewLabeledSecurityIstioIov1Beta1AuthorizationPolicySet(securityIstioIov1Beta1AuthorizationPolicies, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledV1ConfigMap, err := NewLabeledV1ConfigMapSet(v1ConfigMaps, snapshotLabels)
	if err != nil {
		return nil, err
	}

	return NewSnapshot(
		name,

		[]LabeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet{labeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificate},
		[]LabeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet{labeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirective},
		[]LabeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet{labeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfig},
		[]LabeledNetworkingIstioIov1Alpha3DestinationRuleSet{labeledNetworkingIstioIov1Alpha3DestinationRule},
		[]LabeledNetworkingIstioIov1Alpha3EnvoyFilterSet{labeledNetworkingIstioIov1Alpha3EnvoyFilter},
		[]LabeledNetworkingIstioIov1Alpha3GatewaySet{labeledNetworkingIstioIov1Alpha3Gateway},
		[]LabeledNetworkingIstioIov1Alpha3ServiceEntrySet{labeledNetworkingIstioIov1Alpha3ServiceEntry},
		[]LabeledNetworkingIstioIov1Alpha3VirtualServiceSet{labeledNetworkingIstioIov1Alpha3VirtualService},
		[]LabeledSecurityIstioIov1Beta1AuthorizationPolicySet{labeledSecurityIstioIov1Beta1AuthorizationPolicy},
		[]LabeledV1ConfigMapSet{labeledV1ConfigMap},
		clusters...,
	), nil
}

// apply the desired resources to the cluster state; remove stale resources where necessary
func (s *snapshot) ApplyLocalCluster(ctx context.Context, cli client.Client, errHandler output.ErrorHandler) {
	var genericLists []output.ResourceList

	for _, outputSet := range s.certificatesMeshGlooSoloIov1Alpha2IssuedCertificates {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIov1Alpha3DestinationRules {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIov1Alpha3EnvoyFilters {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIov1Alpha3Gateways {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIov1Alpha3ServiceEntries {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIov1Alpha3VirtualServices {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.securityIstioIov1Beta1AuthorizationPolicies {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.v1ConfigMaps {
		genericLists = append(genericLists, outputSet.Generic())
	}

	output.Snapshot{
		Name:        s.name,
		ListsToSync: genericLists,
	}.SyncLocalCluster(ctx, cli, errHandler)
}

// apply the desired resources to multiple cluster states; remove stale resources where necessary
func (s *snapshot) ApplyMultiCluster(ctx context.Context, multiClusterClient multicluster.Client, errHandler output.ErrorHandler) {
	var genericLists []output.ResourceList

	for _, outputSet := range s.certificatesMeshGlooSoloIov1Alpha2IssuedCertificates {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIov1Alpha3DestinationRules {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIov1Alpha3EnvoyFilters {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIov1Alpha3Gateways {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIov1Alpha3ServiceEntries {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIov1Alpha3VirtualServices {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.securityIstioIov1Beta1AuthorizationPolicies {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.v1ConfigMaps {
		genericLists = append(genericLists, outputSet.Generic())
	}

	output.Snapshot{
		Name:        s.name,
		Clusters:    s.clusters,
		ListsToSync: genericLists,
	}.SyncMultiCluster(ctx, multiClusterClient, errHandler)
}

func partitionCertificatesMeshGlooSoloIov1Alpha2IssuedCertificatesByLabel(labelKey string, set certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet) ([]LabeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet, error) {
	setsByLabel := map[string]certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "CertificatesMeshGlooSoloIov1Alpha2IssuedCertificate", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "CertificatesMeshGlooSoloIov1Alpha2IssuedCertificate", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = certificates_mesh_gloo_solo_io_v1alpha2_sets.NewIssuedCertificateSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates []LabeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates = append(partitionedCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates, func(i, j int) bool {
		leftLabelValue := partitionedCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates[i].Labels()[labelKey]
		rightLabelValue := partitionedCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates, nil
}

func partitionCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectivesByLabel(labelKey string, set certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet) ([]LabeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet, error) {
	setsByLabel := map[string]certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "CertificatesMeshGlooSoloIov1Alpha2PodBounceDirective", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "CertificatesMeshGlooSoloIov1Alpha2PodBounceDirective", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = certificates_mesh_gloo_solo_io_v1alpha2_sets.NewPodBounceDirectiveSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives []LabeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives = append(partitionedCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives, func(i, j int) bool {
		leftLabelValue := partitionedCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives[i].Labels()[labelKey]
		rightLabelValue := partitionedCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives, nil
}

func partitionXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigsByLabel(labelKey string, set xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet) ([]LabeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet, error) {
	setsByLabel := map[string]xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "XdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfig", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "XdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfig", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.NewXdsConfigSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs []LabeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs = append(partitionedXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs, func(i, j int) bool {
		leftLabelValue := partitionedXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs[i].Labels()[labelKey]
		rightLabelValue := partitionedXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs, nil
}

func partitionNetworkingIstioIov1Alpha3DestinationRulesByLabel(labelKey string, set networking_istio_io_v1alpha3_sets.DestinationRuleSet) ([]LabeledNetworkingIstioIov1Alpha3DestinationRuleSet, error) {
	setsByLabel := map[string]networking_istio_io_v1alpha3_sets.DestinationRuleSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIov1Alpha3DestinationRule", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIov1Alpha3DestinationRule", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = networking_istio_io_v1alpha3_sets.NewDestinationRuleSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedNetworkingIstioIov1Alpha3DestinationRules []LabeledNetworkingIstioIov1Alpha3DestinationRuleSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledNetworkingIstioIov1Alpha3DestinationRuleSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedNetworkingIstioIov1Alpha3DestinationRules = append(partitionedNetworkingIstioIov1Alpha3DestinationRules, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedNetworkingIstioIov1Alpha3DestinationRules, func(i, j int) bool {
		leftLabelValue := partitionedNetworkingIstioIov1Alpha3DestinationRules[i].Labels()[labelKey]
		rightLabelValue := partitionedNetworkingIstioIov1Alpha3DestinationRules[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedNetworkingIstioIov1Alpha3DestinationRules, nil
}

func partitionNetworkingIstioIov1Alpha3EnvoyFiltersByLabel(labelKey string, set networking_istio_io_v1alpha3_sets.EnvoyFilterSet) ([]LabeledNetworkingIstioIov1Alpha3EnvoyFilterSet, error) {
	setsByLabel := map[string]networking_istio_io_v1alpha3_sets.EnvoyFilterSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIov1Alpha3EnvoyFilter", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIov1Alpha3EnvoyFilter", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedNetworkingIstioIov1Alpha3EnvoyFilters []LabeledNetworkingIstioIov1Alpha3EnvoyFilterSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledNetworkingIstioIov1Alpha3EnvoyFilterSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedNetworkingIstioIov1Alpha3EnvoyFilters = append(partitionedNetworkingIstioIov1Alpha3EnvoyFilters, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedNetworkingIstioIov1Alpha3EnvoyFilters, func(i, j int) bool {
		leftLabelValue := partitionedNetworkingIstioIov1Alpha3EnvoyFilters[i].Labels()[labelKey]
		rightLabelValue := partitionedNetworkingIstioIov1Alpha3EnvoyFilters[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedNetworkingIstioIov1Alpha3EnvoyFilters, nil
}

func partitionNetworkingIstioIov1Alpha3GatewaysByLabel(labelKey string, set networking_istio_io_v1alpha3_sets.GatewaySet) ([]LabeledNetworkingIstioIov1Alpha3GatewaySet, error) {
	setsByLabel := map[string]networking_istio_io_v1alpha3_sets.GatewaySet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIov1Alpha3Gateway", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIov1Alpha3Gateway", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = networking_istio_io_v1alpha3_sets.NewGatewaySet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedNetworkingIstioIov1Alpha3Gateways []LabeledNetworkingIstioIov1Alpha3GatewaySet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledNetworkingIstioIov1Alpha3GatewaySet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedNetworkingIstioIov1Alpha3Gateways = append(partitionedNetworkingIstioIov1Alpha3Gateways, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedNetworkingIstioIov1Alpha3Gateways, func(i, j int) bool {
		leftLabelValue := partitionedNetworkingIstioIov1Alpha3Gateways[i].Labels()[labelKey]
		rightLabelValue := partitionedNetworkingIstioIov1Alpha3Gateways[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedNetworkingIstioIov1Alpha3Gateways, nil
}

func partitionNetworkingIstioIov1Alpha3ServiceEntriesByLabel(labelKey string, set networking_istio_io_v1alpha3_sets.ServiceEntrySet) ([]LabeledNetworkingIstioIov1Alpha3ServiceEntrySet, error) {
	setsByLabel := map[string]networking_istio_io_v1alpha3_sets.ServiceEntrySet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIov1Alpha3ServiceEntry", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIov1Alpha3ServiceEntry", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = networking_istio_io_v1alpha3_sets.NewServiceEntrySet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedNetworkingIstioIov1Alpha3ServiceEntries []LabeledNetworkingIstioIov1Alpha3ServiceEntrySet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledNetworkingIstioIov1Alpha3ServiceEntrySet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedNetworkingIstioIov1Alpha3ServiceEntries = append(partitionedNetworkingIstioIov1Alpha3ServiceEntries, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedNetworkingIstioIov1Alpha3ServiceEntries, func(i, j int) bool {
		leftLabelValue := partitionedNetworkingIstioIov1Alpha3ServiceEntries[i].Labels()[labelKey]
		rightLabelValue := partitionedNetworkingIstioIov1Alpha3ServiceEntries[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedNetworkingIstioIov1Alpha3ServiceEntries, nil
}

func partitionNetworkingIstioIov1Alpha3VirtualServicesByLabel(labelKey string, set networking_istio_io_v1alpha3_sets.VirtualServiceSet) ([]LabeledNetworkingIstioIov1Alpha3VirtualServiceSet, error) {
	setsByLabel := map[string]networking_istio_io_v1alpha3_sets.VirtualServiceSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIov1Alpha3VirtualService", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIov1Alpha3VirtualService", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = networking_istio_io_v1alpha3_sets.NewVirtualServiceSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedNetworkingIstioIov1Alpha3VirtualServices []LabeledNetworkingIstioIov1Alpha3VirtualServiceSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledNetworkingIstioIov1Alpha3VirtualServiceSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedNetworkingIstioIov1Alpha3VirtualServices = append(partitionedNetworkingIstioIov1Alpha3VirtualServices, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedNetworkingIstioIov1Alpha3VirtualServices, func(i, j int) bool {
		leftLabelValue := partitionedNetworkingIstioIov1Alpha3VirtualServices[i].Labels()[labelKey]
		rightLabelValue := partitionedNetworkingIstioIov1Alpha3VirtualServices[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedNetworkingIstioIov1Alpha3VirtualServices, nil
}

func partitionSecurityIstioIov1Beta1AuthorizationPoliciesByLabel(labelKey string, set security_istio_io_v1beta1_sets.AuthorizationPolicySet) ([]LabeledSecurityIstioIov1Beta1AuthorizationPolicySet, error) {
	setsByLabel := map[string]security_istio_io_v1beta1_sets.AuthorizationPolicySet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "SecurityIstioIov1Beta1AuthorizationPolicy", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "SecurityIstioIov1Beta1AuthorizationPolicy", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = security_istio_io_v1beta1_sets.NewAuthorizationPolicySet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedSecurityIstioIov1Beta1AuthorizationPolicies []LabeledSecurityIstioIov1Beta1AuthorizationPolicySet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledSecurityIstioIov1Beta1AuthorizationPolicySet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedSecurityIstioIov1Beta1AuthorizationPolicies = append(partitionedSecurityIstioIov1Beta1AuthorizationPolicies, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedSecurityIstioIov1Beta1AuthorizationPolicies, func(i, j int) bool {
		leftLabelValue := partitionedSecurityIstioIov1Beta1AuthorizationPolicies[i].Labels()[labelKey]
		rightLabelValue := partitionedSecurityIstioIov1Beta1AuthorizationPolicies[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedSecurityIstioIov1Beta1AuthorizationPolicies, nil
}

func partitionV1ConfigMapsByLabel(labelKey string, set v1_sets.ConfigMapSet) ([]LabeledV1ConfigMapSet, error) {
	setsByLabel := map[string]v1_sets.ConfigMapSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "V1ConfigMap", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "V1ConfigMap", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = v1_sets.NewConfigMapSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedV1ConfigMaps []LabeledV1ConfigMapSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledV1ConfigMapSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedV1ConfigMaps = append(partitionedV1ConfigMaps, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedV1ConfigMaps, func(i, j int) bool {
		leftLabelValue := partitionedV1ConfigMaps[i].Labels()[labelKey]
		rightLabelValue := partitionedV1ConfigMaps[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedV1ConfigMaps, nil
}

func (s snapshot) CertificatesMeshGlooSoloIov1Alpha2IssuedCertificates() []LabeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet {
	return s.certificatesMeshGlooSoloIov1Alpha2IssuedCertificates
}

func (s snapshot) CertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives() []LabeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet {
	return s.certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives
}

func (s snapshot) XdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs() []LabeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet {
	return s.xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs
}

func (s snapshot) NetworkingIstioIov1Alpha3DestinationRules() []LabeledNetworkingIstioIov1Alpha3DestinationRuleSet {
	return s.networkingIstioIov1Alpha3DestinationRules
}

func (s snapshot) NetworkingIstioIov1Alpha3EnvoyFilters() []LabeledNetworkingIstioIov1Alpha3EnvoyFilterSet {
	return s.networkingIstioIov1Alpha3EnvoyFilters
}

func (s snapshot) NetworkingIstioIov1Alpha3Gateways() []LabeledNetworkingIstioIov1Alpha3GatewaySet {
	return s.networkingIstioIov1Alpha3Gateways
}

func (s snapshot) NetworkingIstioIov1Alpha3ServiceEntries() []LabeledNetworkingIstioIov1Alpha3ServiceEntrySet {
	return s.networkingIstioIov1Alpha3ServiceEntries
}

func (s snapshot) NetworkingIstioIov1Alpha3VirtualServices() []LabeledNetworkingIstioIov1Alpha3VirtualServiceSet {
	return s.networkingIstioIov1Alpha3VirtualServices
}

func (s snapshot) SecurityIstioIov1Beta1AuthorizationPolicies() []LabeledSecurityIstioIov1Beta1AuthorizationPolicySet {
	return s.securityIstioIov1Beta1AuthorizationPolicies
}

func (s snapshot) V1ConfigMaps() []LabeledV1ConfigMapSet {
	return s.v1ConfigMaps
}

func (s snapshot) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	certificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet := certificates_mesh_gloo_solo_io_v1alpha2_sets.NewIssuedCertificateSet()
	for _, set := range s.certificatesMeshGlooSoloIov1Alpha2IssuedCertificates {
		certificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet = certificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet.Union(set.Set())
	}
	snapshotMap["certificatesMeshGlooSoloIov1Alpha2IssuedCertificates"] = certificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet.List()
	certificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet := certificates_mesh_gloo_solo_io_v1alpha2_sets.NewPodBounceDirectiveSet()
	for _, set := range s.certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives {
		certificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet = certificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet.Union(set.Set())
	}
	snapshotMap["certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives"] = certificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet.List()

	xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet := xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.NewXdsConfigSet()
	for _, set := range s.xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs {
		xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet = xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet.Union(set.Set())
	}
	snapshotMap["xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs"] = xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet.List()

	networkingIstioIov1Alpha3DestinationRuleSet := networking_istio_io_v1alpha3_sets.NewDestinationRuleSet()
	for _, set := range s.networkingIstioIov1Alpha3DestinationRules {
		networkingIstioIov1Alpha3DestinationRuleSet = networkingIstioIov1Alpha3DestinationRuleSet.Union(set.Set())
	}
	snapshotMap["networkingIstioIov1Alpha3DestinationRules"] = networkingIstioIov1Alpha3DestinationRuleSet.List()
	networkingIstioIov1Alpha3EnvoyFilterSet := networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet()
	for _, set := range s.networkingIstioIov1Alpha3EnvoyFilters {
		networkingIstioIov1Alpha3EnvoyFilterSet = networkingIstioIov1Alpha3EnvoyFilterSet.Union(set.Set())
	}
	snapshotMap["networkingIstioIov1Alpha3EnvoyFilters"] = networkingIstioIov1Alpha3EnvoyFilterSet.List()
	networkingIstioIov1Alpha3GatewaySet := networking_istio_io_v1alpha3_sets.NewGatewaySet()
	for _, set := range s.networkingIstioIov1Alpha3Gateways {
		networkingIstioIov1Alpha3GatewaySet = networkingIstioIov1Alpha3GatewaySet.Union(set.Set())
	}
	snapshotMap["networkingIstioIov1Alpha3Gateways"] = networkingIstioIov1Alpha3GatewaySet.List()
	networkingIstioIov1Alpha3ServiceEntrySet := networking_istio_io_v1alpha3_sets.NewServiceEntrySet()
	for _, set := range s.networkingIstioIov1Alpha3ServiceEntries {
		networkingIstioIov1Alpha3ServiceEntrySet = networkingIstioIov1Alpha3ServiceEntrySet.Union(set.Set())
	}
	snapshotMap["networkingIstioIov1Alpha3ServiceEntries"] = networkingIstioIov1Alpha3ServiceEntrySet.List()
	networkingIstioIov1Alpha3VirtualServiceSet := networking_istio_io_v1alpha3_sets.NewVirtualServiceSet()
	for _, set := range s.networkingIstioIov1Alpha3VirtualServices {
		networkingIstioIov1Alpha3VirtualServiceSet = networkingIstioIov1Alpha3VirtualServiceSet.Union(set.Set())
	}
	snapshotMap["networkingIstioIov1Alpha3VirtualServices"] = networkingIstioIov1Alpha3VirtualServiceSet.List()

	securityIstioIov1Beta1AuthorizationPolicySet := security_istio_io_v1beta1_sets.NewAuthorizationPolicySet()
	for _, set := range s.securityIstioIov1Beta1AuthorizationPolicies {
		securityIstioIov1Beta1AuthorizationPolicySet = securityIstioIov1Beta1AuthorizationPolicySet.Union(set.Set())
	}
	snapshotMap["securityIstioIov1Beta1AuthorizationPolicies"] = securityIstioIov1Beta1AuthorizationPolicySet.List()

	v1ConfigMapSet := v1_sets.NewConfigMapSet()
	for _, set := range s.v1ConfigMaps {
		v1ConfigMapSet = v1ConfigMapSet.Union(set.Set())
	}
	snapshotMap["v1ConfigMaps"] = v1ConfigMapSet.List()

	snapshotMap["clusters"] = s.clusters

	return json.Marshal(snapshotMap)
}

// LabeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet represents a set of certificatesMeshGlooSoloIov1Alpha2IssuedCertificates
// which share a common set of labels.
// These labels are used to find diffs between CertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSets.
type LabeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet interface {
	// returns the set of Labels shared by this CertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet
	Labels() map[string]string

	// returns the set of IssuedCertificatees with the given labels
	Set() certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet struct {
	set    certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet
	labels map[string]string
}

func NewLabeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet(set certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet, labels map[string]string) (LabeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet, error) {
	// validate that each IssuedCertificate contains the labels, else this is not a valid LabeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on CertificatesMeshGlooSoloIov1Alpha2IssuedCertificate %v", k, v, item.Name)
			}
		}
	}

	return &labeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet{set: set, labels: labels}, nil
}

func (l *labeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet) Set() certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet {
	return l.set
}

func (l labeledCertificatesMeshGlooSoloIov1Alpha2IssuedCertificateSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list certificates_mesh_gloo_solo_io_v1alpha2.IssuedCertificateList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "IssuedCertificate",
	}
}

// LabeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet represents a set of certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives
// which share a common set of labels.
// These labels are used to find diffs between CertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSets.
type LabeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet interface {
	// returns the set of Labels shared by this CertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet
	Labels() map[string]string

	// returns the set of PodBounceDirectivees with the given labels
	Set() certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet struct {
	set    certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet
	labels map[string]string
}

func NewLabeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet(set certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet, labels map[string]string) (LabeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet, error) {
	// validate that each PodBounceDirective contains the labels, else this is not a valid LabeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on CertificatesMeshGlooSoloIov1Alpha2PodBounceDirective %v", k, v, item.Name)
			}
		}
	}

	return &labeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet{set: set, labels: labels}, nil
}

func (l *labeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet) Set() certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet {
	return l.set
}

func (l labeledCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list certificates_mesh_gloo_solo_io_v1alpha2.PodBounceDirectiveList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "PodBounceDirective",
	}
}

// LabeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet represents a set of xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs
// which share a common set of labels.
// These labels are used to find diffs between XdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSets.
type LabeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet interface {
	// returns the set of Labels shared by this XdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet
	Labels() map[string]string

	// returns the set of XdsConfiges with the given labels
	Set() xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet struct {
	set    xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet
	labels map[string]string
}

func NewLabeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet(set xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet, labels map[string]string) (LabeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet, error) {
	// validate that each XdsConfig contains the labels, else this is not a valid LabeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on XdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfig %v", k, v, item.Name)
			}
		}
	}

	return &labeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet{set: set, labels: labels}, nil
}

func (l *labeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet) Set() xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet {
	return l.set
}

func (l labeledXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1.XdsConfigList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "XdsConfig",
	}
}

// LabeledNetworkingIstioIov1Alpha3DestinationRuleSet represents a set of networkingIstioIov1Alpha3DestinationRules
// which share a common set of labels.
// These labels are used to find diffs between NetworkingIstioIov1Alpha3DestinationRuleSets.
type LabeledNetworkingIstioIov1Alpha3DestinationRuleSet interface {
	// returns the set of Labels shared by this NetworkingIstioIov1Alpha3DestinationRuleSet
	Labels() map[string]string

	// returns the set of DestinationRulees with the given labels
	Set() networking_istio_io_v1alpha3_sets.DestinationRuleSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledNetworkingIstioIov1Alpha3DestinationRuleSet struct {
	set    networking_istio_io_v1alpha3_sets.DestinationRuleSet
	labels map[string]string
}

func NewLabeledNetworkingIstioIov1Alpha3DestinationRuleSet(set networking_istio_io_v1alpha3_sets.DestinationRuleSet, labels map[string]string) (LabeledNetworkingIstioIov1Alpha3DestinationRuleSet, error) {
	// validate that each DestinationRule contains the labels, else this is not a valid LabeledNetworkingIstioIov1Alpha3DestinationRuleSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on NetworkingIstioIov1Alpha3DestinationRule %v", k, v, item.Name)
			}
		}
	}

	return &labeledNetworkingIstioIov1Alpha3DestinationRuleSet{set: set, labels: labels}, nil
}

func (l *labeledNetworkingIstioIov1Alpha3DestinationRuleSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledNetworkingIstioIov1Alpha3DestinationRuleSet) Set() networking_istio_io_v1alpha3_sets.DestinationRuleSet {
	return l.set
}

func (l labeledNetworkingIstioIov1Alpha3DestinationRuleSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list networking_istio_io_v1alpha3.DestinationRuleList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "DestinationRule",
	}
}

// LabeledNetworkingIstioIov1Alpha3EnvoyFilterSet represents a set of networkingIstioIov1Alpha3EnvoyFilters
// which share a common set of labels.
// These labels are used to find diffs between NetworkingIstioIov1Alpha3EnvoyFilterSets.
type LabeledNetworkingIstioIov1Alpha3EnvoyFilterSet interface {
	// returns the set of Labels shared by this NetworkingIstioIov1Alpha3EnvoyFilterSet
	Labels() map[string]string

	// returns the set of EnvoyFilteres with the given labels
	Set() networking_istio_io_v1alpha3_sets.EnvoyFilterSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledNetworkingIstioIov1Alpha3EnvoyFilterSet struct {
	set    networking_istio_io_v1alpha3_sets.EnvoyFilterSet
	labels map[string]string
}

func NewLabeledNetworkingIstioIov1Alpha3EnvoyFilterSet(set networking_istio_io_v1alpha3_sets.EnvoyFilterSet, labels map[string]string) (LabeledNetworkingIstioIov1Alpha3EnvoyFilterSet, error) {
	// validate that each EnvoyFilter contains the labels, else this is not a valid LabeledNetworkingIstioIov1Alpha3EnvoyFilterSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on NetworkingIstioIov1Alpha3EnvoyFilter %v", k, v, item.Name)
			}
		}
	}

	return &labeledNetworkingIstioIov1Alpha3EnvoyFilterSet{set: set, labels: labels}, nil
}

func (l *labeledNetworkingIstioIov1Alpha3EnvoyFilterSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledNetworkingIstioIov1Alpha3EnvoyFilterSet) Set() networking_istio_io_v1alpha3_sets.EnvoyFilterSet {
	return l.set
}

func (l labeledNetworkingIstioIov1Alpha3EnvoyFilterSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list networking_istio_io_v1alpha3.EnvoyFilterList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "EnvoyFilter",
	}
}

// LabeledNetworkingIstioIov1Alpha3GatewaySet represents a set of networkingIstioIov1Alpha3Gateways
// which share a common set of labels.
// These labels are used to find diffs between NetworkingIstioIov1Alpha3GatewaySets.
type LabeledNetworkingIstioIov1Alpha3GatewaySet interface {
	// returns the set of Labels shared by this NetworkingIstioIov1Alpha3GatewaySet
	Labels() map[string]string

	// returns the set of Gatewayes with the given labels
	Set() networking_istio_io_v1alpha3_sets.GatewaySet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledNetworkingIstioIov1Alpha3GatewaySet struct {
	set    networking_istio_io_v1alpha3_sets.GatewaySet
	labels map[string]string
}

func NewLabeledNetworkingIstioIov1Alpha3GatewaySet(set networking_istio_io_v1alpha3_sets.GatewaySet, labels map[string]string) (LabeledNetworkingIstioIov1Alpha3GatewaySet, error) {
	// validate that each Gateway contains the labels, else this is not a valid LabeledNetworkingIstioIov1Alpha3GatewaySet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on NetworkingIstioIov1Alpha3Gateway %v", k, v, item.Name)
			}
		}
	}

	return &labeledNetworkingIstioIov1Alpha3GatewaySet{set: set, labels: labels}, nil
}

func (l *labeledNetworkingIstioIov1Alpha3GatewaySet) Labels() map[string]string {
	return l.labels
}

func (l *labeledNetworkingIstioIov1Alpha3GatewaySet) Set() networking_istio_io_v1alpha3_sets.GatewaySet {
	return l.set
}

func (l labeledNetworkingIstioIov1Alpha3GatewaySet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list networking_istio_io_v1alpha3.GatewayList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "Gateway",
	}
}

// LabeledNetworkingIstioIov1Alpha3ServiceEntrySet represents a set of networkingIstioIov1Alpha3ServiceEntries
// which share a common set of labels.
// These labels are used to find diffs between NetworkingIstioIov1Alpha3ServiceEntrySets.
type LabeledNetworkingIstioIov1Alpha3ServiceEntrySet interface {
	// returns the set of Labels shared by this NetworkingIstioIov1Alpha3ServiceEntrySet
	Labels() map[string]string

	// returns the set of ServiceEntryes with the given labels
	Set() networking_istio_io_v1alpha3_sets.ServiceEntrySet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledNetworkingIstioIov1Alpha3ServiceEntrySet struct {
	set    networking_istio_io_v1alpha3_sets.ServiceEntrySet
	labels map[string]string
}

func NewLabeledNetworkingIstioIov1Alpha3ServiceEntrySet(set networking_istio_io_v1alpha3_sets.ServiceEntrySet, labels map[string]string) (LabeledNetworkingIstioIov1Alpha3ServiceEntrySet, error) {
	// validate that each ServiceEntry contains the labels, else this is not a valid LabeledNetworkingIstioIov1Alpha3ServiceEntrySet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on NetworkingIstioIov1Alpha3ServiceEntry %v", k, v, item.Name)
			}
		}
	}

	return &labeledNetworkingIstioIov1Alpha3ServiceEntrySet{set: set, labels: labels}, nil
}

func (l *labeledNetworkingIstioIov1Alpha3ServiceEntrySet) Labels() map[string]string {
	return l.labels
}

func (l *labeledNetworkingIstioIov1Alpha3ServiceEntrySet) Set() networking_istio_io_v1alpha3_sets.ServiceEntrySet {
	return l.set
}

func (l labeledNetworkingIstioIov1Alpha3ServiceEntrySet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list networking_istio_io_v1alpha3.ServiceEntryList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "ServiceEntry",
	}
}

// LabeledNetworkingIstioIov1Alpha3VirtualServiceSet represents a set of networkingIstioIov1Alpha3VirtualServices
// which share a common set of labels.
// These labels are used to find diffs between NetworkingIstioIov1Alpha3VirtualServiceSets.
type LabeledNetworkingIstioIov1Alpha3VirtualServiceSet interface {
	// returns the set of Labels shared by this NetworkingIstioIov1Alpha3VirtualServiceSet
	Labels() map[string]string

	// returns the set of VirtualServicees with the given labels
	Set() networking_istio_io_v1alpha3_sets.VirtualServiceSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledNetworkingIstioIov1Alpha3VirtualServiceSet struct {
	set    networking_istio_io_v1alpha3_sets.VirtualServiceSet
	labels map[string]string
}

func NewLabeledNetworkingIstioIov1Alpha3VirtualServiceSet(set networking_istio_io_v1alpha3_sets.VirtualServiceSet, labels map[string]string) (LabeledNetworkingIstioIov1Alpha3VirtualServiceSet, error) {
	// validate that each VirtualService contains the labels, else this is not a valid LabeledNetworkingIstioIov1Alpha3VirtualServiceSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on NetworkingIstioIov1Alpha3VirtualService %v", k, v, item.Name)
			}
		}
	}

	return &labeledNetworkingIstioIov1Alpha3VirtualServiceSet{set: set, labels: labels}, nil
}

func (l *labeledNetworkingIstioIov1Alpha3VirtualServiceSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledNetworkingIstioIov1Alpha3VirtualServiceSet) Set() networking_istio_io_v1alpha3_sets.VirtualServiceSet {
	return l.set
}

func (l labeledNetworkingIstioIov1Alpha3VirtualServiceSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list networking_istio_io_v1alpha3.VirtualServiceList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "VirtualService",
	}
}

// LabeledSecurityIstioIov1Beta1AuthorizationPolicySet represents a set of securityIstioIov1Beta1AuthorizationPolicies
// which share a common set of labels.
// These labels are used to find diffs between SecurityIstioIov1Beta1AuthorizationPolicySets.
type LabeledSecurityIstioIov1Beta1AuthorizationPolicySet interface {
	// returns the set of Labels shared by this SecurityIstioIov1Beta1AuthorizationPolicySet
	Labels() map[string]string

	// returns the set of AuthorizationPolicyes with the given labels
	Set() security_istio_io_v1beta1_sets.AuthorizationPolicySet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledSecurityIstioIov1Beta1AuthorizationPolicySet struct {
	set    security_istio_io_v1beta1_sets.AuthorizationPolicySet
	labels map[string]string
}

func NewLabeledSecurityIstioIov1Beta1AuthorizationPolicySet(set security_istio_io_v1beta1_sets.AuthorizationPolicySet, labels map[string]string) (LabeledSecurityIstioIov1Beta1AuthorizationPolicySet, error) {
	// validate that each AuthorizationPolicy contains the labels, else this is not a valid LabeledSecurityIstioIov1Beta1AuthorizationPolicySet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on SecurityIstioIov1Beta1AuthorizationPolicy %v", k, v, item.Name)
			}
		}
	}

	return &labeledSecurityIstioIov1Beta1AuthorizationPolicySet{set: set, labels: labels}, nil
}

func (l *labeledSecurityIstioIov1Beta1AuthorizationPolicySet) Labels() map[string]string {
	return l.labels
}

func (l *labeledSecurityIstioIov1Beta1AuthorizationPolicySet) Set() security_istio_io_v1beta1_sets.AuthorizationPolicySet {
	return l.set
}

func (l labeledSecurityIstioIov1Beta1AuthorizationPolicySet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list security_istio_io_v1beta1.AuthorizationPolicyList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "AuthorizationPolicy",
	}
}

// LabeledV1ConfigMapSet represents a set of v1ConfigMaps
// which share a common set of labels.
// These labels are used to find diffs between V1ConfigMapSets.
type LabeledV1ConfigMapSet interface {
	// returns the set of Labels shared by this V1ConfigMapSet
	Labels() map[string]string

	// returns the set of ConfigMapes with the given labels
	Set() v1_sets.ConfigMapSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledV1ConfigMapSet struct {
	set    v1_sets.ConfigMapSet
	labels map[string]string
}

func NewLabeledV1ConfigMapSet(set v1_sets.ConfigMapSet, labels map[string]string) (LabeledV1ConfigMapSet, error) {
	// validate that each ConfigMap contains the labels, else this is not a valid LabeledV1ConfigMapSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on V1ConfigMap %v", k, v, item.Name)
			}
		}
	}

	return &labeledV1ConfigMapSet{set: set, labels: labels}, nil
}

func (l *labeledV1ConfigMapSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledV1ConfigMapSet) Set() v1_sets.ConfigMapSet {
	return l.set
}

func (l labeledV1ConfigMapSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list v1.ConfigMapList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "ConfigMap",
	}
}

type builder struct {
	ctx      context.Context
	name     string
	clusters []string

	certificatesMeshGlooSoloIov1Alpha2IssuedCertificates  certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet
	certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet

	xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet

	networkingIstioIov1Alpha3DestinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet
	networkingIstioIov1Alpha3EnvoyFilters     networking_istio_io_v1alpha3_sets.EnvoyFilterSet
	networkingIstioIov1Alpha3Gateways         networking_istio_io_v1alpha3_sets.GatewaySet
	networkingIstioIov1Alpha3ServiceEntries   networking_istio_io_v1alpha3_sets.ServiceEntrySet
	networkingIstioIov1Alpha3VirtualServices  networking_istio_io_v1alpha3_sets.VirtualServiceSet

	securityIstioIov1Beta1AuthorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet

	v1ConfigMaps v1_sets.ConfigMapSet
}

func NewBuilder(ctx context.Context, name string) *builder {
	return &builder{
		ctx:  ctx,
		name: name,

		certificatesMeshGlooSoloIov1Alpha2IssuedCertificates:  certificates_mesh_gloo_solo_io_v1alpha2_sets.NewIssuedCertificateSet(),
		certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives: certificates_mesh_gloo_solo_io_v1alpha2_sets.NewPodBounceDirectiveSet(),

		xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs: xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.NewXdsConfigSet(),

		networkingIstioIov1Alpha3DestinationRules: networking_istio_io_v1alpha3_sets.NewDestinationRuleSet(),
		networkingIstioIov1Alpha3EnvoyFilters:     networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet(),
		networkingIstioIov1Alpha3Gateways:         networking_istio_io_v1alpha3_sets.NewGatewaySet(),
		networkingIstioIov1Alpha3ServiceEntries:   networking_istio_io_v1alpha3_sets.NewServiceEntrySet(),
		networkingIstioIov1Alpha3VirtualServices:  networking_istio_io_v1alpha3_sets.NewVirtualServiceSet(),

		securityIstioIov1Beta1AuthorizationPolicies: security_istio_io_v1beta1_sets.NewAuthorizationPolicySet(),

		v1ConfigMaps: v1_sets.NewConfigMapSet(),
	}
}

// the output Builder uses a builder pattern to allow
// iteratively collecting outputs before producing a final snapshot
type Builder interface {

	// add CertificatesMeshGlooSoloIov1Alpha2IssuedCertificates to the collected outputs
	AddCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates(certificatesMeshGlooSoloIov1Alpha2IssuedCertificates ...*certificates_mesh_gloo_solo_io_v1alpha2.IssuedCertificate)

	// get the collected CertificatesMeshGlooSoloIov1Alpha2IssuedCertificates
	GetCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates() certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet

	// add CertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives to the collected outputs
	AddCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives(certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives ...*certificates_mesh_gloo_solo_io_v1alpha2.PodBounceDirective)

	// get the collected CertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives
	GetCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives() certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet

	// add XdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs to the collected outputs
	AddXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs(xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs ...*xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1.XdsConfig)

	// get the collected XdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs
	GetXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs() xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet

	// add NetworkingIstioIov1Alpha3DestinationRules to the collected outputs
	AddNetworkingIstioIov1Alpha3DestinationRules(networkingIstioIov1Alpha3DestinationRules ...*networking_istio_io_v1alpha3.DestinationRule)

	// get the collected NetworkingIstioIov1Alpha3DestinationRules
	GetNetworkingIstioIov1Alpha3DestinationRules() networking_istio_io_v1alpha3_sets.DestinationRuleSet

	// add NetworkingIstioIov1Alpha3EnvoyFilters to the collected outputs
	AddNetworkingIstioIov1Alpha3EnvoyFilters(networkingIstioIov1Alpha3EnvoyFilters ...*networking_istio_io_v1alpha3.EnvoyFilter)

	// get the collected NetworkingIstioIov1Alpha3EnvoyFilters
	GetNetworkingIstioIov1Alpha3EnvoyFilters() networking_istio_io_v1alpha3_sets.EnvoyFilterSet

	// add NetworkingIstioIov1Alpha3Gateways to the collected outputs
	AddNetworkingIstioIov1Alpha3Gateways(networkingIstioIov1Alpha3Gateways ...*networking_istio_io_v1alpha3.Gateway)

	// get the collected NetworkingIstioIov1Alpha3Gateways
	GetNetworkingIstioIov1Alpha3Gateways() networking_istio_io_v1alpha3_sets.GatewaySet

	// add NetworkingIstioIov1Alpha3ServiceEntries to the collected outputs
	AddNetworkingIstioIov1Alpha3ServiceEntries(networkingIstioIov1Alpha3ServiceEntries ...*networking_istio_io_v1alpha3.ServiceEntry)

	// get the collected NetworkingIstioIov1Alpha3ServiceEntries
	GetNetworkingIstioIov1Alpha3ServiceEntries() networking_istio_io_v1alpha3_sets.ServiceEntrySet

	// add NetworkingIstioIov1Alpha3VirtualServices to the collected outputs
	AddNetworkingIstioIov1Alpha3VirtualServices(networkingIstioIov1Alpha3VirtualServices ...*networking_istio_io_v1alpha3.VirtualService)

	// get the collected NetworkingIstioIov1Alpha3VirtualServices
	GetNetworkingIstioIov1Alpha3VirtualServices() networking_istio_io_v1alpha3_sets.VirtualServiceSet

	// add SecurityIstioIov1Beta1AuthorizationPolicies to the collected outputs
	AddSecurityIstioIov1Beta1AuthorizationPolicies(securityIstioIov1Beta1AuthorizationPolicies ...*security_istio_io_v1beta1.AuthorizationPolicy)

	// get the collected SecurityIstioIov1Beta1AuthorizationPolicies
	GetSecurityIstioIov1Beta1AuthorizationPolicies() security_istio_io_v1beta1_sets.AuthorizationPolicySet

	// add V1ConfigMaps to the collected outputs
	AddV1ConfigMaps(v1ConfigMaps ...*v1.ConfigMap)

	// get the collected V1ConfigMaps
	GetV1ConfigMaps() v1_sets.ConfigMapSet

	// build the collected outputs into a label-partitioned snapshot
	BuildLabelPartitionedSnapshot(labelKey string) (Snapshot, error)

	// build the collected outputs into a snapshot with a single partition
	BuildSinglePartitionedSnapshot(snapshotLabels map[string]string) (Snapshot, error)

	// add a cluster to the collected clusters.
	// this can be used to collect clusters for use with MultiCluster snapshots.
	AddCluster(cluster string)

	// returns the set of clusters currently stored in this builder
	Clusters() []string

	// merge all the resources from another Builder into this one
	Merge(other Builder)

	// create a clone of this builder (deepcopying all resources)
	Clone() Builder

	// return the difference between the snapshot in this builder's and another
	Delta(newSnap Builder) output.SnapshotDelta
}

func (b *builder) AddCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates(certificatesMeshGlooSoloIov1Alpha2IssuedCertificates ...*certificates_mesh_gloo_solo_io_v1alpha2.IssuedCertificate) {
	for _, obj := range certificatesMeshGlooSoloIov1Alpha2IssuedCertificates {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output CertificatesMeshGlooSoloIov1Alpha2IssuedCertificate %v", sets.Key(obj))
		b.certificatesMeshGlooSoloIov1Alpha2IssuedCertificates.Insert(obj)
	}
}
func (b *builder) AddCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives(certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives ...*certificates_mesh_gloo_solo_io_v1alpha2.PodBounceDirective) {
	for _, obj := range certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output CertificatesMeshGlooSoloIov1Alpha2PodBounceDirective %v", sets.Key(obj))
		b.certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives.Insert(obj)
	}
}
func (b *builder) AddXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs(xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs ...*xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1.XdsConfig) {
	for _, obj := range xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output XdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfig %v", sets.Key(obj))
		b.xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs.Insert(obj)
	}
}
func (b *builder) AddNetworkingIstioIov1Alpha3DestinationRules(networkingIstioIov1Alpha3DestinationRules ...*networking_istio_io_v1alpha3.DestinationRule) {
	for _, obj := range networkingIstioIov1Alpha3DestinationRules {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output NetworkingIstioIov1Alpha3DestinationRule %v", sets.Key(obj))
		b.networkingIstioIov1Alpha3DestinationRules.Insert(obj)
	}
}
func (b *builder) AddNetworkingIstioIov1Alpha3EnvoyFilters(networkingIstioIov1Alpha3EnvoyFilters ...*networking_istio_io_v1alpha3.EnvoyFilter) {
	for _, obj := range networkingIstioIov1Alpha3EnvoyFilters {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output NetworkingIstioIov1Alpha3EnvoyFilter %v", sets.Key(obj))
		b.networkingIstioIov1Alpha3EnvoyFilters.Insert(obj)
	}
}
func (b *builder) AddNetworkingIstioIov1Alpha3Gateways(networkingIstioIov1Alpha3Gateways ...*networking_istio_io_v1alpha3.Gateway) {
	for _, obj := range networkingIstioIov1Alpha3Gateways {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output NetworkingIstioIov1Alpha3Gateway %v", sets.Key(obj))
		b.networkingIstioIov1Alpha3Gateways.Insert(obj)
	}
}
func (b *builder) AddNetworkingIstioIov1Alpha3ServiceEntries(networkingIstioIov1Alpha3ServiceEntries ...*networking_istio_io_v1alpha3.ServiceEntry) {
	for _, obj := range networkingIstioIov1Alpha3ServiceEntries {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output NetworkingIstioIov1Alpha3ServiceEntry %v", sets.Key(obj))
		b.networkingIstioIov1Alpha3ServiceEntries.Insert(obj)
	}
}
func (b *builder) AddNetworkingIstioIov1Alpha3VirtualServices(networkingIstioIov1Alpha3VirtualServices ...*networking_istio_io_v1alpha3.VirtualService) {
	for _, obj := range networkingIstioIov1Alpha3VirtualServices {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output NetworkingIstioIov1Alpha3VirtualService %v", sets.Key(obj))
		b.networkingIstioIov1Alpha3VirtualServices.Insert(obj)
	}
}
func (b *builder) AddSecurityIstioIov1Beta1AuthorizationPolicies(securityIstioIov1Beta1AuthorizationPolicies ...*security_istio_io_v1beta1.AuthorizationPolicy) {
	for _, obj := range securityIstioIov1Beta1AuthorizationPolicies {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output SecurityIstioIov1Beta1AuthorizationPolicy %v", sets.Key(obj))
		b.securityIstioIov1Beta1AuthorizationPolicies.Insert(obj)
	}
}
func (b *builder) AddV1ConfigMaps(v1ConfigMaps ...*v1.ConfigMap) {
	for _, obj := range v1ConfigMaps {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output V1ConfigMap %v", sets.Key(obj))
		b.v1ConfigMaps.Insert(obj)
	}
}

func (b *builder) GetCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates() certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet {
	return b.certificatesMeshGlooSoloIov1Alpha2IssuedCertificates
}
func (b *builder) GetCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives() certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet {
	return b.certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives
}

func (b *builder) GetXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs() xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet {
	return b.xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs
}

func (b *builder) GetNetworkingIstioIov1Alpha3DestinationRules() networking_istio_io_v1alpha3_sets.DestinationRuleSet {
	return b.networkingIstioIov1Alpha3DestinationRules
}
func (b *builder) GetNetworkingIstioIov1Alpha3EnvoyFilters() networking_istio_io_v1alpha3_sets.EnvoyFilterSet {
	return b.networkingIstioIov1Alpha3EnvoyFilters
}
func (b *builder) GetNetworkingIstioIov1Alpha3Gateways() networking_istio_io_v1alpha3_sets.GatewaySet {
	return b.networkingIstioIov1Alpha3Gateways
}
func (b *builder) GetNetworkingIstioIov1Alpha3ServiceEntries() networking_istio_io_v1alpha3_sets.ServiceEntrySet {
	return b.networkingIstioIov1Alpha3ServiceEntries
}
func (b *builder) GetNetworkingIstioIov1Alpha3VirtualServices() networking_istio_io_v1alpha3_sets.VirtualServiceSet {
	return b.networkingIstioIov1Alpha3VirtualServices
}

func (b *builder) GetSecurityIstioIov1Beta1AuthorizationPolicies() security_istio_io_v1beta1_sets.AuthorizationPolicySet {
	return b.securityIstioIov1Beta1AuthorizationPolicies
}

func (b *builder) GetV1ConfigMaps() v1_sets.ConfigMapSet {
	return b.v1ConfigMaps
}

func (b *builder) BuildLabelPartitionedSnapshot(labelKey string) (Snapshot, error) {
	return NewLabelPartitionedSnapshot(
		b.name,
		labelKey,

		b.certificatesMeshGlooSoloIov1Alpha2IssuedCertificates,
		b.certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives,

		b.xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs,

		b.networkingIstioIov1Alpha3DestinationRules,
		b.networkingIstioIov1Alpha3EnvoyFilters,
		b.networkingIstioIov1Alpha3Gateways,
		b.networkingIstioIov1Alpha3ServiceEntries,
		b.networkingIstioIov1Alpha3VirtualServices,

		b.securityIstioIov1Beta1AuthorizationPolicies,

		b.v1ConfigMaps,
		b.clusters...,
	)
}

func (b *builder) BuildSinglePartitionedSnapshot(snapshotLabels map[string]string) (Snapshot, error) {
	return NewSinglePartitionedSnapshot(
		b.name,
		snapshotLabels,

		b.certificatesMeshGlooSoloIov1Alpha2IssuedCertificates,
		b.certificatesMeshGlooSoloIov1Alpha2PodBounceDirectives,

		b.xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs,

		b.networkingIstioIov1Alpha3DestinationRules,
		b.networkingIstioIov1Alpha3EnvoyFilters,
		b.networkingIstioIov1Alpha3Gateways,
		b.networkingIstioIov1Alpha3ServiceEntries,
		b.networkingIstioIov1Alpha3VirtualServices,

		b.securityIstioIov1Beta1AuthorizationPolicies,

		b.v1ConfigMaps,
		b.clusters...,
	)
}

func (b *builder) AddCluster(cluster string) {
	b.clusters = append(b.clusters, cluster)
}

func (b *builder) Clusters() []string {
	return b.clusters
}

func (b *builder) Merge(other Builder) {
	if other == nil {
		return
	}

	b.AddCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates(other.GetCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates().List()...)
	b.AddCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives(other.GetCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives().List()...)

	b.AddXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs(other.GetXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs().List()...)

	b.AddNetworkingIstioIov1Alpha3DestinationRules(other.GetNetworkingIstioIov1Alpha3DestinationRules().List()...)
	b.AddNetworkingIstioIov1Alpha3EnvoyFilters(other.GetNetworkingIstioIov1Alpha3EnvoyFilters().List()...)
	b.AddNetworkingIstioIov1Alpha3Gateways(other.GetNetworkingIstioIov1Alpha3Gateways().List()...)
	b.AddNetworkingIstioIov1Alpha3ServiceEntries(other.GetNetworkingIstioIov1Alpha3ServiceEntries().List()...)
	b.AddNetworkingIstioIov1Alpha3VirtualServices(other.GetNetworkingIstioIov1Alpha3VirtualServices().List()...)

	b.AddSecurityIstioIov1Beta1AuthorizationPolicies(other.GetSecurityIstioIov1Beta1AuthorizationPolicies().List()...)

	b.AddV1ConfigMaps(other.GetV1ConfigMaps().List()...)
	for _, cluster := range other.Clusters() {
		b.AddCluster(cluster)
	}
}

func (b *builder) Clone() Builder {
	if b == nil {
		return nil
	}
	clone := NewBuilder(b.ctx, b.name)

	for _, certificatesMeshGlooSoloIov1Alpha2IssuedCertificate := range b.GetCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates().List() {
		clone.AddCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates(certificatesMeshGlooSoloIov1Alpha2IssuedCertificate.DeepCopy())
	}
	for _, certificatesMeshGlooSoloIov1Alpha2PodBounceDirective := range b.GetCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives().List() {
		clone.AddCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives(certificatesMeshGlooSoloIov1Alpha2PodBounceDirective.DeepCopy())
	}

	for _, xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfig := range b.GetXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs().List() {
		clone.AddXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs(xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfig.DeepCopy())
	}

	for _, networkingIstioIov1Alpha3DestinationRule := range b.GetNetworkingIstioIov1Alpha3DestinationRules().List() {
		clone.AddNetworkingIstioIov1Alpha3DestinationRules(networkingIstioIov1Alpha3DestinationRule.DeepCopy())
	}
	for _, networkingIstioIov1Alpha3EnvoyFilter := range b.GetNetworkingIstioIov1Alpha3EnvoyFilters().List() {
		clone.AddNetworkingIstioIov1Alpha3EnvoyFilters(networkingIstioIov1Alpha3EnvoyFilter.DeepCopy())
	}
	for _, networkingIstioIov1Alpha3Gateway := range b.GetNetworkingIstioIov1Alpha3Gateways().List() {
		clone.AddNetworkingIstioIov1Alpha3Gateways(networkingIstioIov1Alpha3Gateway.DeepCopy())
	}
	for _, networkingIstioIov1Alpha3ServiceEntry := range b.GetNetworkingIstioIov1Alpha3ServiceEntries().List() {
		clone.AddNetworkingIstioIov1Alpha3ServiceEntries(networkingIstioIov1Alpha3ServiceEntry.DeepCopy())
	}
	for _, networkingIstioIov1Alpha3VirtualService := range b.GetNetworkingIstioIov1Alpha3VirtualServices().List() {
		clone.AddNetworkingIstioIov1Alpha3VirtualServices(networkingIstioIov1Alpha3VirtualService.DeepCopy())
	}

	for _, securityIstioIov1Beta1AuthorizationPolicy := range b.GetSecurityIstioIov1Beta1AuthorizationPolicies().List() {
		clone.AddSecurityIstioIov1Beta1AuthorizationPolicies(securityIstioIov1Beta1AuthorizationPolicy.DeepCopy())
	}

	for _, v1ConfigMap := range b.GetV1ConfigMaps().List() {
		clone.AddV1ConfigMaps(v1ConfigMap.DeepCopy())
	}
	for _, cluster := range b.Clusters() {
		clone.AddCluster(cluster)
	}
	return clone
}

func (b *builder) Delta(other Builder) output.SnapshotDelta {
	delta := output.SnapshotDelta{}
	if b == nil {
		return delta
	}

	// calculate delta between IssuedCertificates
	certificatesMeshGlooSoloIov1Alpha2IssuedCertificateDelta := b.GetCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates().Delta(other.GetCertificatesMeshGlooSoloIov1Alpha2IssuedCertificates())
	certificatesMeshGlooSoloIov1Alpha2IssuedCertificateGvk := schema.GroupVersionKind{
		Group:   "certificates.mesh.gloo.solo.io",
		Version: "v1alpha2",
		Kind:    "IssuedCertificate",
	}
	delta.AddInserted(certificatesMeshGlooSoloIov1Alpha2IssuedCertificateGvk, certificatesMeshGlooSoloIov1Alpha2IssuedCertificateDelta.Inserted)
	delta.AddRemoved(certificatesMeshGlooSoloIov1Alpha2IssuedCertificateGvk, certificatesMeshGlooSoloIov1Alpha2IssuedCertificateDelta.Removed)
	// calculate delta between PodBounceDirectives
	certificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveDelta := b.GetCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives().Delta(other.GetCertificatesMeshGlooSoloIov1Alpha2PodBounceDirectives())
	certificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveGvk := schema.GroupVersionKind{
		Group:   "certificates.mesh.gloo.solo.io",
		Version: "v1alpha2",
		Kind:    "PodBounceDirective",
	}
	delta.AddInserted(certificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveGvk, certificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveDelta.Inserted)
	delta.AddRemoved(certificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveGvk, certificatesMeshGlooSoloIov1Alpha2PodBounceDirectiveDelta.Removed)

	// calculate delta between XdsConfigs
	xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigDelta := b.GetXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs().Delta(other.GetXdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigs())
	xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigGvk := schema.GroupVersionKind{
		Group:   "xds.agent.enterprise.mesh.gloo.solo.io",
		Version: "v1alpha1",
		Kind:    "XdsConfig",
	}
	delta.AddInserted(xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigGvk, xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigDelta.Inserted)
	delta.AddRemoved(xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigGvk, xdsAgentEnterpriseMeshGlooSoloIov1Alpha1XdsConfigDelta.Removed)

	// calculate delta between DestinationRules
	networkingIstioIov1Alpha3DestinationRuleDelta := b.GetNetworkingIstioIov1Alpha3DestinationRules().Delta(other.GetNetworkingIstioIov1Alpha3DestinationRules())
	networkingIstioIov1Alpha3DestinationRuleGvk := schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "DestinationRule",
	}
	delta.AddInserted(networkingIstioIov1Alpha3DestinationRuleGvk, networkingIstioIov1Alpha3DestinationRuleDelta.Inserted)
	delta.AddRemoved(networkingIstioIov1Alpha3DestinationRuleGvk, networkingIstioIov1Alpha3DestinationRuleDelta.Removed)
	// calculate delta between EnvoyFilters
	networkingIstioIov1Alpha3EnvoyFilterDelta := b.GetNetworkingIstioIov1Alpha3EnvoyFilters().Delta(other.GetNetworkingIstioIov1Alpha3EnvoyFilters())
	networkingIstioIov1Alpha3EnvoyFilterGvk := schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "EnvoyFilter",
	}
	delta.AddInserted(networkingIstioIov1Alpha3EnvoyFilterGvk, networkingIstioIov1Alpha3EnvoyFilterDelta.Inserted)
	delta.AddRemoved(networkingIstioIov1Alpha3EnvoyFilterGvk, networkingIstioIov1Alpha3EnvoyFilterDelta.Removed)
	// calculate delta between Gateways
	networkingIstioIov1Alpha3GatewayDelta := b.GetNetworkingIstioIov1Alpha3Gateways().Delta(other.GetNetworkingIstioIov1Alpha3Gateways())
	networkingIstioIov1Alpha3GatewayGvk := schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "Gateway",
	}
	delta.AddInserted(networkingIstioIov1Alpha3GatewayGvk, networkingIstioIov1Alpha3GatewayDelta.Inserted)
	delta.AddRemoved(networkingIstioIov1Alpha3GatewayGvk, networkingIstioIov1Alpha3GatewayDelta.Removed)
	// calculate delta between ServiceEntries
	networkingIstioIov1Alpha3ServiceEntryDelta := b.GetNetworkingIstioIov1Alpha3ServiceEntries().Delta(other.GetNetworkingIstioIov1Alpha3ServiceEntries())
	networkingIstioIov1Alpha3ServiceEntryGvk := schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "ServiceEntry",
	}
	delta.AddInserted(networkingIstioIov1Alpha3ServiceEntryGvk, networkingIstioIov1Alpha3ServiceEntryDelta.Inserted)
	delta.AddRemoved(networkingIstioIov1Alpha3ServiceEntryGvk, networkingIstioIov1Alpha3ServiceEntryDelta.Removed)
	// calculate delta between VirtualServices
	networkingIstioIov1Alpha3VirtualServiceDelta := b.GetNetworkingIstioIov1Alpha3VirtualServices().Delta(other.GetNetworkingIstioIov1Alpha3VirtualServices())
	networkingIstioIov1Alpha3VirtualServiceGvk := schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "VirtualService",
	}
	delta.AddInserted(networkingIstioIov1Alpha3VirtualServiceGvk, networkingIstioIov1Alpha3VirtualServiceDelta.Inserted)
	delta.AddRemoved(networkingIstioIov1Alpha3VirtualServiceGvk, networkingIstioIov1Alpha3VirtualServiceDelta.Removed)

	// calculate delta between AuthorizationPolicies
	securityIstioIov1Beta1AuthorizationPolicyDelta := b.GetSecurityIstioIov1Beta1AuthorizationPolicies().Delta(other.GetSecurityIstioIov1Beta1AuthorizationPolicies())
	securityIstioIov1Beta1AuthorizationPolicyGvk := schema.GroupVersionKind{
		Group:   "security.istio.io",
		Version: "v1beta1",
		Kind:    "AuthorizationPolicy",
	}
	delta.AddInserted(securityIstioIov1Beta1AuthorizationPolicyGvk, securityIstioIov1Beta1AuthorizationPolicyDelta.Inserted)
	delta.AddRemoved(securityIstioIov1Beta1AuthorizationPolicyGvk, securityIstioIov1Beta1AuthorizationPolicyDelta.Removed)

	// calculate delta between ConfigMaps
	v1ConfigMapDelta := b.GetV1ConfigMaps().Delta(other.GetV1ConfigMaps())
	v1ConfigMapGvk := schema.GroupVersionKind{
		Group:   "",
		Version: "v1",
		Kind:    "ConfigMap",
	}
	delta.AddInserted(v1ConfigMapGvk, v1ConfigMapDelta.Inserted)
	delta.AddRemoved(v1ConfigMapGvk, v1ConfigMapDelta.Removed)
	return delta
}
