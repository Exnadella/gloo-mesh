// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./snapshot.go -destination mocks/snapshot.go

// Definitions for Output Snapshots
package istio

import (
	"context"
	"encoding/json"
	"sort"

	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/solo-io/go-utils/contextutils"
	"github.com/solo-io/skv2/pkg/multicluster"

	"github.com/rotisserie/eris"
	"github.com/solo-io/skv2/contrib/pkg/output"
	"github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"sigs.k8s.io/controller-runtime/pkg/client"

	certificates_mesh_gloo_solo_io_v1alpha2 "github.com/solo-io/gloo-mesh/pkg/api/certificates.mesh.gloo.solo.io/v1alpha2"
	certificates_mesh_gloo_solo_io_v1alpha2_sets "github.com/solo-io/gloo-mesh/pkg/api/certificates.mesh.gloo.solo.io/v1alpha2/sets"

	xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1 "github.com/solo-io/gloo-mesh/pkg/api/xds.agent.enterprise.mesh.gloo.solo.io/v1alpha1"
	xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets "github.com/solo-io/gloo-mesh/pkg/api/xds.agent.enterprise.mesh.gloo.solo.io/v1alpha1/sets"

	networking_istio_io_v1alpha3_sets "github.com/solo-io/external-apis/pkg/api/istio/networking.istio.io/v1alpha3/sets"
	networking_istio_io_v1alpha3 "istio.io/client-go/pkg/apis/networking/v1alpha3"

	security_istio_io_v1beta1_sets "github.com/solo-io/external-apis/pkg/api/istio/security.istio.io/v1beta1/sets"
	security_istio_io_v1beta1 "istio.io/client-go/pkg/apis/security/v1beta1"

	v1_sets "github.com/solo-io/external-apis/pkg/api/k8s/core/v1/sets"
	v1 "k8s.io/api/core/v1"
)

// this error can occur if constructing a Partitioned Snapshot from a resource
// that is missing the partition label
var MissingRequiredLabelError = func(labelKey, resourceKind string, obj ezkube.ResourceId) error {
	return eris.Errorf("expected label %v not on labels of %v %v", labelKey, resourceKind, sets.Key(obj))
}

// the snapshot of output resources produced by a translation
type Snapshot interface {

	// return the set of CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates with a given set of labels
	CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates() []LabeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet
	// return the set of CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives with a given set of labels
	CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives() []LabeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet
	// return the set of XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs with a given set of labels
	XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs() []LabeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet
	// return the set of NetworkingIstioIo_V1Alpha3_DestinationRules with a given set of labels
	NetworkingIstioIo_V1Alpha3_DestinationRules() []LabeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet
	// return the set of NetworkingIstioIo_V1Alpha3_EnvoyFilters with a given set of labels
	NetworkingIstioIo_V1Alpha3_EnvoyFilters() []LabeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet
	// return the set of NetworkingIstioIo_V1Alpha3_Gateways with a given set of labels
	NetworkingIstioIo_V1Alpha3_Gateways() []LabeledNetworkingIstioIo_V1Alpha3_GatewaySet
	// return the set of NetworkingIstioIo_V1Alpha3_ServiceEntries with a given set of labels
	NetworkingIstioIo_V1Alpha3_ServiceEntries() []LabeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet
	// return the set of NetworkingIstioIo_V1Alpha3_VirtualServices with a given set of labels
	NetworkingIstioIo_V1Alpha3_VirtualServices() []LabeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet
	// return the set of SecurityIstioIo_V1Beta1_AuthorizationPolicies with a given set of labels
	SecurityIstioIo_V1Beta1_AuthorizationPolicies() []LabeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet
	// return the set of V1_ConfigMaps with a given set of labels
	V1_ConfigMaps() []LabeledV1_ConfigMapSet

	// apply the snapshot to the local cluster, garbage collecting stale resources
	ApplyLocalCluster(ctx context.Context, clusterClient client.Client, errHandler output.ErrorHandler)

	// apply resources from the snapshot across multiple clusters, garbage collecting stale resources
	ApplyMultiCluster(ctx context.Context, multiClusterClient multicluster.Client, errHandler output.ErrorHandler)

	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)
}

type snapshot struct {
	name string

	certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates  []LabeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet
	certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives []LabeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet
	xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs    []LabeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet
	networkingIstioIoV1Alpha3DestinationRules             []LabeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet
	networkingIstioIoV1Alpha3EnvoyFilters                 []LabeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet
	networkingIstioIoV1Alpha3Gateways                     []LabeledNetworkingIstioIo_V1Alpha3_GatewaySet
	networkingIstioIoV1Alpha3ServiceEntries               []LabeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet
	networkingIstioIoV1Alpha3VirtualServices              []LabeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet
	securityIstioIoV1Beta1AuthorizationPolicies           []LabeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet
	v1ConfigMaps                                          []LabeledV1_ConfigMapSet
	clusters                                              []string
}

func NewSnapshot(
	name string,

	certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates []LabeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet,
	certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives []LabeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet,
	xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs []LabeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet,
	networkingIstioIoV1Alpha3DestinationRules []LabeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet,
	networkingIstioIoV1Alpha3EnvoyFilters []LabeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet,
	networkingIstioIoV1Alpha3Gateways []LabeledNetworkingIstioIo_V1Alpha3_GatewaySet,
	networkingIstioIoV1Alpha3ServiceEntries []LabeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet,
	networkingIstioIoV1Alpha3VirtualServices []LabeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet,
	securityIstioIoV1Beta1AuthorizationPolicies []LabeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet,
	v1ConfigMaps []LabeledV1_ConfigMapSet,
	clusters ...string, // the set of clusters to apply the snapshot to. only required for multicluster snapshots.
) Snapshot {
	return &snapshot{
		name: name,

		certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates:  certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates,
		certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives: certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives,
		xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs:    xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs,
		networkingIstioIoV1Alpha3DestinationRules:             networkingIstioIoV1Alpha3DestinationRules,
		networkingIstioIoV1Alpha3EnvoyFilters:                 networkingIstioIoV1Alpha3EnvoyFilters,
		networkingIstioIoV1Alpha3Gateways:                     networkingIstioIoV1Alpha3Gateways,
		networkingIstioIoV1Alpha3ServiceEntries:               networkingIstioIoV1Alpha3ServiceEntries,
		networkingIstioIoV1Alpha3VirtualServices:              networkingIstioIoV1Alpha3VirtualServices,
		securityIstioIoV1Beta1AuthorizationPolicies:           securityIstioIoV1Beta1AuthorizationPolicies,
		v1ConfigMaps: v1ConfigMaps,
		clusters:     clusters,
	}
}

// automatically partitions the input resources
// by the presence of the provided label.
func NewLabelPartitionedSnapshot(
	name,
	labelKey string, // the key by which to partition the resources

	certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet,
	certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet,

	xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet,

	networkingIstioIoV1Alpha3DestinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet,
	networkingIstioIoV1Alpha3EnvoyFilters networking_istio_io_v1alpha3_sets.EnvoyFilterSet,
	networkingIstioIoV1Alpha3Gateways networking_istio_io_v1alpha3_sets.GatewaySet,
	networkingIstioIoV1Alpha3ServiceEntries networking_istio_io_v1alpha3_sets.ServiceEntrySet,
	networkingIstioIoV1Alpha3VirtualServices networking_istio_io_v1alpha3_sets.VirtualServiceSet,

	securityIstioIoV1Beta1AuthorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet,

	v1ConfigMaps v1_sets.ConfigMapSet,
	clusters ...string, // the set of clusters to apply the snapshot to. only required for multicluster snapshots.
) (Snapshot, error) {

	partitionedCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates, err := partitionCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificatesByLabel(labelKey, certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates)
	if err != nil {
		return nil, err
	}
	partitionedCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives, err := partitionCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectivesByLabel(labelKey, certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives)
	if err != nil {
		return nil, err
	}
	partitionedXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs, err := partitionXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigsByLabel(labelKey, xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs)
	if err != nil {
		return nil, err
	}
	partitionedNetworkingIstioIo_V1Alpha3_DestinationRules, err := partitionNetworkingIstioIo_V1Alpha3_DestinationRulesByLabel(labelKey, networkingIstioIoV1Alpha3DestinationRules)
	if err != nil {
		return nil, err
	}
	partitionedNetworkingIstioIo_V1Alpha3_EnvoyFilters, err := partitionNetworkingIstioIo_V1Alpha3_EnvoyFiltersByLabel(labelKey, networkingIstioIoV1Alpha3EnvoyFilters)
	if err != nil {
		return nil, err
	}
	partitionedNetworkingIstioIo_V1Alpha3_Gateways, err := partitionNetworkingIstioIo_V1Alpha3_GatewaysByLabel(labelKey, networkingIstioIoV1Alpha3Gateways)
	if err != nil {
		return nil, err
	}
	partitionedNetworkingIstioIo_V1Alpha3_ServiceEntries, err := partitionNetworkingIstioIo_V1Alpha3_ServiceEntriesByLabel(labelKey, networkingIstioIoV1Alpha3ServiceEntries)
	if err != nil {
		return nil, err
	}
	partitionedNetworkingIstioIo_V1Alpha3_VirtualServices, err := partitionNetworkingIstioIo_V1Alpha3_VirtualServicesByLabel(labelKey, networkingIstioIoV1Alpha3VirtualServices)
	if err != nil {
		return nil, err
	}
	partitionedSecurityIstioIo_V1Beta1_AuthorizationPolicies, err := partitionSecurityIstioIo_V1Beta1_AuthorizationPoliciesByLabel(labelKey, securityIstioIoV1Beta1AuthorizationPolicies)
	if err != nil {
		return nil, err
	}
	partitionedV1_ConfigMaps, err := partitionV1_ConfigMapsByLabel(labelKey, v1ConfigMaps)
	if err != nil {
		return nil, err
	}

	return NewSnapshot(
		name,

		partitionedCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates,
		partitionedCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives,
		partitionedXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs,
		partitionedNetworkingIstioIo_V1Alpha3_DestinationRules,
		partitionedNetworkingIstioIo_V1Alpha3_EnvoyFilters,
		partitionedNetworkingIstioIo_V1Alpha3_Gateways,
		partitionedNetworkingIstioIo_V1Alpha3_ServiceEntries,
		partitionedNetworkingIstioIo_V1Alpha3_VirtualServices,
		partitionedSecurityIstioIo_V1Beta1_AuthorizationPolicies,
		partitionedV1_ConfigMaps,
		clusters...,
	), nil
}

// simplified constructor for a snapshot
// with a single label partition (i.e. all resources share a single set of labels).
func NewSinglePartitionedSnapshot(
	name string,
	snapshotLabels map[string]string, // a single set of labels shared by all resources

	certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet,
	certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet,

	xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet,

	networkingIstioIoV1Alpha3DestinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet,
	networkingIstioIoV1Alpha3EnvoyFilters networking_istio_io_v1alpha3_sets.EnvoyFilterSet,
	networkingIstioIoV1Alpha3Gateways networking_istio_io_v1alpha3_sets.GatewaySet,
	networkingIstioIoV1Alpha3ServiceEntries networking_istio_io_v1alpha3_sets.ServiceEntrySet,
	networkingIstioIoV1Alpha3VirtualServices networking_istio_io_v1alpha3_sets.VirtualServiceSet,

	securityIstioIoV1Beta1AuthorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet,

	v1ConfigMaps v1_sets.ConfigMapSet,
	clusters ...string, // the set of clusters to apply the snapshot to. only required for multicluster snapshots.
) (Snapshot, error) {

	labeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificate, err := NewLabeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet(certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirective, err := NewLabeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet(certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfig, err := NewLabeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet(xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledNetworkingIstioIo_V1Alpha3_DestinationRule, err := NewLabeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet(networkingIstioIoV1Alpha3DestinationRules, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledNetworkingIstioIo_V1Alpha3_EnvoyFilter, err := NewLabeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet(networkingIstioIoV1Alpha3EnvoyFilters, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledNetworkingIstioIo_V1Alpha3_Gateway, err := NewLabeledNetworkingIstioIo_V1Alpha3_GatewaySet(networkingIstioIoV1Alpha3Gateways, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledNetworkingIstioIo_V1Alpha3_ServiceEntry, err := NewLabeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet(networkingIstioIoV1Alpha3ServiceEntries, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledNetworkingIstioIo_V1Alpha3_VirtualService, err := NewLabeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet(networkingIstioIoV1Alpha3VirtualServices, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledSecurityIstioIo_V1Beta1_AuthorizationPolicy, err := NewLabeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet(securityIstioIoV1Beta1AuthorizationPolicies, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledV1_ConfigMap, err := NewLabeledV1_ConfigMapSet(v1ConfigMaps, snapshotLabels)
	if err != nil {
		return nil, err
	}

	return NewSnapshot(
		name,

		[]LabeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet{labeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificate},
		[]LabeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet{labeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirective},
		[]LabeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet{labeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfig},
		[]LabeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet{labeledNetworkingIstioIo_V1Alpha3_DestinationRule},
		[]LabeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet{labeledNetworkingIstioIo_V1Alpha3_EnvoyFilter},
		[]LabeledNetworkingIstioIo_V1Alpha3_GatewaySet{labeledNetworkingIstioIo_V1Alpha3_Gateway},
		[]LabeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet{labeledNetworkingIstioIo_V1Alpha3_ServiceEntry},
		[]LabeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet{labeledNetworkingIstioIo_V1Alpha3_VirtualService},
		[]LabeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet{labeledSecurityIstioIo_V1Beta1_AuthorizationPolicy},
		[]LabeledV1_ConfigMapSet{labeledV1_ConfigMap},
		clusters...,
	), nil
}

// apply the desired resources to the cluster state; remove stale resources where necessary
func (s *snapshot) ApplyLocalCluster(ctx context.Context, cli client.Client, errHandler output.ErrorHandler) {
	var genericLists []output.ResourceList

	for _, outputSet := range s.certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIoV1Alpha3DestinationRules {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIoV1Alpha3EnvoyFilters {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIoV1Alpha3Gateways {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIoV1Alpha3ServiceEntries {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIoV1Alpha3VirtualServices {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.securityIstioIoV1Beta1AuthorizationPolicies {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.v1ConfigMaps {
		genericLists = append(genericLists, outputSet.Generic())
	}

	output.Snapshot{
		Name:        s.name,
		ListsToSync: genericLists,
	}.SyncLocalCluster(ctx, cli, errHandler)
}

// apply the desired resources to multiple cluster states; remove stale resources where necessary
func (s *snapshot) ApplyMultiCluster(ctx context.Context, multiClusterClient multicluster.Client, errHandler output.ErrorHandler) {
	var genericLists []output.ResourceList

	for _, outputSet := range s.certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIoV1Alpha3DestinationRules {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIoV1Alpha3EnvoyFilters {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIoV1Alpha3Gateways {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIoV1Alpha3ServiceEntries {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.networkingIstioIoV1Alpha3VirtualServices {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.securityIstioIoV1Beta1AuthorizationPolicies {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.v1ConfigMaps {
		genericLists = append(genericLists, outputSet.Generic())
	}

	output.Snapshot{
		Name:        s.name,
		Clusters:    s.clusters,
		ListsToSync: genericLists,
	}.SyncMultiCluster(ctx, multiClusterClient, errHandler)
}

func partitionCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificatesByLabel(labelKey string, set certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet) ([]LabeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet, error) {
	setsByLabel := map[string]certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificate", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificate", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = certificates_mesh_gloo_solo_io_v1alpha2_sets.NewIssuedCertificateSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates []LabeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates = append(partitionedCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates, func(i, j int) bool {
		leftLabelValue := partitionedCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates[i].Labels()[labelKey]
		rightLabelValue := partitionedCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates, nil
}

func partitionCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectivesByLabel(labelKey string, set certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet) ([]LabeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet, error) {
	setsByLabel := map[string]certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirective", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirective", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = certificates_mesh_gloo_solo_io_v1alpha2_sets.NewPodBounceDirectiveSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives []LabeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives = append(partitionedCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives, func(i, j int) bool {
		leftLabelValue := partitionedCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives[i].Labels()[labelKey]
		rightLabelValue := partitionedCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives, nil
}

func partitionXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigsByLabel(labelKey string, set xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet) ([]LabeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet, error) {
	setsByLabel := map[string]xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfig", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfig", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.NewXdsConfigSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs []LabeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs = append(partitionedXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs, func(i, j int) bool {
		leftLabelValue := partitionedXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs[i].Labels()[labelKey]
		rightLabelValue := partitionedXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs, nil
}

func partitionNetworkingIstioIo_V1Alpha3_DestinationRulesByLabel(labelKey string, set networking_istio_io_v1alpha3_sets.DestinationRuleSet) ([]LabeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet, error) {
	setsByLabel := map[string]networking_istio_io_v1alpha3_sets.DestinationRuleSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIo_V1Alpha3_DestinationRule", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIo_V1Alpha3_DestinationRule", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = networking_istio_io_v1alpha3_sets.NewDestinationRuleSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedNetworkingIstioIo_V1Alpha3_DestinationRules []LabeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedNetworkingIstioIo_V1Alpha3_DestinationRules = append(partitionedNetworkingIstioIo_V1Alpha3_DestinationRules, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedNetworkingIstioIo_V1Alpha3_DestinationRules, func(i, j int) bool {
		leftLabelValue := partitionedNetworkingIstioIo_V1Alpha3_DestinationRules[i].Labels()[labelKey]
		rightLabelValue := partitionedNetworkingIstioIo_V1Alpha3_DestinationRules[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedNetworkingIstioIo_V1Alpha3_DestinationRules, nil
}

func partitionNetworkingIstioIo_V1Alpha3_EnvoyFiltersByLabel(labelKey string, set networking_istio_io_v1alpha3_sets.EnvoyFilterSet) ([]LabeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet, error) {
	setsByLabel := map[string]networking_istio_io_v1alpha3_sets.EnvoyFilterSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIo_V1Alpha3_EnvoyFilter", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIo_V1Alpha3_EnvoyFilter", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedNetworkingIstioIo_V1Alpha3_EnvoyFilters []LabeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedNetworkingIstioIo_V1Alpha3_EnvoyFilters = append(partitionedNetworkingIstioIo_V1Alpha3_EnvoyFilters, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedNetworkingIstioIo_V1Alpha3_EnvoyFilters, func(i, j int) bool {
		leftLabelValue := partitionedNetworkingIstioIo_V1Alpha3_EnvoyFilters[i].Labels()[labelKey]
		rightLabelValue := partitionedNetworkingIstioIo_V1Alpha3_EnvoyFilters[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedNetworkingIstioIo_V1Alpha3_EnvoyFilters, nil
}

func partitionNetworkingIstioIo_V1Alpha3_GatewaysByLabel(labelKey string, set networking_istio_io_v1alpha3_sets.GatewaySet) ([]LabeledNetworkingIstioIo_V1Alpha3_GatewaySet, error) {
	setsByLabel := map[string]networking_istio_io_v1alpha3_sets.GatewaySet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIo_V1Alpha3_Gateway", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIo_V1Alpha3_Gateway", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = networking_istio_io_v1alpha3_sets.NewGatewaySet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedNetworkingIstioIo_V1Alpha3_Gateways []LabeledNetworkingIstioIo_V1Alpha3_GatewaySet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledNetworkingIstioIo_V1Alpha3_GatewaySet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedNetworkingIstioIo_V1Alpha3_Gateways = append(partitionedNetworkingIstioIo_V1Alpha3_Gateways, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedNetworkingIstioIo_V1Alpha3_Gateways, func(i, j int) bool {
		leftLabelValue := partitionedNetworkingIstioIo_V1Alpha3_Gateways[i].Labels()[labelKey]
		rightLabelValue := partitionedNetworkingIstioIo_V1Alpha3_Gateways[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedNetworkingIstioIo_V1Alpha3_Gateways, nil
}

func partitionNetworkingIstioIo_V1Alpha3_ServiceEntriesByLabel(labelKey string, set networking_istio_io_v1alpha3_sets.ServiceEntrySet) ([]LabeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet, error) {
	setsByLabel := map[string]networking_istio_io_v1alpha3_sets.ServiceEntrySet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIo_V1Alpha3_ServiceEntry", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIo_V1Alpha3_ServiceEntry", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = networking_istio_io_v1alpha3_sets.NewServiceEntrySet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedNetworkingIstioIo_V1Alpha3_ServiceEntries []LabeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedNetworkingIstioIo_V1Alpha3_ServiceEntries = append(partitionedNetworkingIstioIo_V1Alpha3_ServiceEntries, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedNetworkingIstioIo_V1Alpha3_ServiceEntries, func(i, j int) bool {
		leftLabelValue := partitionedNetworkingIstioIo_V1Alpha3_ServiceEntries[i].Labels()[labelKey]
		rightLabelValue := partitionedNetworkingIstioIo_V1Alpha3_ServiceEntries[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedNetworkingIstioIo_V1Alpha3_ServiceEntries, nil
}

func partitionNetworkingIstioIo_V1Alpha3_VirtualServicesByLabel(labelKey string, set networking_istio_io_v1alpha3_sets.VirtualServiceSet) ([]LabeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet, error) {
	setsByLabel := map[string]networking_istio_io_v1alpha3_sets.VirtualServiceSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIo_V1Alpha3_VirtualService", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "NetworkingIstioIo_V1Alpha3_VirtualService", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = networking_istio_io_v1alpha3_sets.NewVirtualServiceSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedNetworkingIstioIo_V1Alpha3_VirtualServices []LabeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedNetworkingIstioIo_V1Alpha3_VirtualServices = append(partitionedNetworkingIstioIo_V1Alpha3_VirtualServices, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedNetworkingIstioIo_V1Alpha3_VirtualServices, func(i, j int) bool {
		leftLabelValue := partitionedNetworkingIstioIo_V1Alpha3_VirtualServices[i].Labels()[labelKey]
		rightLabelValue := partitionedNetworkingIstioIo_V1Alpha3_VirtualServices[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedNetworkingIstioIo_V1Alpha3_VirtualServices, nil
}

func partitionSecurityIstioIo_V1Beta1_AuthorizationPoliciesByLabel(labelKey string, set security_istio_io_v1beta1_sets.AuthorizationPolicySet) ([]LabeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet, error) {
	setsByLabel := map[string]security_istio_io_v1beta1_sets.AuthorizationPolicySet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "SecurityIstioIo_V1Beta1_AuthorizationPolicy", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "SecurityIstioIo_V1Beta1_AuthorizationPolicy", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = security_istio_io_v1beta1_sets.NewAuthorizationPolicySet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedSecurityIstioIo_V1Beta1_AuthorizationPolicies []LabeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedSecurityIstioIo_V1Beta1_AuthorizationPolicies = append(partitionedSecurityIstioIo_V1Beta1_AuthorizationPolicies, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedSecurityIstioIo_V1Beta1_AuthorizationPolicies, func(i, j int) bool {
		leftLabelValue := partitionedSecurityIstioIo_V1Beta1_AuthorizationPolicies[i].Labels()[labelKey]
		rightLabelValue := partitionedSecurityIstioIo_V1Beta1_AuthorizationPolicies[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedSecurityIstioIo_V1Beta1_AuthorizationPolicies, nil
}

func partitionV1_ConfigMapsByLabel(labelKey string, set v1_sets.ConfigMapSet) ([]LabeledV1_ConfigMapSet, error) {
	setsByLabel := map[string]v1_sets.ConfigMapSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "V1_ConfigMap", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "V1_ConfigMap", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = v1_sets.NewConfigMapSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedV1_ConfigMaps []LabeledV1_ConfigMapSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledV1_ConfigMapSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedV1_ConfigMaps = append(partitionedV1_ConfigMaps, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedV1_ConfigMaps, func(i, j int) bool {
		leftLabelValue := partitionedV1_ConfigMaps[i].Labels()[labelKey]
		rightLabelValue := partitionedV1_ConfigMaps[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedV1_ConfigMaps, nil
}

func (s snapshot) CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates() []LabeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet {
	return s.certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates
}

func (s snapshot) CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives() []LabeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet {
	return s.certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives
}

func (s snapshot) XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs() []LabeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet {
	return s.xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs
}

func (s snapshot) NetworkingIstioIo_V1Alpha3_DestinationRules() []LabeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet {
	return s.networkingIstioIoV1Alpha3DestinationRules
}

func (s snapshot) NetworkingIstioIo_V1Alpha3_EnvoyFilters() []LabeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet {
	return s.networkingIstioIoV1Alpha3EnvoyFilters
}

func (s snapshot) NetworkingIstioIo_V1Alpha3_Gateways() []LabeledNetworkingIstioIo_V1Alpha3_GatewaySet {
	return s.networkingIstioIoV1Alpha3Gateways
}

func (s snapshot) NetworkingIstioIo_V1Alpha3_ServiceEntries() []LabeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet {
	return s.networkingIstioIoV1Alpha3ServiceEntries
}

func (s snapshot) NetworkingIstioIo_V1Alpha3_VirtualServices() []LabeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet {
	return s.networkingIstioIoV1Alpha3VirtualServices
}

func (s snapshot) SecurityIstioIo_V1Beta1_AuthorizationPolicies() []LabeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet {
	return s.securityIstioIoV1Beta1AuthorizationPolicies
}

func (s snapshot) V1_ConfigMaps() []LabeledV1_ConfigMapSet {
	return s.v1ConfigMaps
}

func (s snapshot) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	certificatesMeshGlooSoloIoV1Alpha2IssuedCertificateSet := certificates_mesh_gloo_solo_io_v1alpha2_sets.NewIssuedCertificateSet()
	for _, set := range s.certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates {
		certificatesMeshGlooSoloIoV1Alpha2IssuedCertificateSet = certificatesMeshGlooSoloIoV1Alpha2IssuedCertificateSet.Union(set.Set())
	}
	snapshotMap["certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates"] = certificatesMeshGlooSoloIoV1Alpha2IssuedCertificateSet.List()
	certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectiveSet := certificates_mesh_gloo_solo_io_v1alpha2_sets.NewPodBounceDirectiveSet()
	for _, set := range s.certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives {
		certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectiveSet = certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectiveSet.Union(set.Set())
	}
	snapshotMap["certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives"] = certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectiveSet.List()

	xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigSet := xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.NewXdsConfigSet()
	for _, set := range s.xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs {
		xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigSet = xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigSet.Union(set.Set())
	}
	snapshotMap["xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs"] = xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigSet.List()

	networkingIstioIoV1Alpha3DestinationRuleSet := networking_istio_io_v1alpha3_sets.NewDestinationRuleSet()
	for _, set := range s.networkingIstioIoV1Alpha3DestinationRules {
		networkingIstioIoV1Alpha3DestinationRuleSet = networkingIstioIoV1Alpha3DestinationRuleSet.Union(set.Set())
	}
	snapshotMap["networkingIstioIoV1Alpha3DestinationRules"] = networkingIstioIoV1Alpha3DestinationRuleSet.List()
	networkingIstioIoV1Alpha3EnvoyFilterSet := networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet()
	for _, set := range s.networkingIstioIoV1Alpha3EnvoyFilters {
		networkingIstioIoV1Alpha3EnvoyFilterSet = networkingIstioIoV1Alpha3EnvoyFilterSet.Union(set.Set())
	}
	snapshotMap["networkingIstioIoV1Alpha3EnvoyFilters"] = networkingIstioIoV1Alpha3EnvoyFilterSet.List()
	networkingIstioIoV1Alpha3GatewaySet := networking_istio_io_v1alpha3_sets.NewGatewaySet()
	for _, set := range s.networkingIstioIoV1Alpha3Gateways {
		networkingIstioIoV1Alpha3GatewaySet = networkingIstioIoV1Alpha3GatewaySet.Union(set.Set())
	}
	snapshotMap["networkingIstioIoV1Alpha3Gateways"] = networkingIstioIoV1Alpha3GatewaySet.List()
	networkingIstioIoV1Alpha3ServiceEntrySet := networking_istio_io_v1alpha3_sets.NewServiceEntrySet()
	for _, set := range s.networkingIstioIoV1Alpha3ServiceEntries {
		networkingIstioIoV1Alpha3ServiceEntrySet = networkingIstioIoV1Alpha3ServiceEntrySet.Union(set.Set())
	}
	snapshotMap["networkingIstioIoV1Alpha3ServiceEntries"] = networkingIstioIoV1Alpha3ServiceEntrySet.List()
	networkingIstioIoV1Alpha3VirtualServiceSet := networking_istio_io_v1alpha3_sets.NewVirtualServiceSet()
	for _, set := range s.networkingIstioIoV1Alpha3VirtualServices {
		networkingIstioIoV1Alpha3VirtualServiceSet = networkingIstioIoV1Alpha3VirtualServiceSet.Union(set.Set())
	}
	snapshotMap["networkingIstioIoV1Alpha3VirtualServices"] = networkingIstioIoV1Alpha3VirtualServiceSet.List()

	securityIstioIoV1Beta1AuthorizationPolicySet := security_istio_io_v1beta1_sets.NewAuthorizationPolicySet()
	for _, set := range s.securityIstioIoV1Beta1AuthorizationPolicies {
		securityIstioIoV1Beta1AuthorizationPolicySet = securityIstioIoV1Beta1AuthorizationPolicySet.Union(set.Set())
	}
	snapshotMap["securityIstioIoV1Beta1AuthorizationPolicies"] = securityIstioIoV1Beta1AuthorizationPolicySet.List()

	v1ConfigMapSet := v1_sets.NewConfigMapSet()
	for _, set := range s.v1ConfigMaps {
		v1ConfigMapSet = v1ConfigMapSet.Union(set.Set())
	}
	snapshotMap["v1ConfigMaps"] = v1ConfigMapSet.List()

	snapshotMap["clusters"] = s.clusters

	return json.Marshal(snapshotMap)
}

// LabeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet represents a set of certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates
// which share a common set of labels.
// These labels are used to find diffs between CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSets.
type LabeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet interface {
	// returns the set of Labels shared by this CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet
	Labels() map[string]string

	// returns the set of IssuedCertificatees with the given labels
	Set() certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet struct {
	set    certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet
	labels map[string]string
}

func NewLabeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet(set certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet, labels map[string]string) (LabeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet, error) {
	// validate that each IssuedCertificate contains the labels, else this is not a valid LabeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificate %v", k, v, item.Name)
			}
		}
	}

	return &labeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet{set: set, labels: labels}, nil
}

func (l *labeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet) Set() certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet {
	return l.set
}

func (l labeledCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificateSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list certificates_mesh_gloo_solo_io_v1alpha2.IssuedCertificateList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "IssuedCertificate",
	}
}

// LabeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet represents a set of certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives
// which share a common set of labels.
// These labels are used to find diffs between CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSets.
type LabeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet interface {
	// returns the set of Labels shared by this CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet
	Labels() map[string]string

	// returns the set of PodBounceDirectivees with the given labels
	Set() certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet struct {
	set    certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet
	labels map[string]string
}

func NewLabeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet(set certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet, labels map[string]string) (LabeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet, error) {
	// validate that each PodBounceDirective contains the labels, else this is not a valid LabeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirective %v", k, v, item.Name)
			}
		}
	}

	return &labeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet{set: set, labels: labels}, nil
}

func (l *labeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet) Set() certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet {
	return l.set
}

func (l labeledCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectiveSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list certificates_mesh_gloo_solo_io_v1alpha2.PodBounceDirectiveList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "PodBounceDirective",
	}
}

// LabeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet represents a set of xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs
// which share a common set of labels.
// These labels are used to find diffs between XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSets.
type LabeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet interface {
	// returns the set of Labels shared by this XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet
	Labels() map[string]string

	// returns the set of XdsConfiges with the given labels
	Set() xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet struct {
	set    xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet
	labels map[string]string
}

func NewLabeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet(set xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet, labels map[string]string) (LabeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet, error) {
	// validate that each XdsConfig contains the labels, else this is not a valid LabeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfig %v", k, v, item.Name)
			}
		}
	}

	return &labeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet{set: set, labels: labels}, nil
}

func (l *labeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet) Set() xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet {
	return l.set
}

func (l labeledXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1.XdsConfigList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "XdsConfig",
	}
}

// LabeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet represents a set of networkingIstioIoV1Alpha3DestinationRules
// which share a common set of labels.
// These labels are used to find diffs between NetworkingIstioIo_V1Alpha3_DestinationRuleSets.
type LabeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet interface {
	// returns the set of Labels shared by this NetworkingIstioIo_V1Alpha3_DestinationRuleSet
	Labels() map[string]string

	// returns the set of DestinationRulees with the given labels
	Set() networking_istio_io_v1alpha3_sets.DestinationRuleSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet struct {
	set    networking_istio_io_v1alpha3_sets.DestinationRuleSet
	labels map[string]string
}

func NewLabeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet(set networking_istio_io_v1alpha3_sets.DestinationRuleSet, labels map[string]string) (LabeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet, error) {
	// validate that each DestinationRule contains the labels, else this is not a valid LabeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on NetworkingIstioIo_V1Alpha3_DestinationRule %v", k, v, item.Name)
			}
		}
	}

	return &labeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet{set: set, labels: labels}, nil
}

func (l *labeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet) Set() networking_istio_io_v1alpha3_sets.DestinationRuleSet {
	return l.set
}

func (l labeledNetworkingIstioIo_V1Alpha3_DestinationRuleSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list networking_istio_io_v1alpha3.DestinationRuleList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "DestinationRule",
	}
}

// LabeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet represents a set of networkingIstioIoV1Alpha3EnvoyFilters
// which share a common set of labels.
// These labels are used to find diffs between NetworkingIstioIo_V1Alpha3_EnvoyFilterSets.
type LabeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet interface {
	// returns the set of Labels shared by this NetworkingIstioIo_V1Alpha3_EnvoyFilterSet
	Labels() map[string]string

	// returns the set of EnvoyFilteres with the given labels
	Set() networking_istio_io_v1alpha3_sets.EnvoyFilterSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet struct {
	set    networking_istio_io_v1alpha3_sets.EnvoyFilterSet
	labels map[string]string
}

func NewLabeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet(set networking_istio_io_v1alpha3_sets.EnvoyFilterSet, labels map[string]string) (LabeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet, error) {
	// validate that each EnvoyFilter contains the labels, else this is not a valid LabeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on NetworkingIstioIo_V1Alpha3_EnvoyFilter %v", k, v, item.Name)
			}
		}
	}

	return &labeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet{set: set, labels: labels}, nil
}

func (l *labeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet) Set() networking_istio_io_v1alpha3_sets.EnvoyFilterSet {
	return l.set
}

func (l labeledNetworkingIstioIo_V1Alpha3_EnvoyFilterSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list networking_istio_io_v1alpha3.EnvoyFilterList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "EnvoyFilter",
	}
}

// LabeledNetworkingIstioIo_V1Alpha3_GatewaySet represents a set of networkingIstioIoV1Alpha3Gateways
// which share a common set of labels.
// These labels are used to find diffs between NetworkingIstioIo_V1Alpha3_GatewaySets.
type LabeledNetworkingIstioIo_V1Alpha3_GatewaySet interface {
	// returns the set of Labels shared by this NetworkingIstioIo_V1Alpha3_GatewaySet
	Labels() map[string]string

	// returns the set of Gatewayes with the given labels
	Set() networking_istio_io_v1alpha3_sets.GatewaySet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledNetworkingIstioIo_V1Alpha3_GatewaySet struct {
	set    networking_istio_io_v1alpha3_sets.GatewaySet
	labels map[string]string
}

func NewLabeledNetworkingIstioIo_V1Alpha3_GatewaySet(set networking_istio_io_v1alpha3_sets.GatewaySet, labels map[string]string) (LabeledNetworkingIstioIo_V1Alpha3_GatewaySet, error) {
	// validate that each Gateway contains the labels, else this is not a valid LabeledNetworkingIstioIo_V1Alpha3_GatewaySet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on NetworkingIstioIo_V1Alpha3_Gateway %v", k, v, item.Name)
			}
		}
	}

	return &labeledNetworkingIstioIo_V1Alpha3_GatewaySet{set: set, labels: labels}, nil
}

func (l *labeledNetworkingIstioIo_V1Alpha3_GatewaySet) Labels() map[string]string {
	return l.labels
}

func (l *labeledNetworkingIstioIo_V1Alpha3_GatewaySet) Set() networking_istio_io_v1alpha3_sets.GatewaySet {
	return l.set
}

func (l labeledNetworkingIstioIo_V1Alpha3_GatewaySet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list networking_istio_io_v1alpha3.GatewayList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "Gateway",
	}
}

// LabeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet represents a set of networkingIstioIoV1Alpha3ServiceEntries
// which share a common set of labels.
// These labels are used to find diffs between NetworkingIstioIo_V1Alpha3_ServiceEntrySets.
type LabeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet interface {
	// returns the set of Labels shared by this NetworkingIstioIo_V1Alpha3_ServiceEntrySet
	Labels() map[string]string

	// returns the set of ServiceEntryes with the given labels
	Set() networking_istio_io_v1alpha3_sets.ServiceEntrySet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet struct {
	set    networking_istio_io_v1alpha3_sets.ServiceEntrySet
	labels map[string]string
}

func NewLabeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet(set networking_istio_io_v1alpha3_sets.ServiceEntrySet, labels map[string]string) (LabeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet, error) {
	// validate that each ServiceEntry contains the labels, else this is not a valid LabeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on NetworkingIstioIo_V1Alpha3_ServiceEntry %v", k, v, item.Name)
			}
		}
	}

	return &labeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet{set: set, labels: labels}, nil
}

func (l *labeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet) Labels() map[string]string {
	return l.labels
}

func (l *labeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet) Set() networking_istio_io_v1alpha3_sets.ServiceEntrySet {
	return l.set
}

func (l labeledNetworkingIstioIo_V1Alpha3_ServiceEntrySet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list networking_istio_io_v1alpha3.ServiceEntryList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "ServiceEntry",
	}
}

// LabeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet represents a set of networkingIstioIoV1Alpha3VirtualServices
// which share a common set of labels.
// These labels are used to find diffs between NetworkingIstioIo_V1Alpha3_VirtualServiceSets.
type LabeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet interface {
	// returns the set of Labels shared by this NetworkingIstioIo_V1Alpha3_VirtualServiceSet
	Labels() map[string]string

	// returns the set of VirtualServicees with the given labels
	Set() networking_istio_io_v1alpha3_sets.VirtualServiceSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet struct {
	set    networking_istio_io_v1alpha3_sets.VirtualServiceSet
	labels map[string]string
}

func NewLabeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet(set networking_istio_io_v1alpha3_sets.VirtualServiceSet, labels map[string]string) (LabeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet, error) {
	// validate that each VirtualService contains the labels, else this is not a valid LabeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on NetworkingIstioIo_V1Alpha3_VirtualService %v", k, v, item.Name)
			}
		}
	}

	return &labeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet{set: set, labels: labels}, nil
}

func (l *labeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet) Set() networking_istio_io_v1alpha3_sets.VirtualServiceSet {
	return l.set
}

func (l labeledNetworkingIstioIo_V1Alpha3_VirtualServiceSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list networking_istio_io_v1alpha3.VirtualServiceList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "VirtualService",
	}
}

// LabeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet represents a set of securityIstioIoV1Beta1AuthorizationPolicies
// which share a common set of labels.
// These labels are used to find diffs between SecurityIstioIo_V1Beta1_AuthorizationPolicySets.
type LabeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet interface {
	// returns the set of Labels shared by this SecurityIstioIo_V1Beta1_AuthorizationPolicySet
	Labels() map[string]string

	// returns the set of AuthorizationPolicyes with the given labels
	Set() security_istio_io_v1beta1_sets.AuthorizationPolicySet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet struct {
	set    security_istio_io_v1beta1_sets.AuthorizationPolicySet
	labels map[string]string
}

func NewLabeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet(set security_istio_io_v1beta1_sets.AuthorizationPolicySet, labels map[string]string) (LabeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet, error) {
	// validate that each AuthorizationPolicy contains the labels, else this is not a valid LabeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on SecurityIstioIo_V1Beta1_AuthorizationPolicy %v", k, v, item.Name)
			}
		}
	}

	return &labeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet{set: set, labels: labels}, nil
}

func (l *labeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet) Labels() map[string]string {
	return l.labels
}

func (l *labeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet) Set() security_istio_io_v1beta1_sets.AuthorizationPolicySet {
	return l.set
}

func (l labeledSecurityIstioIo_V1Beta1_AuthorizationPolicySet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list security_istio_io_v1beta1.AuthorizationPolicyList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "AuthorizationPolicy",
	}
}

// LabeledV1_ConfigMapSet represents a set of v1ConfigMaps
// which share a common set of labels.
// These labels are used to find diffs between V1_ConfigMapSets.
type LabeledV1_ConfigMapSet interface {
	// returns the set of Labels shared by this V1_ConfigMapSet
	Labels() map[string]string

	// returns the set of ConfigMapes with the given labels
	Set() v1_sets.ConfigMapSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledV1_ConfigMapSet struct {
	set    v1_sets.ConfigMapSet
	labels map[string]string
}

func NewLabeledV1_ConfigMapSet(set v1_sets.ConfigMapSet, labels map[string]string) (LabeledV1_ConfigMapSet, error) {
	// validate that each ConfigMap contains the labels, else this is not a valid LabeledV1_ConfigMapSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on V1_ConfigMap %v", k, v, item.Name)
			}
		}
	}

	return &labeledV1_ConfigMapSet{set: set, labels: labels}, nil
}

func (l *labeledV1_ConfigMapSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledV1_ConfigMapSet) Set() v1_sets.ConfigMapSet {
	return l.set
}

func (l labeledV1_ConfigMapSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list v1.ConfigMapList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "ConfigMap",
	}
}

type builder struct {
	ctx      context.Context
	name     string
	clusters []string

	certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates  certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet
	certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet

	xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet

	networkingIstioIoV1Alpha3DestinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet
	networkingIstioIoV1Alpha3EnvoyFilters     networking_istio_io_v1alpha3_sets.EnvoyFilterSet
	networkingIstioIoV1Alpha3Gateways         networking_istio_io_v1alpha3_sets.GatewaySet
	networkingIstioIoV1Alpha3ServiceEntries   networking_istio_io_v1alpha3_sets.ServiceEntrySet
	networkingIstioIoV1Alpha3VirtualServices  networking_istio_io_v1alpha3_sets.VirtualServiceSet

	securityIstioIoV1Beta1AuthorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet

	v1ConfigMaps v1_sets.ConfigMapSet
}

func NewBuilder(ctx context.Context, name string) *builder {
	return &builder{
		ctx:  ctx,
		name: name,

		certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates:  certificates_mesh_gloo_solo_io_v1alpha2_sets.NewIssuedCertificateSet(),
		certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives: certificates_mesh_gloo_solo_io_v1alpha2_sets.NewPodBounceDirectiveSet(),

		xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs: xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.NewXdsConfigSet(),

		networkingIstioIoV1Alpha3DestinationRules: networking_istio_io_v1alpha3_sets.NewDestinationRuleSet(),
		networkingIstioIoV1Alpha3EnvoyFilters:     networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet(),
		networkingIstioIoV1Alpha3Gateways:         networking_istio_io_v1alpha3_sets.NewGatewaySet(),
		networkingIstioIoV1Alpha3ServiceEntries:   networking_istio_io_v1alpha3_sets.NewServiceEntrySet(),
		networkingIstioIoV1Alpha3VirtualServices:  networking_istio_io_v1alpha3_sets.NewVirtualServiceSet(),

		securityIstioIoV1Beta1AuthorizationPolicies: security_istio_io_v1beta1_sets.NewAuthorizationPolicySet(),

		v1ConfigMaps: v1_sets.NewConfigMapSet(),
	}
}

// the output Builder uses a builder pattern to allow
// iteratively collecting outputs before producing a final snapshot
type Builder interface {

	// add CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates to the collected outputs
	AddCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates(certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates ...*certificates_mesh_gloo_solo_io_v1alpha2.IssuedCertificate)

	// get the collected CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates
	GetCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates() certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet

	// add CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives to the collected outputs
	AddCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives(certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives ...*certificates_mesh_gloo_solo_io_v1alpha2.PodBounceDirective)

	// get the collected CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives
	GetCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives() certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet

	// add XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs to the collected outputs
	AddXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs(xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs ...*xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1.XdsConfig)

	// get the collected XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs
	GetXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs() xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet

	// add NetworkingIstioIo_V1Alpha3_DestinationRules to the collected outputs
	AddNetworkingIstioIo_V1Alpha3_DestinationRules(networkingIstioIoV1Alpha3DestinationRules ...*networking_istio_io_v1alpha3.DestinationRule)

	// get the collected NetworkingIstioIo_V1Alpha3_DestinationRules
	GetNetworkingIstioIo_V1Alpha3_DestinationRules() networking_istio_io_v1alpha3_sets.DestinationRuleSet

	// add NetworkingIstioIo_V1Alpha3_EnvoyFilters to the collected outputs
	AddNetworkingIstioIo_V1Alpha3_EnvoyFilters(networkingIstioIoV1Alpha3EnvoyFilters ...*networking_istio_io_v1alpha3.EnvoyFilter)

	// get the collected NetworkingIstioIo_V1Alpha3_EnvoyFilters
	GetNetworkingIstioIo_V1Alpha3_EnvoyFilters() networking_istio_io_v1alpha3_sets.EnvoyFilterSet

	// add NetworkingIstioIo_V1Alpha3_Gateways to the collected outputs
	AddNetworkingIstioIo_V1Alpha3_Gateways(networkingIstioIoV1Alpha3Gateways ...*networking_istio_io_v1alpha3.Gateway)

	// get the collected NetworkingIstioIo_V1Alpha3_Gateways
	GetNetworkingIstioIo_V1Alpha3_Gateways() networking_istio_io_v1alpha3_sets.GatewaySet

	// add NetworkingIstioIo_V1Alpha3_ServiceEntries to the collected outputs
	AddNetworkingIstioIo_V1Alpha3_ServiceEntries(networkingIstioIoV1Alpha3ServiceEntries ...*networking_istio_io_v1alpha3.ServiceEntry)

	// get the collected NetworkingIstioIo_V1Alpha3_ServiceEntries
	GetNetworkingIstioIo_V1Alpha3_ServiceEntries() networking_istio_io_v1alpha3_sets.ServiceEntrySet

	// add NetworkingIstioIo_V1Alpha3_VirtualServices to the collected outputs
	AddNetworkingIstioIo_V1Alpha3_VirtualServices(networkingIstioIoV1Alpha3VirtualServices ...*networking_istio_io_v1alpha3.VirtualService)

	// get the collected NetworkingIstioIo_V1Alpha3_VirtualServices
	GetNetworkingIstioIo_V1Alpha3_VirtualServices() networking_istio_io_v1alpha3_sets.VirtualServiceSet

	// add SecurityIstioIo_V1Beta1_AuthorizationPolicies to the collected outputs
	AddSecurityIstioIo_V1Beta1_AuthorizationPolicies(securityIstioIoV1Beta1AuthorizationPolicies ...*security_istio_io_v1beta1.AuthorizationPolicy)

	// get the collected SecurityIstioIo_V1Beta1_AuthorizationPolicies
	GetSecurityIstioIo_V1Beta1_AuthorizationPolicies() security_istio_io_v1beta1_sets.AuthorizationPolicySet

	// add V1_ConfigMaps to the collected outputs
	AddV1_ConfigMaps(v1ConfigMaps ...*v1.ConfigMap)

	// get the collected V1_ConfigMaps
	GetV1_ConfigMaps() v1_sets.ConfigMapSet

	// build the collected outputs into a label-partitioned snapshot
	BuildLabelPartitionedSnapshot(labelKey string) (Snapshot, error)

	// build the collected outputs into a snapshot with a single partition
	BuildSinglePartitionedSnapshot(snapshotLabels map[string]string) (Snapshot, error)

	// add a cluster to the collected clusters.
	// this can be used to collect clusters for use with MultiCluster snapshots.
	AddCluster(cluster string)

	// returns the set of clusters currently stored in this builder
	Clusters() []string

	// merge all the resources from another Builder into this one
	Merge(other Builder)

	// create a clone of this builder (deepcopying all resources)
	Clone() Builder

	// return the difference between the snapshot in this builder's and another
	Delta(newSnap Builder) output.SnapshotDelta
}

func (b *builder) AddCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates(certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates ...*certificates_mesh_gloo_solo_io_v1alpha2.IssuedCertificate) {
	for _, obj := range certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificate %v", sets.Key(obj))
		b.certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates.Insert(obj)
	}
}
func (b *builder) AddCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives(certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives ...*certificates_mesh_gloo_solo_io_v1alpha2.PodBounceDirective) {
	for _, obj := range certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirective %v", sets.Key(obj))
		b.certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives.Insert(obj)
	}
}
func (b *builder) AddXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs(xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs ...*xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1.XdsConfig) {
	for _, obj := range xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfig %v", sets.Key(obj))
		b.xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs.Insert(obj)
	}
}
func (b *builder) AddNetworkingIstioIo_V1Alpha3_DestinationRules(networkingIstioIoV1Alpha3DestinationRules ...*networking_istio_io_v1alpha3.DestinationRule) {
	for _, obj := range networkingIstioIoV1Alpha3DestinationRules {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output NetworkingIstioIo_V1Alpha3_DestinationRule %v", sets.Key(obj))
		b.networkingIstioIoV1Alpha3DestinationRules.Insert(obj)
	}
}
func (b *builder) AddNetworkingIstioIo_V1Alpha3_EnvoyFilters(networkingIstioIoV1Alpha3EnvoyFilters ...*networking_istio_io_v1alpha3.EnvoyFilter) {
	for _, obj := range networkingIstioIoV1Alpha3EnvoyFilters {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output NetworkingIstioIo_V1Alpha3_EnvoyFilter %v", sets.Key(obj))
		b.networkingIstioIoV1Alpha3EnvoyFilters.Insert(obj)
	}
}
func (b *builder) AddNetworkingIstioIo_V1Alpha3_Gateways(networkingIstioIoV1Alpha3Gateways ...*networking_istio_io_v1alpha3.Gateway) {
	for _, obj := range networkingIstioIoV1Alpha3Gateways {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output NetworkingIstioIo_V1Alpha3_Gateway %v", sets.Key(obj))
		b.networkingIstioIoV1Alpha3Gateways.Insert(obj)
	}
}
func (b *builder) AddNetworkingIstioIo_V1Alpha3_ServiceEntries(networkingIstioIoV1Alpha3ServiceEntries ...*networking_istio_io_v1alpha3.ServiceEntry) {
	for _, obj := range networkingIstioIoV1Alpha3ServiceEntries {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output NetworkingIstioIo_V1Alpha3_ServiceEntry %v", sets.Key(obj))
		b.networkingIstioIoV1Alpha3ServiceEntries.Insert(obj)
	}
}
func (b *builder) AddNetworkingIstioIo_V1Alpha3_VirtualServices(networkingIstioIoV1Alpha3VirtualServices ...*networking_istio_io_v1alpha3.VirtualService) {
	for _, obj := range networkingIstioIoV1Alpha3VirtualServices {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output NetworkingIstioIo_V1Alpha3_VirtualService %v", sets.Key(obj))
		b.networkingIstioIoV1Alpha3VirtualServices.Insert(obj)
	}
}
func (b *builder) AddSecurityIstioIo_V1Beta1_AuthorizationPolicies(securityIstioIoV1Beta1AuthorizationPolicies ...*security_istio_io_v1beta1.AuthorizationPolicy) {
	for _, obj := range securityIstioIoV1Beta1AuthorizationPolicies {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output SecurityIstioIo_V1Beta1_AuthorizationPolicy %v", sets.Key(obj))
		b.securityIstioIoV1Beta1AuthorizationPolicies.Insert(obj)
	}
}
func (b *builder) AddV1_ConfigMaps(v1ConfigMaps ...*v1.ConfigMap) {
	for _, obj := range v1ConfigMaps {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output V1_ConfigMap %v", sets.Key(obj))
		b.v1ConfigMaps.Insert(obj)
	}
}

func (b *builder) GetCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates() certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet {
	return b.certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates
}
func (b *builder) GetCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives() certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet {
	return b.certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives
}

func (b *builder) GetXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs() xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet {
	return b.xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs
}

func (b *builder) GetNetworkingIstioIo_V1Alpha3_DestinationRules() networking_istio_io_v1alpha3_sets.DestinationRuleSet {
	return b.networkingIstioIoV1Alpha3DestinationRules
}
func (b *builder) GetNetworkingIstioIo_V1Alpha3_EnvoyFilters() networking_istio_io_v1alpha3_sets.EnvoyFilterSet {
	return b.networkingIstioIoV1Alpha3EnvoyFilters
}
func (b *builder) GetNetworkingIstioIo_V1Alpha3_Gateways() networking_istio_io_v1alpha3_sets.GatewaySet {
	return b.networkingIstioIoV1Alpha3Gateways
}
func (b *builder) GetNetworkingIstioIo_V1Alpha3_ServiceEntries() networking_istio_io_v1alpha3_sets.ServiceEntrySet {
	return b.networkingIstioIoV1Alpha3ServiceEntries
}
func (b *builder) GetNetworkingIstioIo_V1Alpha3_VirtualServices() networking_istio_io_v1alpha3_sets.VirtualServiceSet {
	return b.networkingIstioIoV1Alpha3VirtualServices
}

func (b *builder) GetSecurityIstioIo_V1Beta1_AuthorizationPolicies() security_istio_io_v1beta1_sets.AuthorizationPolicySet {
	return b.securityIstioIoV1Beta1AuthorizationPolicies
}

func (b *builder) GetV1_ConfigMaps() v1_sets.ConfigMapSet {
	return b.v1ConfigMaps
}

func (b *builder) BuildLabelPartitionedSnapshot(labelKey string) (Snapshot, error) {
	return NewLabelPartitionedSnapshot(
		b.name,
		labelKey,

		b.certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates,
		b.certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives,

		b.xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs,

		b.networkingIstioIoV1Alpha3DestinationRules,
		b.networkingIstioIoV1Alpha3EnvoyFilters,
		b.networkingIstioIoV1Alpha3Gateways,
		b.networkingIstioIoV1Alpha3ServiceEntries,
		b.networkingIstioIoV1Alpha3VirtualServices,

		b.securityIstioIoV1Beta1AuthorizationPolicies,

		b.v1ConfigMaps,
		b.clusters...,
	)
}

func (b *builder) BuildSinglePartitionedSnapshot(snapshotLabels map[string]string) (Snapshot, error) {
	return NewSinglePartitionedSnapshot(
		b.name,
		snapshotLabels,

		b.certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates,
		b.certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives,

		b.xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs,

		b.networkingIstioIoV1Alpha3DestinationRules,
		b.networkingIstioIoV1Alpha3EnvoyFilters,
		b.networkingIstioIoV1Alpha3Gateways,
		b.networkingIstioIoV1Alpha3ServiceEntries,
		b.networkingIstioIoV1Alpha3VirtualServices,

		b.securityIstioIoV1Beta1AuthorizationPolicies,

		b.v1ConfigMaps,
		b.clusters...,
	)
}

func (b *builder) AddCluster(cluster string) {
	b.clusters = append(b.clusters, cluster)
}

func (b *builder) Clusters() []string {
	return b.clusters
}

func (b *builder) Merge(other Builder) {
	if other == nil {
		return
	}

	b.AddCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates(other.GetCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates().List()...)
	b.AddCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives(other.GetCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives().List()...)

	b.AddXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs(other.GetXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs().List()...)

	b.AddNetworkingIstioIo_V1Alpha3_DestinationRules(other.GetNetworkingIstioIo_V1Alpha3_DestinationRules().List()...)
	b.AddNetworkingIstioIo_V1Alpha3_EnvoyFilters(other.GetNetworkingIstioIo_V1Alpha3_EnvoyFilters().List()...)
	b.AddNetworkingIstioIo_V1Alpha3_Gateways(other.GetNetworkingIstioIo_V1Alpha3_Gateways().List()...)
	b.AddNetworkingIstioIo_V1Alpha3_ServiceEntries(other.GetNetworkingIstioIo_V1Alpha3_ServiceEntries().List()...)
	b.AddNetworkingIstioIo_V1Alpha3_VirtualServices(other.GetNetworkingIstioIo_V1Alpha3_VirtualServices().List()...)

	b.AddSecurityIstioIo_V1Beta1_AuthorizationPolicies(other.GetSecurityIstioIo_V1Beta1_AuthorizationPolicies().List()...)

	b.AddV1_ConfigMaps(other.GetV1_ConfigMaps().List()...)
	for _, cluster := range other.Clusters() {
		b.AddCluster(cluster)
	}
}

func (b *builder) Clone() Builder {
	if b == nil {
		return nil
	}
	clone := NewBuilder(b.ctx, b.name)

	for _, certificatesMeshGlooSoloIoV1Alpha2IssuedCertificate := range b.GetCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates().List() {
		clone.AddCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates(certificatesMeshGlooSoloIoV1Alpha2IssuedCertificate.DeepCopy())
	}
	for _, certificatesMeshGlooSoloIoV1Alpha2PodBounceDirective := range b.GetCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives().List() {
		clone.AddCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives(certificatesMeshGlooSoloIoV1Alpha2PodBounceDirective.DeepCopy())
	}

	for _, xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfig := range b.GetXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs().List() {
		clone.AddXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs(xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfig.DeepCopy())
	}

	for _, networkingIstioIoV1Alpha3DestinationRule := range b.GetNetworkingIstioIo_V1Alpha3_DestinationRules().List() {
		clone.AddNetworkingIstioIo_V1Alpha3_DestinationRules(networkingIstioIoV1Alpha3DestinationRule.DeepCopy())
	}
	for _, networkingIstioIoV1Alpha3EnvoyFilter := range b.GetNetworkingIstioIo_V1Alpha3_EnvoyFilters().List() {
		clone.AddNetworkingIstioIo_V1Alpha3_EnvoyFilters(networkingIstioIoV1Alpha3EnvoyFilter.DeepCopy())
	}
	for _, networkingIstioIoV1Alpha3Gateway := range b.GetNetworkingIstioIo_V1Alpha3_Gateways().List() {
		clone.AddNetworkingIstioIo_V1Alpha3_Gateways(networkingIstioIoV1Alpha3Gateway.DeepCopy())
	}
	for _, networkingIstioIoV1Alpha3ServiceEntry := range b.GetNetworkingIstioIo_V1Alpha3_ServiceEntries().List() {
		clone.AddNetworkingIstioIo_V1Alpha3_ServiceEntries(networkingIstioIoV1Alpha3ServiceEntry.DeepCopy())
	}
	for _, networkingIstioIoV1Alpha3VirtualService := range b.GetNetworkingIstioIo_V1Alpha3_VirtualServices().List() {
		clone.AddNetworkingIstioIo_V1Alpha3_VirtualServices(networkingIstioIoV1Alpha3VirtualService.DeepCopy())
	}

	for _, securityIstioIoV1Beta1AuthorizationPolicy := range b.GetSecurityIstioIo_V1Beta1_AuthorizationPolicies().List() {
		clone.AddSecurityIstioIo_V1Beta1_AuthorizationPolicies(securityIstioIoV1Beta1AuthorizationPolicy.DeepCopy())
	}

	for _, v1ConfigMap := range b.GetV1_ConfigMaps().List() {
		clone.AddV1_ConfigMaps(v1ConfigMap.DeepCopy())
	}
	for _, cluster := range b.Clusters() {
		clone.AddCluster(cluster)
	}
	return clone
}

func (b *builder) Delta(other Builder) output.SnapshotDelta {
	delta := output.SnapshotDelta{}
	if b == nil {
		return delta
	}

	// calculate delta between IssuedCertificates
	certificatesMeshGlooSoloIoV1Alpha2IssuedCertificateDelta := b.GetCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates().Delta(other.GetCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates())
	certificatesMeshGlooSoloIoV1Alpha2IssuedCertificateGvk := schema.GroupVersionKind{
		Group:   "certificates.mesh.gloo.solo.io",
		Version: "v1alpha2",
		Kind:    "IssuedCertificate",
	}
	delta.AddInserted(certificatesMeshGlooSoloIoV1Alpha2IssuedCertificateGvk, certificatesMeshGlooSoloIoV1Alpha2IssuedCertificateDelta.Inserted)
	delta.AddRemoved(certificatesMeshGlooSoloIoV1Alpha2IssuedCertificateGvk, certificatesMeshGlooSoloIoV1Alpha2IssuedCertificateDelta.Removed)
	// calculate delta between PodBounceDirectives
	certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectiveDelta := b.GetCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives().Delta(other.GetCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives())
	certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectiveGvk := schema.GroupVersionKind{
		Group:   "certificates.mesh.gloo.solo.io",
		Version: "v1alpha2",
		Kind:    "PodBounceDirective",
	}
	delta.AddInserted(certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectiveGvk, certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectiveDelta.Inserted)
	delta.AddRemoved(certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectiveGvk, certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectiveDelta.Removed)

	// calculate delta between XdsConfigs
	xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigDelta := b.GetXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs().Delta(other.GetXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs())
	xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigGvk := schema.GroupVersionKind{
		Group:   "xds.agent.enterprise.mesh.gloo.solo.io",
		Version: "v1alpha1",
		Kind:    "XdsConfig",
	}
	delta.AddInserted(xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigGvk, xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigDelta.Inserted)
	delta.AddRemoved(xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigGvk, xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigDelta.Removed)

	// calculate delta between DestinationRules
	networkingIstioIoV1Alpha3DestinationRuleDelta := b.GetNetworkingIstioIo_V1Alpha3_DestinationRules().Delta(other.GetNetworkingIstioIo_V1Alpha3_DestinationRules())
	networkingIstioIoV1Alpha3DestinationRuleGvk := schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "DestinationRule",
	}
	delta.AddInserted(networkingIstioIoV1Alpha3DestinationRuleGvk, networkingIstioIoV1Alpha3DestinationRuleDelta.Inserted)
	delta.AddRemoved(networkingIstioIoV1Alpha3DestinationRuleGvk, networkingIstioIoV1Alpha3DestinationRuleDelta.Removed)
	// calculate delta between EnvoyFilters
	networkingIstioIoV1Alpha3EnvoyFilterDelta := b.GetNetworkingIstioIo_V1Alpha3_EnvoyFilters().Delta(other.GetNetworkingIstioIo_V1Alpha3_EnvoyFilters())
	networkingIstioIoV1Alpha3EnvoyFilterGvk := schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "EnvoyFilter",
	}
	delta.AddInserted(networkingIstioIoV1Alpha3EnvoyFilterGvk, networkingIstioIoV1Alpha3EnvoyFilterDelta.Inserted)
	delta.AddRemoved(networkingIstioIoV1Alpha3EnvoyFilterGvk, networkingIstioIoV1Alpha3EnvoyFilterDelta.Removed)
	// calculate delta between Gateways
	networkingIstioIoV1Alpha3GatewayDelta := b.GetNetworkingIstioIo_V1Alpha3_Gateways().Delta(other.GetNetworkingIstioIo_V1Alpha3_Gateways())
	networkingIstioIoV1Alpha3GatewayGvk := schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "Gateway",
	}
	delta.AddInserted(networkingIstioIoV1Alpha3GatewayGvk, networkingIstioIoV1Alpha3GatewayDelta.Inserted)
	delta.AddRemoved(networkingIstioIoV1Alpha3GatewayGvk, networkingIstioIoV1Alpha3GatewayDelta.Removed)
	// calculate delta between ServiceEntries
	networkingIstioIoV1Alpha3ServiceEntryDelta := b.GetNetworkingIstioIo_V1Alpha3_ServiceEntries().Delta(other.GetNetworkingIstioIo_V1Alpha3_ServiceEntries())
	networkingIstioIoV1Alpha3ServiceEntryGvk := schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "ServiceEntry",
	}
	delta.AddInserted(networkingIstioIoV1Alpha3ServiceEntryGvk, networkingIstioIoV1Alpha3ServiceEntryDelta.Inserted)
	delta.AddRemoved(networkingIstioIoV1Alpha3ServiceEntryGvk, networkingIstioIoV1Alpha3ServiceEntryDelta.Removed)
	// calculate delta between VirtualServices
	networkingIstioIoV1Alpha3VirtualServiceDelta := b.GetNetworkingIstioIo_V1Alpha3_VirtualServices().Delta(other.GetNetworkingIstioIo_V1Alpha3_VirtualServices())
	networkingIstioIoV1Alpha3VirtualServiceGvk := schema.GroupVersionKind{
		Group:   "networking.istio.io",
		Version: "v1alpha3",
		Kind:    "VirtualService",
	}
	delta.AddInserted(networkingIstioIoV1Alpha3VirtualServiceGvk, networkingIstioIoV1Alpha3VirtualServiceDelta.Inserted)
	delta.AddRemoved(networkingIstioIoV1Alpha3VirtualServiceGvk, networkingIstioIoV1Alpha3VirtualServiceDelta.Removed)

	// calculate delta between AuthorizationPolicies
	securityIstioIoV1Beta1AuthorizationPolicyDelta := b.GetSecurityIstioIo_V1Beta1_AuthorizationPolicies().Delta(other.GetSecurityIstioIo_V1Beta1_AuthorizationPolicies())
	securityIstioIoV1Beta1AuthorizationPolicyGvk := schema.GroupVersionKind{
		Group:   "security.istio.io",
		Version: "v1beta1",
		Kind:    "AuthorizationPolicy",
	}
	delta.AddInserted(securityIstioIoV1Beta1AuthorizationPolicyGvk, securityIstioIoV1Beta1AuthorizationPolicyDelta.Inserted)
	delta.AddRemoved(securityIstioIoV1Beta1AuthorizationPolicyGvk, securityIstioIoV1Beta1AuthorizationPolicyDelta.Removed)

	// calculate delta between ConfigMaps
	v1ConfigMapDelta := b.GetV1_ConfigMaps().Delta(other.GetV1_ConfigMaps())
	v1ConfigMapGvk := schema.GroupVersionKind{
		Group:   "",
		Version: "v1",
		Kind:    "ConfigMap",
	}
	delta.AddInserted(v1ConfigMapGvk, v1ConfigMapDelta.Inserted)
	delta.AddRemoved(v1ConfigMapGvk, v1ConfigMapDelta.Removed)
	return delta
}
