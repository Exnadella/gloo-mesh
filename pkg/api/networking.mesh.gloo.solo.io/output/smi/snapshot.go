// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./snapshot.go -destination mocks/snapshot.go

// Definitions for Output Snapshots
package smi

import (
	"context"
	"encoding/json"
	"sort"

	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/solo-io/go-utils/contextutils"
	"github.com/solo-io/skv2/pkg/multicluster"

	"github.com/rotisserie/eris"
	"github.com/solo-io/skv2/contrib/pkg/output"
	"github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"sigs.k8s.io/controller-runtime/pkg/client"

	split_smi_spec_io_v1alpha2 "github.com/servicemeshinterface/smi-sdk-go/pkg/apis/split/v1alpha2"
	split_smi_spec_io_v1alpha2_sets "github.com/solo-io/external-apis/pkg/api/smi/split.smi-spec.io/v1alpha2/sets"

	access_smi_spec_io_v1alpha2 "github.com/servicemeshinterface/smi-sdk-go/pkg/apis/access/v1alpha2"
	access_smi_spec_io_v1alpha2_sets "github.com/solo-io/external-apis/pkg/api/smi/access.smi-spec.io/v1alpha2/sets"

	specs_smi_spec_io_v1alpha3 "github.com/servicemeshinterface/smi-sdk-go/pkg/apis/specs/v1alpha3"
	specs_smi_spec_io_v1alpha3_sets "github.com/solo-io/external-apis/pkg/api/smi/specs.smi-spec.io/v1alpha3/sets"
)

// this error can occur if constructing a Partitioned Snapshot from a resource
// that is missing the partition label
var MissingRequiredLabelError = func(labelKey, resourceKind string, obj ezkube.ResourceId) error {
	return eris.Errorf("expected label %v not on labels of %v %v", labelKey, resourceKind, sets.Key(obj))
}

// the snapshot of output resources produced by a translation
type Snapshot interface {

	// return the set of SplitSmiSpecIo_V1Alpha2_TrafficSplits with a given set of labels
	SplitSmiSpecIo_V1Alpha2_TrafficSplits() []LabeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet
	// return the set of AccessSmiSpecIo_V1Alpha2_TrafficTargets with a given set of labels
	AccessSmiSpecIo_V1Alpha2_TrafficTargets() []LabeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet
	// return the set of SpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups with a given set of labels
	SpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups() []LabeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet

	// apply the snapshot to the local cluster, garbage collecting stale resources
	ApplyLocalCluster(ctx context.Context, clusterClient client.Client, errHandler output.ErrorHandler)

	// apply resources from the snapshot across multiple clusters, garbage collecting stale resources
	ApplyMultiCluster(ctx context.Context, multiClusterClient multicluster.Client, errHandler output.ErrorHandler)

	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)
}

type snapshot struct {
	name string

	splitSmiSpecIoV1Alpha2TrafficSplits   []LabeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet
	accessSmiSpecIoV1Alpha2TrafficTargets []LabeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet
	specsSmiSpecIoV1Alpha3HTTPRouteGroups []LabeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet
	clusters                              []string
}

func NewSnapshot(
	name string,

	splitSmiSpecIoV1Alpha2TrafficSplits []LabeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet,
	accessSmiSpecIoV1Alpha2TrafficTargets []LabeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet,
	specsSmiSpecIoV1Alpha3HTTPRouteGroups []LabeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet,
	clusters ...string, // the set of clusters to apply the snapshot to. only required for multicluster snapshots.
) Snapshot {
	return &snapshot{
		name: name,

		splitSmiSpecIoV1Alpha2TrafficSplits:   splitSmiSpecIoV1Alpha2TrafficSplits,
		accessSmiSpecIoV1Alpha2TrafficTargets: accessSmiSpecIoV1Alpha2TrafficTargets,
		specsSmiSpecIoV1Alpha3HTTPRouteGroups: specsSmiSpecIoV1Alpha3HTTPRouteGroups,
		clusters:                              clusters,
	}
}

// automatically partitions the input resources
// by the presence of the provided label.
func NewLabelPartitionedSnapshot(
	name,
	labelKey string, // the key by which to partition the resources

	splitSmiSpecIoV1Alpha2TrafficSplits split_smi_spec_io_v1alpha2_sets.TrafficSplitSet,

	accessSmiSpecIoV1Alpha2TrafficTargets access_smi_spec_io_v1alpha2_sets.TrafficTargetSet,

	specsSmiSpecIoV1Alpha3HTTPRouteGroups specs_smi_spec_io_v1alpha3_sets.HTTPRouteGroupSet,
	clusters ...string, // the set of clusters to apply the snapshot to. only required for multicluster snapshots.
) (Snapshot, error) {

	partitionedSplitSmiSpecIo_V1Alpha2_TrafficSplits, err := partitionSplitSmiSpecIo_V1Alpha2_TrafficSplitsByLabel(labelKey, splitSmiSpecIoV1Alpha2TrafficSplits)
	if err != nil {
		return nil, err
	}
	partitionedAccessSmiSpecIo_V1Alpha2_TrafficTargets, err := partitionAccessSmiSpecIo_V1Alpha2_TrafficTargetsByLabel(labelKey, accessSmiSpecIoV1Alpha2TrafficTargets)
	if err != nil {
		return nil, err
	}
	partitionedSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups, err := partitionSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupsByLabel(labelKey, specsSmiSpecIoV1Alpha3HTTPRouteGroups)
	if err != nil {
		return nil, err
	}

	return NewSnapshot(
		name,

		partitionedSplitSmiSpecIo_V1Alpha2_TrafficSplits,
		partitionedAccessSmiSpecIo_V1Alpha2_TrafficTargets,
		partitionedSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups,
		clusters...,
	), nil
}

// simplified constructor for a snapshot
// with a single label partition (i.e. all resources share a single set of labels).
func NewSinglePartitionedSnapshot(
	name string,
	snapshotLabels map[string]string, // a single set of labels shared by all resources

	splitSmiSpecIoV1Alpha2TrafficSplits split_smi_spec_io_v1alpha2_sets.TrafficSplitSet,

	accessSmiSpecIoV1Alpha2TrafficTargets access_smi_spec_io_v1alpha2_sets.TrafficTargetSet,

	specsSmiSpecIoV1Alpha3HTTPRouteGroups specs_smi_spec_io_v1alpha3_sets.HTTPRouteGroupSet,
	clusters ...string, // the set of clusters to apply the snapshot to. only required for multicluster snapshots.
) (Snapshot, error) {

	labeledSplitSmiSpecIo_V1Alpha2_TrafficSplit, err := NewLabeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet(splitSmiSpecIoV1Alpha2TrafficSplits, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledAccessSmiSpecIo_V1Alpha2_TrafficTarget, err := NewLabeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet(accessSmiSpecIoV1Alpha2TrafficTargets, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroup, err := NewLabeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet(specsSmiSpecIoV1Alpha3HTTPRouteGroups, snapshotLabels)
	if err != nil {
		return nil, err
	}

	return NewSnapshot(
		name,

		[]LabeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet{labeledSplitSmiSpecIo_V1Alpha2_TrafficSplit},
		[]LabeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet{labeledAccessSmiSpecIo_V1Alpha2_TrafficTarget},
		[]LabeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet{labeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroup},
		clusters...,
	), nil
}

// apply the desired resources to the cluster state; remove stale resources where necessary
func (s *snapshot) ApplyLocalCluster(ctx context.Context, cli client.Client, errHandler output.ErrorHandler) {
	var genericLists []output.ResourceList

	for _, outputSet := range s.splitSmiSpecIoV1Alpha2TrafficSplits {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.accessSmiSpecIoV1Alpha2TrafficTargets {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.specsSmiSpecIoV1Alpha3HTTPRouteGroups {
		genericLists = append(genericLists, outputSet.Generic())
	}

	output.Snapshot{
		Name:        s.name,
		ListsToSync: genericLists,
	}.SyncLocalCluster(ctx, cli, errHandler)
}

// apply the desired resources to multiple cluster states; remove stale resources where necessary
func (s *snapshot) ApplyMultiCluster(ctx context.Context, multiClusterClient multicluster.Client, errHandler output.ErrorHandler) {
	var genericLists []output.ResourceList

	for _, outputSet := range s.splitSmiSpecIoV1Alpha2TrafficSplits {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.accessSmiSpecIoV1Alpha2TrafficTargets {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.specsSmiSpecIoV1Alpha3HTTPRouteGroups {
		genericLists = append(genericLists, outputSet.Generic())
	}

	output.Snapshot{
		Name:        s.name,
		Clusters:    s.clusters,
		ListsToSync: genericLists,
	}.SyncMultiCluster(ctx, multiClusterClient, errHandler)
}

func partitionSplitSmiSpecIo_V1Alpha2_TrafficSplitsByLabel(labelKey string, set split_smi_spec_io_v1alpha2_sets.TrafficSplitSet) ([]LabeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet, error) {
	setsByLabel := map[string]split_smi_spec_io_v1alpha2_sets.TrafficSplitSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "SplitSmiSpecIo_V1Alpha2_TrafficSplit", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "SplitSmiSpecIo_V1Alpha2_TrafficSplit", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = split_smi_spec_io_v1alpha2_sets.NewTrafficSplitSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedSplitSmiSpecIo_V1Alpha2_TrafficSplits []LabeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedSplitSmiSpecIo_V1Alpha2_TrafficSplits = append(partitionedSplitSmiSpecIo_V1Alpha2_TrafficSplits, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedSplitSmiSpecIo_V1Alpha2_TrafficSplits, func(i, j int) bool {
		leftLabelValue := partitionedSplitSmiSpecIo_V1Alpha2_TrafficSplits[i].Labels()[labelKey]
		rightLabelValue := partitionedSplitSmiSpecIo_V1Alpha2_TrafficSplits[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedSplitSmiSpecIo_V1Alpha2_TrafficSplits, nil
}

func partitionAccessSmiSpecIo_V1Alpha2_TrafficTargetsByLabel(labelKey string, set access_smi_spec_io_v1alpha2_sets.TrafficTargetSet) ([]LabeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet, error) {
	setsByLabel := map[string]access_smi_spec_io_v1alpha2_sets.TrafficTargetSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "AccessSmiSpecIo_V1Alpha2_TrafficTarget", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "AccessSmiSpecIo_V1Alpha2_TrafficTarget", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = access_smi_spec_io_v1alpha2_sets.NewTrafficTargetSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedAccessSmiSpecIo_V1Alpha2_TrafficTargets []LabeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedAccessSmiSpecIo_V1Alpha2_TrafficTargets = append(partitionedAccessSmiSpecIo_V1Alpha2_TrafficTargets, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedAccessSmiSpecIo_V1Alpha2_TrafficTargets, func(i, j int) bool {
		leftLabelValue := partitionedAccessSmiSpecIo_V1Alpha2_TrafficTargets[i].Labels()[labelKey]
		rightLabelValue := partitionedAccessSmiSpecIo_V1Alpha2_TrafficTargets[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedAccessSmiSpecIo_V1Alpha2_TrafficTargets, nil
}

func partitionSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupsByLabel(labelKey string, set specs_smi_spec_io_v1alpha3_sets.HTTPRouteGroupSet) ([]LabeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet, error) {
	setsByLabel := map[string]specs_smi_spec_io_v1alpha3_sets.HTTPRouteGroupSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "SpecsSmiSpecIo_V1Alpha3_HTTPRouteGroup", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "SpecsSmiSpecIo_V1Alpha3_HTTPRouteGroup", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = specs_smi_spec_io_v1alpha3_sets.NewHTTPRouteGroupSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups []LabeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups = append(partitionedSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups, func(i, j int) bool {
		leftLabelValue := partitionedSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups[i].Labels()[labelKey]
		rightLabelValue := partitionedSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups, nil
}

func (s snapshot) SplitSmiSpecIo_V1Alpha2_TrafficSplits() []LabeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet {
	return s.splitSmiSpecIoV1Alpha2TrafficSplits
}

func (s snapshot) AccessSmiSpecIo_V1Alpha2_TrafficTargets() []LabeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet {
	return s.accessSmiSpecIoV1Alpha2TrafficTargets
}

func (s snapshot) SpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups() []LabeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet {
	return s.specsSmiSpecIoV1Alpha3HTTPRouteGroups
}

func (s snapshot) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	splitSmiSpecIoV1Alpha2TrafficSplitSet := split_smi_spec_io_v1alpha2_sets.NewTrafficSplitSet()
	for _, set := range s.splitSmiSpecIoV1Alpha2TrafficSplits {
		splitSmiSpecIoV1Alpha2TrafficSplitSet = splitSmiSpecIoV1Alpha2TrafficSplitSet.Union(set.Set())
	}
	snapshotMap["splitSmiSpecIoV1Alpha2TrafficSplits"] = splitSmiSpecIoV1Alpha2TrafficSplitSet.List()

	accessSmiSpecIoV1Alpha2TrafficTargetSet := access_smi_spec_io_v1alpha2_sets.NewTrafficTargetSet()
	for _, set := range s.accessSmiSpecIoV1Alpha2TrafficTargets {
		accessSmiSpecIoV1Alpha2TrafficTargetSet = accessSmiSpecIoV1Alpha2TrafficTargetSet.Union(set.Set())
	}
	snapshotMap["accessSmiSpecIoV1Alpha2TrafficTargets"] = accessSmiSpecIoV1Alpha2TrafficTargetSet.List()

	specsSmiSpecIoV1Alpha3HTTPRouteGroupSet := specs_smi_spec_io_v1alpha3_sets.NewHTTPRouteGroupSet()
	for _, set := range s.specsSmiSpecIoV1Alpha3HTTPRouteGroups {
		specsSmiSpecIoV1Alpha3HTTPRouteGroupSet = specsSmiSpecIoV1Alpha3HTTPRouteGroupSet.Union(set.Set())
	}
	snapshotMap["specsSmiSpecIoV1Alpha3HTTPRouteGroups"] = specsSmiSpecIoV1Alpha3HTTPRouteGroupSet.List()

	snapshotMap["clusters"] = s.clusters

	return json.Marshal(snapshotMap)
}

// LabeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet represents a set of splitSmiSpecIoV1Alpha2TrafficSplits
// which share a common set of labels.
// These labels are used to find diffs between SplitSmiSpecIo_V1Alpha2_TrafficSplitSets.
type LabeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet interface {
	// returns the set of Labels shared by this SplitSmiSpecIo_V1Alpha2_TrafficSplitSet
	Labels() map[string]string

	// returns the set of TrafficSplites with the given labels
	Set() split_smi_spec_io_v1alpha2_sets.TrafficSplitSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet struct {
	set    split_smi_spec_io_v1alpha2_sets.TrafficSplitSet
	labels map[string]string
}

func NewLabeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet(set split_smi_spec_io_v1alpha2_sets.TrafficSplitSet, labels map[string]string) (LabeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet, error) {
	// validate that each TrafficSplit contains the labels, else this is not a valid LabeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on SplitSmiSpecIo_V1Alpha2_TrafficSplit %v", k, v, item.Name)
			}
		}
	}

	return &labeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet{set: set, labels: labels}, nil
}

func (l *labeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet) Set() split_smi_spec_io_v1alpha2_sets.TrafficSplitSet {
	return l.set
}

func (l labeledSplitSmiSpecIo_V1Alpha2_TrafficSplitSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list split_smi_spec_io_v1alpha2.TrafficSplitList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "TrafficSplit",
	}
}

// LabeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet represents a set of accessSmiSpecIoV1Alpha2TrafficTargets
// which share a common set of labels.
// These labels are used to find diffs between AccessSmiSpecIo_V1Alpha2_TrafficTargetSets.
type LabeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet interface {
	// returns the set of Labels shared by this AccessSmiSpecIo_V1Alpha2_TrafficTargetSet
	Labels() map[string]string

	// returns the set of TrafficTargetes with the given labels
	Set() access_smi_spec_io_v1alpha2_sets.TrafficTargetSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet struct {
	set    access_smi_spec_io_v1alpha2_sets.TrafficTargetSet
	labels map[string]string
}

func NewLabeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet(set access_smi_spec_io_v1alpha2_sets.TrafficTargetSet, labels map[string]string) (LabeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet, error) {
	// validate that each TrafficTarget contains the labels, else this is not a valid LabeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on AccessSmiSpecIo_V1Alpha2_TrafficTarget %v", k, v, item.Name)
			}
		}
	}

	return &labeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet{set: set, labels: labels}, nil
}

func (l *labeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet) Set() access_smi_spec_io_v1alpha2_sets.TrafficTargetSet {
	return l.set
}

func (l labeledAccessSmiSpecIo_V1Alpha2_TrafficTargetSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list access_smi_spec_io_v1alpha2.TrafficTargetList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "TrafficTarget",
	}
}

// LabeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet represents a set of specsSmiSpecIoV1Alpha3HTTPRouteGroups
// which share a common set of labels.
// These labels are used to find diffs between SpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSets.
type LabeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet interface {
	// returns the set of Labels shared by this SpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet
	Labels() map[string]string

	// returns the set of HTTPRouteGroupes with the given labels
	Set() specs_smi_spec_io_v1alpha3_sets.HTTPRouteGroupSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet struct {
	set    specs_smi_spec_io_v1alpha3_sets.HTTPRouteGroupSet
	labels map[string]string
}

func NewLabeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet(set specs_smi_spec_io_v1alpha3_sets.HTTPRouteGroupSet, labels map[string]string) (LabeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet, error) {
	// validate that each HTTPRouteGroup contains the labels, else this is not a valid LabeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on SpecsSmiSpecIo_V1Alpha3_HTTPRouteGroup %v", k, v, item.Name)
			}
		}
	}

	return &labeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet{set: set, labels: labels}, nil
}

func (l *labeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet) Set() specs_smi_spec_io_v1alpha3_sets.HTTPRouteGroupSet {
	return l.set
}

func (l labeledSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroupSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list specs_smi_spec_io_v1alpha3.HTTPRouteGroupList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "HTTPRouteGroup",
	}
}

type builder struct {
	ctx      context.Context
	name     string
	clusters []string

	splitSmiSpecIoV1Alpha2TrafficSplits split_smi_spec_io_v1alpha2_sets.TrafficSplitSet

	accessSmiSpecIoV1Alpha2TrafficTargets access_smi_spec_io_v1alpha2_sets.TrafficTargetSet

	specsSmiSpecIoV1Alpha3HTTPRouteGroups specs_smi_spec_io_v1alpha3_sets.HTTPRouteGroupSet
}

func NewBuilder(ctx context.Context, name string) *builder {
	return &builder{
		ctx:  ctx,
		name: name,

		splitSmiSpecIoV1Alpha2TrafficSplits: split_smi_spec_io_v1alpha2_sets.NewTrafficSplitSet(),

		accessSmiSpecIoV1Alpha2TrafficTargets: access_smi_spec_io_v1alpha2_sets.NewTrafficTargetSet(),

		specsSmiSpecIoV1Alpha3HTTPRouteGroups: specs_smi_spec_io_v1alpha3_sets.NewHTTPRouteGroupSet(),
	}
}

// the output Builder uses a builder pattern to allow
// iteratively collecting outputs before producing a final snapshot
type Builder interface {

	// add SplitSmiSpecIo_V1Alpha2_TrafficSplits to the collected outputs
	AddSplitSmiSpecIo_V1Alpha2_TrafficSplits(splitSmiSpecIoV1Alpha2TrafficSplits ...*split_smi_spec_io_v1alpha2.TrafficSplit)

	// get the collected SplitSmiSpecIo_V1Alpha2_TrafficSplits
	GetSplitSmiSpecIo_V1Alpha2_TrafficSplits() split_smi_spec_io_v1alpha2_sets.TrafficSplitSet

	// add AccessSmiSpecIo_V1Alpha2_TrafficTargets to the collected outputs
	AddAccessSmiSpecIo_V1Alpha2_TrafficTargets(accessSmiSpecIoV1Alpha2TrafficTargets ...*access_smi_spec_io_v1alpha2.TrafficTarget)

	// get the collected AccessSmiSpecIo_V1Alpha2_TrafficTargets
	GetAccessSmiSpecIo_V1Alpha2_TrafficTargets() access_smi_spec_io_v1alpha2_sets.TrafficTargetSet

	// add SpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups to the collected outputs
	AddSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups(specsSmiSpecIoV1Alpha3HTTPRouteGroups ...*specs_smi_spec_io_v1alpha3.HTTPRouteGroup)

	// get the collected SpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups
	GetSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups() specs_smi_spec_io_v1alpha3_sets.HTTPRouteGroupSet

	// build the collected outputs into a label-partitioned snapshot
	BuildLabelPartitionedSnapshot(labelKey string) (Snapshot, error)

	// build the collected outputs into a snapshot with a single partition
	BuildSinglePartitionedSnapshot(snapshotLabels map[string]string) (Snapshot, error)

	// add a cluster to the collected clusters.
	// this can be used to collect clusters for use with MultiCluster snapshots.
	AddCluster(cluster string)

	// returns the set of clusters currently stored in this builder
	Clusters() []string

	// merge all the resources from another Builder into this one
	Merge(other Builder)

	// create a clone of this builder (deepcopying all resources)
	Clone() Builder

	// return the difference between the snapshot in this builder's and another
	Delta(newSnap Builder) output.SnapshotDelta
}

func (b *builder) AddSplitSmiSpecIo_V1Alpha2_TrafficSplits(splitSmiSpecIoV1Alpha2TrafficSplits ...*split_smi_spec_io_v1alpha2.TrafficSplit) {
	for _, obj := range splitSmiSpecIoV1Alpha2TrafficSplits {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output SplitSmiSpecIo_V1Alpha2_TrafficSplit %v", sets.Key(obj))
		b.splitSmiSpecIoV1Alpha2TrafficSplits.Insert(obj)
	}
}
func (b *builder) AddAccessSmiSpecIo_V1Alpha2_TrafficTargets(accessSmiSpecIoV1Alpha2TrafficTargets ...*access_smi_spec_io_v1alpha2.TrafficTarget) {
	for _, obj := range accessSmiSpecIoV1Alpha2TrafficTargets {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output AccessSmiSpecIo_V1Alpha2_TrafficTarget %v", sets.Key(obj))
		b.accessSmiSpecIoV1Alpha2TrafficTargets.Insert(obj)
	}
}
func (b *builder) AddSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups(specsSmiSpecIoV1Alpha3HTTPRouteGroups ...*specs_smi_spec_io_v1alpha3.HTTPRouteGroup) {
	for _, obj := range specsSmiSpecIoV1Alpha3HTTPRouteGroups {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output SpecsSmiSpecIo_V1Alpha3_HTTPRouteGroup %v", sets.Key(obj))
		b.specsSmiSpecIoV1Alpha3HTTPRouteGroups.Insert(obj)
	}
}

func (b *builder) GetSplitSmiSpecIo_V1Alpha2_TrafficSplits() split_smi_spec_io_v1alpha2_sets.TrafficSplitSet {
	return b.splitSmiSpecIoV1Alpha2TrafficSplits
}

func (b *builder) GetAccessSmiSpecIo_V1Alpha2_TrafficTargets() access_smi_spec_io_v1alpha2_sets.TrafficTargetSet {
	return b.accessSmiSpecIoV1Alpha2TrafficTargets
}

func (b *builder) GetSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups() specs_smi_spec_io_v1alpha3_sets.HTTPRouteGroupSet {
	return b.specsSmiSpecIoV1Alpha3HTTPRouteGroups
}

func (b *builder) BuildLabelPartitionedSnapshot(labelKey string) (Snapshot, error) {
	return NewLabelPartitionedSnapshot(
		b.name,
		labelKey,

		b.splitSmiSpecIoV1Alpha2TrafficSplits,

		b.accessSmiSpecIoV1Alpha2TrafficTargets,

		b.specsSmiSpecIoV1Alpha3HTTPRouteGroups,
		b.clusters...,
	)
}

func (b *builder) BuildSinglePartitionedSnapshot(snapshotLabels map[string]string) (Snapshot, error) {
	return NewSinglePartitionedSnapshot(
		b.name,
		snapshotLabels,

		b.splitSmiSpecIoV1Alpha2TrafficSplits,

		b.accessSmiSpecIoV1Alpha2TrafficTargets,

		b.specsSmiSpecIoV1Alpha3HTTPRouteGroups,
		b.clusters...,
	)
}

func (b *builder) AddCluster(cluster string) {
	b.clusters = append(b.clusters, cluster)
}

func (b *builder) Clusters() []string {
	return b.clusters
}

func (b *builder) Merge(other Builder) {
	if other == nil {
		return
	}

	b.AddSplitSmiSpecIo_V1Alpha2_TrafficSplits(other.GetSplitSmiSpecIo_V1Alpha2_TrafficSplits().List()...)

	b.AddAccessSmiSpecIo_V1Alpha2_TrafficTargets(other.GetAccessSmiSpecIo_V1Alpha2_TrafficTargets().List()...)

	b.AddSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups(other.GetSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups().List()...)
	for _, cluster := range other.Clusters() {
		b.AddCluster(cluster)
	}
}

func (b *builder) Clone() Builder {
	if b == nil {
		return nil
	}
	clone := NewBuilder(b.ctx, b.name)

	for _, splitSmiSpecIoV1Alpha2TrafficSplit := range b.GetSplitSmiSpecIo_V1Alpha2_TrafficSplits().List() {
		clone.AddSplitSmiSpecIo_V1Alpha2_TrafficSplits(splitSmiSpecIoV1Alpha2TrafficSplit.DeepCopy())
	}

	for _, accessSmiSpecIoV1Alpha2TrafficTarget := range b.GetAccessSmiSpecIo_V1Alpha2_TrafficTargets().List() {
		clone.AddAccessSmiSpecIo_V1Alpha2_TrafficTargets(accessSmiSpecIoV1Alpha2TrafficTarget.DeepCopy())
	}

	for _, specsSmiSpecIoV1Alpha3HTTPRouteGroup := range b.GetSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups().List() {
		clone.AddSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups(specsSmiSpecIoV1Alpha3HTTPRouteGroup.DeepCopy())
	}
	for _, cluster := range b.Clusters() {
		clone.AddCluster(cluster)
	}
	return clone
}

func (b *builder) Delta(other Builder) output.SnapshotDelta {
	delta := output.SnapshotDelta{}
	if b == nil {
		return delta
	}

	// calculate delta between TrafficSplits
	splitSmiSpecIoV1Alpha2TrafficSplitDelta := b.GetSplitSmiSpecIo_V1Alpha2_TrafficSplits().Delta(other.GetSplitSmiSpecIo_V1Alpha2_TrafficSplits())
	splitSmiSpecIoV1Alpha2TrafficSplitGvk := schema.GroupVersionKind{
		Group:   "split.smi-spec.io",
		Version: "v1alpha2",
		Kind:    "TrafficSplit",
	}
	delta.AddInserted(splitSmiSpecIoV1Alpha2TrafficSplitGvk, splitSmiSpecIoV1Alpha2TrafficSplitDelta.Inserted)
	delta.AddRemoved(splitSmiSpecIoV1Alpha2TrafficSplitGvk, splitSmiSpecIoV1Alpha2TrafficSplitDelta.Removed)

	// calculate delta between TrafficTargets
	accessSmiSpecIoV1Alpha2TrafficTargetDelta := b.GetAccessSmiSpecIo_V1Alpha2_TrafficTargets().Delta(other.GetAccessSmiSpecIo_V1Alpha2_TrafficTargets())
	accessSmiSpecIoV1Alpha2TrafficTargetGvk := schema.GroupVersionKind{
		Group:   "access.smi-spec.io",
		Version: "v1alpha2",
		Kind:    "TrafficTarget",
	}
	delta.AddInserted(accessSmiSpecIoV1Alpha2TrafficTargetGvk, accessSmiSpecIoV1Alpha2TrafficTargetDelta.Inserted)
	delta.AddRemoved(accessSmiSpecIoV1Alpha2TrafficTargetGvk, accessSmiSpecIoV1Alpha2TrafficTargetDelta.Removed)

	// calculate delta between HTTPRouteGroups
	specsSmiSpecIoV1Alpha3HTTPRouteGroupDelta := b.GetSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups().Delta(other.GetSpecsSmiSpecIo_V1Alpha3_HTTPRouteGroups())
	specsSmiSpecIoV1Alpha3HTTPRouteGroupGvk := schema.GroupVersionKind{
		Group:   "specs.smi-spec.io",
		Version: "v1alpha3",
		Kind:    "HTTPRouteGroup",
	}
	delta.AddInserted(specsSmiSpecIoV1Alpha3HTTPRouteGroupGvk, specsSmiSpecIoV1Alpha3HTTPRouteGroupDelta.Inserted)
	delta.AddRemoved(specsSmiSpecIoV1Alpha3HTTPRouteGroupGvk, specsSmiSpecIoV1Alpha3HTTPRouteGroupDelta.Removed)
	return delta
}
