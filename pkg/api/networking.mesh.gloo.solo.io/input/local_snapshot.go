// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./local_snapshot.go -destination mocks/local_snapshot.go

// The Input LocalSnapshot contains the set of all:
// * SettingsMeshGlooSoloIo_V1Alpha2_Settings
// * DiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTargets
// * DiscoveryMeshGlooSoloIo_V1Alpha2_Workloads
// * DiscoveryMeshGlooSoloIo_V1Alpha2_Meshes
// * NetworkingMeshGlooSoloIo_V1Alpha2_TrafficPolicies
// * NetworkingMeshGlooSoloIo_V1Alpha2_AccessPolicies
// * NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes
// * NetworkingMeshGlooSoloIo_V1Alpha2_FailoverServices
// * NetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeployments
// * ObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecords
// * V1_Secrets
// * MulticlusterSoloIo_V1Alpha1_KubernetesClusters
// read from a given cluster or set of clusters, across all namespaces.
//
// A snapshot can be constructed from either a single Manager (for a single cluster)
// or a ClusterWatcher (for multiple clusters) using the LocalSnapshotBuilder.
//
// Resources in a MultiCluster snapshot will have their ClusterName set to the
// name of the cluster from which the resource was read.

package input

import (
	"context"
	"encoding/json"

	"github.com/solo-io/skv2/pkg/verifier"
	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/hashicorp/go-multierror"

	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/manager"

	settings_mesh_gloo_solo_io_v1alpha2 "github.com/solo-io/gloo-mesh/pkg/api/settings.mesh.gloo.solo.io/v1alpha2"
	settings_mesh_gloo_solo_io_v1alpha2_sets "github.com/solo-io/gloo-mesh/pkg/api/settings.mesh.gloo.solo.io/v1alpha2/sets"

	discovery_mesh_gloo_solo_io_v1alpha2 "github.com/solo-io/gloo-mesh/pkg/api/discovery.mesh.gloo.solo.io/v1alpha2"
	discovery_mesh_gloo_solo_io_v1alpha2_sets "github.com/solo-io/gloo-mesh/pkg/api/discovery.mesh.gloo.solo.io/v1alpha2/sets"

	networking_mesh_gloo_solo_io_v1alpha2 "github.com/solo-io/gloo-mesh/pkg/api/networking.mesh.gloo.solo.io/v1alpha2"
	networking_mesh_gloo_solo_io_v1alpha2_sets "github.com/solo-io/gloo-mesh/pkg/api/networking.mesh.gloo.solo.io/v1alpha2/sets"

	networking_enterprise_mesh_gloo_solo_io_v1alpha1 "github.com/solo-io/gloo-mesh/pkg/api/networking.enterprise.mesh.gloo.solo.io/v1alpha1"
	networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets "github.com/solo-io/gloo-mesh/pkg/api/networking.enterprise.mesh.gloo.solo.io/v1alpha1/sets"

	observability_enterprise_mesh_gloo_solo_io_v1alpha1 "github.com/solo-io/gloo-mesh/pkg/api/observability.enterprise.mesh.gloo.solo.io/v1alpha1"
	observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets "github.com/solo-io/gloo-mesh/pkg/api/observability.enterprise.mesh.gloo.solo.io/v1alpha1/sets"

	v1 "github.com/solo-io/external-apis/pkg/api/k8s/core/v1"
	v1_sets "github.com/solo-io/external-apis/pkg/api/k8s/core/v1/sets"

	multicluster_solo_io_v1alpha1 "github.com/solo-io/skv2/pkg/api/multicluster.solo.io/v1alpha1"
	multicluster_solo_io_v1alpha1_sets "github.com/solo-io/skv2/pkg/api/multicluster.solo.io/v1alpha1/sets"
)

// the snapshot of input resources consumed by translation
type LocalSnapshot interface {

	// return the set of input SettingsMeshGlooSoloIo_V1Alpha2_Settings
	SettingsMeshGlooSoloIo_V1Alpha2_Settings() settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet

	// return the set of input DiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTargets
	DiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTargets() discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet
	// return the set of input DiscoveryMeshGlooSoloIo_V1Alpha2_Workloads
	DiscoveryMeshGlooSoloIo_V1Alpha2_Workloads() discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet
	// return the set of input DiscoveryMeshGlooSoloIo_V1Alpha2_Meshes
	DiscoveryMeshGlooSoloIo_V1Alpha2_Meshes() discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet

	// return the set of input NetworkingMeshGlooSoloIo_V1Alpha2_TrafficPolicies
	NetworkingMeshGlooSoloIo_V1Alpha2_TrafficPolicies() networking_mesh_gloo_solo_io_v1alpha2_sets.TrafficPolicySet
	// return the set of input NetworkingMeshGlooSoloIo_V1Alpha2_AccessPolicies
	NetworkingMeshGlooSoloIo_V1Alpha2_AccessPolicies() networking_mesh_gloo_solo_io_v1alpha2_sets.AccessPolicySet
	// return the set of input NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes
	NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes() networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet
	// return the set of input NetworkingMeshGlooSoloIo_V1Alpha2_FailoverServices
	NetworkingMeshGlooSoloIo_V1Alpha2_FailoverServices() networking_mesh_gloo_solo_io_v1alpha2_sets.FailoverServiceSet

	// return the set of input NetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeployments
	NetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeployments() networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets.WasmDeploymentSet

	// return the set of input ObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecords
	ObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecords() observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets.AccessLogRecordSet

	// return the set of input V1_Secrets
	V1_Secrets() v1_sets.SecretSet

	// return the set of input MulticlusterSoloIo_V1Alpha1_KubernetesClusters
	MulticlusterSoloIo_V1Alpha1_KubernetesClusters() multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet
	// update the status of all input objects which support
	// the Status subresource (across multiple clusters)
	SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client, opts LocalSyncStatusOptions) error
	// update the status of all input objects which support
	// the Status subresource (in the local cluster)
	SyncStatuses(ctx context.Context, c client.Client, opts LocalSyncStatusOptions) error
	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)
}

// options for syncing input object statuses
type LocalSyncStatusOptions struct {

	// sync status of SettingsMeshGlooSoloIo_V1Alpha2_Settings objects
	SettingsMeshGlooSoloIo_V1Alpha2_Settings bool

	// sync status of DiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTarget objects
	DiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTarget bool
	// sync status of DiscoveryMeshGlooSoloIo_V1Alpha2_Workload objects
	DiscoveryMeshGlooSoloIo_V1Alpha2_Workload bool
	// sync status of DiscoveryMeshGlooSoloIo_V1Alpha2_Mesh objects
	DiscoveryMeshGlooSoloIo_V1Alpha2_Mesh bool

	// sync status of NetworkingMeshGlooSoloIo_V1Alpha2_TrafficPolicy objects
	NetworkingMeshGlooSoloIo_V1Alpha2_TrafficPolicy bool
	// sync status of NetworkingMeshGlooSoloIo_V1Alpha2_AccessPolicy objects
	NetworkingMeshGlooSoloIo_V1Alpha2_AccessPolicy bool
	// sync status of NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMesh objects
	NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMesh bool
	// sync status of NetworkingMeshGlooSoloIo_V1Alpha2_FailoverService objects
	NetworkingMeshGlooSoloIo_V1Alpha2_FailoverService bool

	// sync status of NetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeployment objects
	NetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeployment bool

	// sync status of ObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecord objects
	ObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecord bool

	// sync status of V1_Secret objects
	V1_Secret bool

	// sync status of MulticlusterSoloIo_V1Alpha1_KubernetesCluster objects
	MulticlusterSoloIo_V1Alpha1_KubernetesCluster bool
}

type snapshotLocal struct {
	name string

	settingsMeshGlooSoloIoV1Alpha2Settings settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet

	discoveryMeshGlooSoloIoV1Alpha2TrafficTargets discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet
	discoveryMeshGlooSoloIoV1Alpha2Workloads      discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet
	discoveryMeshGlooSoloIoV1Alpha2Meshes         discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet

	networkingMeshGlooSoloIoV1Alpha2TrafficPolicies  networking_mesh_gloo_solo_io_v1alpha2_sets.TrafficPolicySet
	networkingMeshGlooSoloIoV1Alpha2AccessPolicies   networking_mesh_gloo_solo_io_v1alpha2_sets.AccessPolicySet
	networkingMeshGlooSoloIoV1Alpha2VirtualMeshes    networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet
	networkingMeshGlooSoloIoV1Alpha2FailoverServices networking_mesh_gloo_solo_io_v1alpha2_sets.FailoverServiceSet

	networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets.WasmDeploymentSet

	observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets.AccessLogRecordSet

	v1Secrets v1_sets.SecretSet

	multiclusterSoloIoV1Alpha1KubernetesClusters multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet
}

func NewLocalSnapshot(
	name string,

	settingsMeshGlooSoloIoV1Alpha2Settings settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet,

	discoveryMeshGlooSoloIoV1Alpha2TrafficTargets discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet,
	discoveryMeshGlooSoloIoV1Alpha2Workloads discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet,
	discoveryMeshGlooSoloIoV1Alpha2Meshes discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet,

	networkingMeshGlooSoloIoV1Alpha2TrafficPolicies networking_mesh_gloo_solo_io_v1alpha2_sets.TrafficPolicySet,
	networkingMeshGlooSoloIoV1Alpha2AccessPolicies networking_mesh_gloo_solo_io_v1alpha2_sets.AccessPolicySet,
	networkingMeshGlooSoloIoV1Alpha2VirtualMeshes networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet,
	networkingMeshGlooSoloIoV1Alpha2FailoverServices networking_mesh_gloo_solo_io_v1alpha2_sets.FailoverServiceSet,

	networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets.WasmDeploymentSet,

	observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets.AccessLogRecordSet,

	v1Secrets v1_sets.SecretSet,

	multiclusterSoloIoV1Alpha1KubernetesClusters multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet,

) LocalSnapshot {
	return &snapshotLocal{
		name: name,

		settingsMeshGlooSoloIoV1Alpha2Settings:                        settingsMeshGlooSoloIoV1Alpha2Settings,
		discoveryMeshGlooSoloIoV1Alpha2TrafficTargets:                 discoveryMeshGlooSoloIoV1Alpha2TrafficTargets,
		discoveryMeshGlooSoloIoV1Alpha2Workloads:                      discoveryMeshGlooSoloIoV1Alpha2Workloads,
		discoveryMeshGlooSoloIoV1Alpha2Meshes:                         discoveryMeshGlooSoloIoV1Alpha2Meshes,
		networkingMeshGlooSoloIoV1Alpha2TrafficPolicies:               networkingMeshGlooSoloIoV1Alpha2TrafficPolicies,
		networkingMeshGlooSoloIoV1Alpha2AccessPolicies:                networkingMeshGlooSoloIoV1Alpha2AccessPolicies,
		networkingMeshGlooSoloIoV1Alpha2VirtualMeshes:                 networkingMeshGlooSoloIoV1Alpha2VirtualMeshes,
		networkingMeshGlooSoloIoV1Alpha2FailoverServices:              networkingMeshGlooSoloIoV1Alpha2FailoverServices,
		networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments:     networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments,
		observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords: observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords,
		v1Secrets: v1Secrets,
		multiclusterSoloIoV1Alpha1KubernetesClusters: multiclusterSoloIoV1Alpha1KubernetesClusters,
	}
}

func (s snapshotLocal) SettingsMeshGlooSoloIo_V1Alpha2_Settings() settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet {
	return s.settingsMeshGlooSoloIoV1Alpha2Settings
}

func (s snapshotLocal) DiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTargets() discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet {
	return s.discoveryMeshGlooSoloIoV1Alpha2TrafficTargets
}

func (s snapshotLocal) DiscoveryMeshGlooSoloIo_V1Alpha2_Workloads() discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet {
	return s.discoveryMeshGlooSoloIoV1Alpha2Workloads
}

func (s snapshotLocal) DiscoveryMeshGlooSoloIo_V1Alpha2_Meshes() discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet {
	return s.discoveryMeshGlooSoloIoV1Alpha2Meshes
}

func (s snapshotLocal) NetworkingMeshGlooSoloIo_V1Alpha2_TrafficPolicies() networking_mesh_gloo_solo_io_v1alpha2_sets.TrafficPolicySet {
	return s.networkingMeshGlooSoloIoV1Alpha2TrafficPolicies
}

func (s snapshotLocal) NetworkingMeshGlooSoloIo_V1Alpha2_AccessPolicies() networking_mesh_gloo_solo_io_v1alpha2_sets.AccessPolicySet {
	return s.networkingMeshGlooSoloIoV1Alpha2AccessPolicies
}

func (s snapshotLocal) NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes() networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet {
	return s.networkingMeshGlooSoloIoV1Alpha2VirtualMeshes
}

func (s snapshotLocal) NetworkingMeshGlooSoloIo_V1Alpha2_FailoverServices() networking_mesh_gloo_solo_io_v1alpha2_sets.FailoverServiceSet {
	return s.networkingMeshGlooSoloIoV1Alpha2FailoverServices
}

func (s snapshotLocal) NetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeployments() networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets.WasmDeploymentSet {
	return s.networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments
}

func (s snapshotLocal) ObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecords() observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets.AccessLogRecordSet {
	return s.observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords
}

func (s snapshotLocal) V1_Secrets() v1_sets.SecretSet {
	return s.v1Secrets
}

func (s snapshotLocal) MulticlusterSoloIo_V1Alpha1_KubernetesClusters() multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet {
	return s.multiclusterSoloIoV1Alpha1KubernetesClusters
}

func (s snapshotLocal) SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client, opts LocalSyncStatusOptions) error {
	var errs error

	if opts.SettingsMeshGlooSoloIo_V1Alpha2_Settings {
		for _, obj := range s.SettingsMeshGlooSoloIo_V1Alpha2_Settings().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.DiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTarget {
		for _, obj := range s.DiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTargets().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.DiscoveryMeshGlooSoloIo_V1Alpha2_Workload {
		for _, obj := range s.DiscoveryMeshGlooSoloIo_V1Alpha2_Workloads().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.DiscoveryMeshGlooSoloIo_V1Alpha2_Mesh {
		for _, obj := range s.DiscoveryMeshGlooSoloIo_V1Alpha2_Meshes().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.NetworkingMeshGlooSoloIo_V1Alpha2_TrafficPolicy {
		for _, obj := range s.NetworkingMeshGlooSoloIo_V1Alpha2_TrafficPolicies().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.NetworkingMeshGlooSoloIo_V1Alpha2_AccessPolicy {
		for _, obj := range s.NetworkingMeshGlooSoloIo_V1Alpha2_AccessPolicies().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMesh {
		for _, obj := range s.NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.NetworkingMeshGlooSoloIo_V1Alpha2_FailoverService {
		for _, obj := range s.NetworkingMeshGlooSoloIo_V1Alpha2_FailoverServices().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.NetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeployment {
		for _, obj := range s.NetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeployments().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.ObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecord {
		for _, obj := range s.ObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecords().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.MulticlusterSoloIo_V1Alpha1_KubernetesCluster {
		for _, obj := range s.MulticlusterSoloIo_V1Alpha1_KubernetesClusters().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	return errs
}

func (s snapshotLocal) SyncStatuses(ctx context.Context, c client.Client, opts LocalSyncStatusOptions) error {
	var errs error

	if opts.SettingsMeshGlooSoloIo_V1Alpha2_Settings {
		for _, obj := range s.SettingsMeshGlooSoloIo_V1Alpha2_Settings().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.DiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTarget {
		for _, obj := range s.DiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTargets().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.DiscoveryMeshGlooSoloIo_V1Alpha2_Workload {
		for _, obj := range s.DiscoveryMeshGlooSoloIo_V1Alpha2_Workloads().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.DiscoveryMeshGlooSoloIo_V1Alpha2_Mesh {
		for _, obj := range s.DiscoveryMeshGlooSoloIo_V1Alpha2_Meshes().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.NetworkingMeshGlooSoloIo_V1Alpha2_TrafficPolicy {
		for _, obj := range s.NetworkingMeshGlooSoloIo_V1Alpha2_TrafficPolicies().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.NetworkingMeshGlooSoloIo_V1Alpha2_AccessPolicy {
		for _, obj := range s.NetworkingMeshGlooSoloIo_V1Alpha2_AccessPolicies().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMesh {
		for _, obj := range s.NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.NetworkingMeshGlooSoloIo_V1Alpha2_FailoverService {
		for _, obj := range s.NetworkingMeshGlooSoloIo_V1Alpha2_FailoverServices().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.NetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeployment {
		for _, obj := range s.NetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeployments().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.ObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecord {
		for _, obj := range s.ObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecords().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.MulticlusterSoloIo_V1Alpha1_KubernetesCluster {
		for _, obj := range s.MulticlusterSoloIo_V1Alpha1_KubernetesClusters().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	return errs
}

func (s snapshotLocal) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	snapshotMap["settingsMeshGlooSoloIoV1Alpha2Settings"] = s.settingsMeshGlooSoloIoV1Alpha2Settings.List()
	snapshotMap["discoveryMeshGlooSoloIoV1Alpha2TrafficTargets"] = s.discoveryMeshGlooSoloIoV1Alpha2TrafficTargets.List()
	snapshotMap["discoveryMeshGlooSoloIoV1Alpha2Workloads"] = s.discoveryMeshGlooSoloIoV1Alpha2Workloads.List()
	snapshotMap["discoveryMeshGlooSoloIoV1Alpha2Meshes"] = s.discoveryMeshGlooSoloIoV1Alpha2Meshes.List()
	snapshotMap["networkingMeshGlooSoloIoV1Alpha2TrafficPolicies"] = s.networkingMeshGlooSoloIoV1Alpha2TrafficPolicies.List()
	snapshotMap["networkingMeshGlooSoloIoV1Alpha2AccessPolicies"] = s.networkingMeshGlooSoloIoV1Alpha2AccessPolicies.List()
	snapshotMap["networkingMeshGlooSoloIoV1Alpha2VirtualMeshes"] = s.networkingMeshGlooSoloIoV1Alpha2VirtualMeshes.List()
	snapshotMap["networkingMeshGlooSoloIoV1Alpha2FailoverServices"] = s.networkingMeshGlooSoloIoV1Alpha2FailoverServices.List()
	snapshotMap["networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments"] = s.networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments.List()
	snapshotMap["observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords"] = s.observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords.List()
	snapshotMap["v1Secrets"] = s.v1Secrets.List()
	snapshotMap["multiclusterSoloIoV1Alpha1KubernetesClusters"] = s.multiclusterSoloIoV1Alpha1KubernetesClusters.List()
	return json.Marshal(snapshotMap)
}

// builds the input snapshot from API Clients.
type LocalBuilder interface {
	BuildSnapshot(ctx context.Context, name string, opts LocalBuildOptions) (LocalSnapshot, error)
}

// Options for building a snapshot
type LocalBuildOptions struct {

	// List options for composing a snapshot from SettingsMeshGlooSoloIo_V1Alpha2_Settings
	SettingsMeshGlooSoloIo_V1Alpha2_Settings ResourceLocalBuildOptions

	// List options for composing a snapshot from DiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTargets
	DiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTargets ResourceLocalBuildOptions
	// List options for composing a snapshot from DiscoveryMeshGlooSoloIo_V1Alpha2_Workloads
	DiscoveryMeshGlooSoloIo_V1Alpha2_Workloads ResourceLocalBuildOptions
	// List options for composing a snapshot from DiscoveryMeshGlooSoloIo_V1Alpha2_Meshes
	DiscoveryMeshGlooSoloIo_V1Alpha2_Meshes ResourceLocalBuildOptions

	// List options for composing a snapshot from NetworkingMeshGlooSoloIo_V1Alpha2_TrafficPolicies
	NetworkingMeshGlooSoloIo_V1Alpha2_TrafficPolicies ResourceLocalBuildOptions
	// List options for composing a snapshot from NetworkingMeshGlooSoloIo_V1Alpha2_AccessPolicies
	NetworkingMeshGlooSoloIo_V1Alpha2_AccessPolicies ResourceLocalBuildOptions
	// List options for composing a snapshot from NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes
	NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes ResourceLocalBuildOptions
	// List options for composing a snapshot from NetworkingMeshGlooSoloIo_V1Alpha2_FailoverServices
	NetworkingMeshGlooSoloIo_V1Alpha2_FailoverServices ResourceLocalBuildOptions

	// List options for composing a snapshot from NetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeployments
	NetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeployments ResourceLocalBuildOptions

	// List options for composing a snapshot from ObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecords
	ObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecords ResourceLocalBuildOptions

	// List options for composing a snapshot from V1_Secrets
	V1_Secrets ResourceLocalBuildOptions

	// List options for composing a snapshot from MulticlusterSoloIo_V1Alpha1_KubernetesClusters
	MulticlusterSoloIo_V1Alpha1_KubernetesClusters ResourceLocalBuildOptions
}

// Options for reading resources of a given type
type ResourceLocalBuildOptions struct {

	// List options for composing a snapshot from a resource type
	ListOptions []client.ListOption

	// If provided, ensure the resource has been verified before adding it to snapshots
	Verifier verifier.ServerResourceVerifier
}

// build a snapshot from resources across multiple clusters
type multiClusterLocalBuilder struct {
	clusters multicluster.Interface
	client   multicluster.Client
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewMultiClusterLocalBuilder(
	clusters multicluster.Interface,
	client multicluster.Client,
) LocalBuilder {
	return &multiClusterLocalBuilder{
		clusters: clusters,
		client:   client,
	}
}

func (b *multiClusterLocalBuilder) BuildSnapshot(ctx context.Context, name string, opts LocalBuildOptions) (LocalSnapshot, error) {

	settingsMeshGlooSoloIoV1Alpha2Settings := settings_mesh_gloo_solo_io_v1alpha2_sets.NewSettingsSet()

	discoveryMeshGlooSoloIoV1Alpha2TrafficTargets := discovery_mesh_gloo_solo_io_v1alpha2_sets.NewTrafficTargetSet()
	discoveryMeshGlooSoloIoV1Alpha2Workloads := discovery_mesh_gloo_solo_io_v1alpha2_sets.NewWorkloadSet()
	discoveryMeshGlooSoloIoV1Alpha2Meshes := discovery_mesh_gloo_solo_io_v1alpha2_sets.NewMeshSet()

	networkingMeshGlooSoloIoV1Alpha2TrafficPolicies := networking_mesh_gloo_solo_io_v1alpha2_sets.NewTrafficPolicySet()
	networkingMeshGlooSoloIoV1Alpha2AccessPolicies := networking_mesh_gloo_solo_io_v1alpha2_sets.NewAccessPolicySet()
	networkingMeshGlooSoloIoV1Alpha2VirtualMeshes := networking_mesh_gloo_solo_io_v1alpha2_sets.NewVirtualMeshSet()
	networkingMeshGlooSoloIoV1Alpha2FailoverServices := networking_mesh_gloo_solo_io_v1alpha2_sets.NewFailoverServiceSet()

	networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments := networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets.NewWasmDeploymentSet()

	observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords := observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets.NewAccessLogRecordSet()

	v1Secrets := v1_sets.NewSecretSet()

	multiclusterSoloIoV1Alpha1KubernetesClusters := multicluster_solo_io_v1alpha1_sets.NewKubernetesClusterSet()

	var errs error

	for _, cluster := range b.clusters.ListClusters() {

		if err := b.insertSettingsMeshGlooSoloIo_V1Alpha2_SettingsFromCluster(ctx, cluster, settingsMeshGlooSoloIoV1Alpha2Settings, opts.SettingsMeshGlooSoloIo_V1Alpha2_Settings); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertDiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTargetsFromCluster(ctx, cluster, discoveryMeshGlooSoloIoV1Alpha2TrafficTargets, opts.DiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTargets); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertDiscoveryMeshGlooSoloIo_V1Alpha2_WorkloadsFromCluster(ctx, cluster, discoveryMeshGlooSoloIoV1Alpha2Workloads, opts.DiscoveryMeshGlooSoloIo_V1Alpha2_Workloads); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertDiscoveryMeshGlooSoloIo_V1Alpha2_MeshesFromCluster(ctx, cluster, discoveryMeshGlooSoloIoV1Alpha2Meshes, opts.DiscoveryMeshGlooSoloIo_V1Alpha2_Meshes); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertNetworkingMeshGlooSoloIo_V1Alpha2_TrafficPoliciesFromCluster(ctx, cluster, networkingMeshGlooSoloIoV1Alpha2TrafficPolicies, opts.NetworkingMeshGlooSoloIo_V1Alpha2_TrafficPolicies); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertNetworkingMeshGlooSoloIo_V1Alpha2_AccessPoliciesFromCluster(ctx, cluster, networkingMeshGlooSoloIoV1Alpha2AccessPolicies, opts.NetworkingMeshGlooSoloIo_V1Alpha2_AccessPolicies); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertNetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshesFromCluster(ctx, cluster, networkingMeshGlooSoloIoV1Alpha2VirtualMeshes, opts.NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertNetworkingMeshGlooSoloIo_V1Alpha2_FailoverServicesFromCluster(ctx, cluster, networkingMeshGlooSoloIoV1Alpha2FailoverServices, opts.NetworkingMeshGlooSoloIo_V1Alpha2_FailoverServices); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertNetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeploymentsFromCluster(ctx, cluster, networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments, opts.NetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeployments); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecordsFromCluster(ctx, cluster, observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords, opts.ObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecords); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertV1_SecretsFromCluster(ctx, cluster, v1Secrets, opts.V1_Secrets); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertMulticlusterSoloIo_V1Alpha1_KubernetesClustersFromCluster(ctx, cluster, multiclusterSoloIoV1Alpha1KubernetesClusters, opts.MulticlusterSoloIo_V1Alpha1_KubernetesClusters); err != nil {
			errs = multierror.Append(errs, err)
		}

	}

	outputSnap := NewLocalSnapshot(
		name,

		settingsMeshGlooSoloIoV1Alpha2Settings,
		discoveryMeshGlooSoloIoV1Alpha2TrafficTargets,
		discoveryMeshGlooSoloIoV1Alpha2Workloads,
		discoveryMeshGlooSoloIoV1Alpha2Meshes,
		networkingMeshGlooSoloIoV1Alpha2TrafficPolicies,
		networkingMeshGlooSoloIoV1Alpha2AccessPolicies,
		networkingMeshGlooSoloIoV1Alpha2VirtualMeshes,
		networkingMeshGlooSoloIoV1Alpha2FailoverServices,
		networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments,
		observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords,
		v1Secrets,
		multiclusterSoloIoV1Alpha1KubernetesClusters,
	)

	return outputSnap, errs
}

func (b *multiClusterLocalBuilder) insertSettingsMeshGlooSoloIo_V1Alpha2_SettingsFromCluster(ctx context.Context, cluster string, settingsMeshGlooSoloIoV1Alpha2Settings settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet, opts ResourceLocalBuildOptions) error {
	settingsMeshGlooSoloIoV1Alpha2SettingsClient, err := settings_mesh_gloo_solo_io_v1alpha2.NewMulticlusterSettingsClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "settings.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "Settings",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	settingsMeshGlooSoloIoV1Alpha2SettingsList, err := settingsMeshGlooSoloIoV1Alpha2SettingsClient.ListSettings(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range settingsMeshGlooSoloIoV1Alpha2SettingsList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		settingsMeshGlooSoloIoV1Alpha2Settings.Insert(&item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertDiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTargetsFromCluster(ctx context.Context, cluster string, discoveryMeshGlooSoloIoV1Alpha2TrafficTargets discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet, opts ResourceLocalBuildOptions) error {
	discoveryMeshGlooSoloIoV1Alpha2TrafficTargetClient, err := discovery_mesh_gloo_solo_io_v1alpha2.NewMulticlusterTrafficTargetClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "TrafficTarget",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	discoveryMeshGlooSoloIoV1Alpha2TrafficTargetList, err := discoveryMeshGlooSoloIoV1Alpha2TrafficTargetClient.ListTrafficTarget(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range discoveryMeshGlooSoloIoV1Alpha2TrafficTargetList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		discoveryMeshGlooSoloIoV1Alpha2TrafficTargets.Insert(&item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertDiscoveryMeshGlooSoloIo_V1Alpha2_WorkloadsFromCluster(ctx context.Context, cluster string, discoveryMeshGlooSoloIoV1Alpha2Workloads discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet, opts ResourceLocalBuildOptions) error {
	discoveryMeshGlooSoloIoV1Alpha2WorkloadClient, err := discovery_mesh_gloo_solo_io_v1alpha2.NewMulticlusterWorkloadClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "Workload",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	discoveryMeshGlooSoloIoV1Alpha2WorkloadList, err := discoveryMeshGlooSoloIoV1Alpha2WorkloadClient.ListWorkload(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range discoveryMeshGlooSoloIoV1Alpha2WorkloadList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		discoveryMeshGlooSoloIoV1Alpha2Workloads.Insert(&item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertDiscoveryMeshGlooSoloIo_V1Alpha2_MeshesFromCluster(ctx context.Context, cluster string, discoveryMeshGlooSoloIoV1Alpha2Meshes discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet, opts ResourceLocalBuildOptions) error {
	discoveryMeshGlooSoloIoV1Alpha2MeshClient, err := discovery_mesh_gloo_solo_io_v1alpha2.NewMulticlusterMeshClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "Mesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	discoveryMeshGlooSoloIoV1Alpha2MeshList, err := discoveryMeshGlooSoloIoV1Alpha2MeshClient.ListMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range discoveryMeshGlooSoloIoV1Alpha2MeshList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		discoveryMeshGlooSoloIoV1Alpha2Meshes.Insert(&item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertNetworkingMeshGlooSoloIo_V1Alpha2_TrafficPoliciesFromCluster(ctx context.Context, cluster string, networkingMeshGlooSoloIoV1Alpha2TrafficPolicies networking_mesh_gloo_solo_io_v1alpha2_sets.TrafficPolicySet, opts ResourceLocalBuildOptions) error {
	networkingMeshGlooSoloIoV1Alpha2TrafficPolicyClient, err := networking_mesh_gloo_solo_io_v1alpha2.NewMulticlusterTrafficPolicyClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "TrafficPolicy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingMeshGlooSoloIoV1Alpha2TrafficPolicyList, err := networkingMeshGlooSoloIoV1Alpha2TrafficPolicyClient.ListTrafficPolicy(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingMeshGlooSoloIoV1Alpha2TrafficPolicyList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		networkingMeshGlooSoloIoV1Alpha2TrafficPolicies.Insert(&item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertNetworkingMeshGlooSoloIo_V1Alpha2_AccessPoliciesFromCluster(ctx context.Context, cluster string, networkingMeshGlooSoloIoV1Alpha2AccessPolicies networking_mesh_gloo_solo_io_v1alpha2_sets.AccessPolicySet, opts ResourceLocalBuildOptions) error {
	networkingMeshGlooSoloIoV1Alpha2AccessPolicyClient, err := networking_mesh_gloo_solo_io_v1alpha2.NewMulticlusterAccessPolicyClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "AccessPolicy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingMeshGlooSoloIoV1Alpha2AccessPolicyList, err := networkingMeshGlooSoloIoV1Alpha2AccessPolicyClient.ListAccessPolicy(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingMeshGlooSoloIoV1Alpha2AccessPolicyList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		networkingMeshGlooSoloIoV1Alpha2AccessPolicies.Insert(&item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertNetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshesFromCluster(ctx context.Context, cluster string, networkingMeshGlooSoloIoV1Alpha2VirtualMeshes networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet, opts ResourceLocalBuildOptions) error {
	networkingMeshGlooSoloIoV1Alpha2VirtualMeshClient, err := networking_mesh_gloo_solo_io_v1alpha2.NewMulticlusterVirtualMeshClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "VirtualMesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingMeshGlooSoloIoV1Alpha2VirtualMeshList, err := networkingMeshGlooSoloIoV1Alpha2VirtualMeshClient.ListVirtualMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingMeshGlooSoloIoV1Alpha2VirtualMeshList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		networkingMeshGlooSoloIoV1Alpha2VirtualMeshes.Insert(&item)
	}

	return nil
}
func (b *multiClusterLocalBuilder) insertNetworkingMeshGlooSoloIo_V1Alpha2_FailoverServicesFromCluster(ctx context.Context, cluster string, networkingMeshGlooSoloIoV1Alpha2FailoverServices networking_mesh_gloo_solo_io_v1alpha2_sets.FailoverServiceSet, opts ResourceLocalBuildOptions) error {
	networkingMeshGlooSoloIoV1Alpha2FailoverServiceClient, err := networking_mesh_gloo_solo_io_v1alpha2.NewMulticlusterFailoverServiceClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "FailoverService",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingMeshGlooSoloIoV1Alpha2FailoverServiceList, err := networkingMeshGlooSoloIoV1Alpha2FailoverServiceClient.ListFailoverService(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingMeshGlooSoloIoV1Alpha2FailoverServiceList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		networkingMeshGlooSoloIoV1Alpha2FailoverServices.Insert(&item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertNetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeploymentsFromCluster(ctx context.Context, cluster string, networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets.WasmDeploymentSet, opts ResourceLocalBuildOptions) error {
	networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeploymentClient, err := networking_enterprise_mesh_gloo_solo_io_v1alpha1.NewMulticlusterWasmDeploymentClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1alpha1",
			Kind:    "WasmDeployment",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeploymentList, err := networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeploymentClient.ListWasmDeployment(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeploymentList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments.Insert(&item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecordsFromCluster(ctx context.Context, cluster string, observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets.AccessLogRecordSet, opts ResourceLocalBuildOptions) error {
	observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecordClient, err := observability_enterprise_mesh_gloo_solo_io_v1alpha1.NewMulticlusterAccessLogRecordClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "observability.enterprise.mesh.gloo.solo.io",
			Version: "v1alpha1",
			Kind:    "AccessLogRecord",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecordList, err := observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecordClient.ListAccessLogRecord(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecordList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords.Insert(&item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertV1_SecretsFromCluster(ctx context.Context, cluster string, v1Secrets v1_sets.SecretSet, opts ResourceLocalBuildOptions) error {
	v1SecretClient, err := v1.NewMulticlusterSecretClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Secret",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	v1SecretList, err := v1SecretClient.ListSecret(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range v1SecretList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		v1Secrets.Insert(&item)
	}

	return nil
}

func (b *multiClusterLocalBuilder) insertMulticlusterSoloIo_V1Alpha1_KubernetesClustersFromCluster(ctx context.Context, cluster string, multiclusterSoloIoV1Alpha1KubernetesClusters multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet, opts ResourceLocalBuildOptions) error {
	multiclusterSoloIoV1Alpha1KubernetesClusterClient, err := multicluster_solo_io_v1alpha1.NewMulticlusterKubernetesClusterClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "multicluster.solo.io",
			Version: "v1alpha1",
			Kind:    "KubernetesCluster",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	multiclusterSoloIoV1Alpha1KubernetesClusterList, err := multiclusterSoloIoV1Alpha1KubernetesClusterClient.ListKubernetesCluster(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range multiclusterSoloIoV1Alpha1KubernetesClusterList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		multiclusterSoloIoV1Alpha1KubernetesClusters.Insert(&item)
	}

	return nil
}

// build a snapshot from resources in a single cluster
type singleClusterLocalBuilder struct {
	mgr         manager.Manager
	clusterName string
}

// Produces snapshots of resources read from the manager for the given cluster
func NewSingleClusterLocalBuilder(
	mgr manager.Manager,
) LocalBuilder {
	return NewSingleClusterLocalBuilderWithClusterName(mgr, "")
}

// Produces snapshots of resources read from the manager for the given cluster.
// Snapshot resources will be marked with the given ClusterName.
func NewSingleClusterLocalBuilderWithClusterName(
	mgr manager.Manager,
	clusterName string,
) LocalBuilder {
	return &singleClusterLocalBuilder{
		mgr:         mgr,
		clusterName: clusterName,
	}
}

func (b *singleClusterLocalBuilder) BuildSnapshot(ctx context.Context, name string, opts LocalBuildOptions) (LocalSnapshot, error) {

	settingsMeshGlooSoloIoV1Alpha2Settings := settings_mesh_gloo_solo_io_v1alpha2_sets.NewSettingsSet()

	discoveryMeshGlooSoloIoV1Alpha2TrafficTargets := discovery_mesh_gloo_solo_io_v1alpha2_sets.NewTrafficTargetSet()
	discoveryMeshGlooSoloIoV1Alpha2Workloads := discovery_mesh_gloo_solo_io_v1alpha2_sets.NewWorkloadSet()
	discoveryMeshGlooSoloIoV1Alpha2Meshes := discovery_mesh_gloo_solo_io_v1alpha2_sets.NewMeshSet()

	networkingMeshGlooSoloIoV1Alpha2TrafficPolicies := networking_mesh_gloo_solo_io_v1alpha2_sets.NewTrafficPolicySet()
	networkingMeshGlooSoloIoV1Alpha2AccessPolicies := networking_mesh_gloo_solo_io_v1alpha2_sets.NewAccessPolicySet()
	networkingMeshGlooSoloIoV1Alpha2VirtualMeshes := networking_mesh_gloo_solo_io_v1alpha2_sets.NewVirtualMeshSet()
	networkingMeshGlooSoloIoV1Alpha2FailoverServices := networking_mesh_gloo_solo_io_v1alpha2_sets.NewFailoverServiceSet()

	networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments := networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets.NewWasmDeploymentSet()

	observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords := observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets.NewAccessLogRecordSet()

	v1Secrets := v1_sets.NewSecretSet()

	multiclusterSoloIoV1Alpha1KubernetesClusters := multicluster_solo_io_v1alpha1_sets.NewKubernetesClusterSet()

	var errs error

	if err := b.insertSettingsMeshGlooSoloIo_V1Alpha2_Settings(ctx, settingsMeshGlooSoloIoV1Alpha2Settings, opts.SettingsMeshGlooSoloIo_V1Alpha2_Settings); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertDiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTargets(ctx, discoveryMeshGlooSoloIoV1Alpha2TrafficTargets, opts.DiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTargets); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertDiscoveryMeshGlooSoloIo_V1Alpha2_Workloads(ctx, discoveryMeshGlooSoloIoV1Alpha2Workloads, opts.DiscoveryMeshGlooSoloIo_V1Alpha2_Workloads); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertDiscoveryMeshGlooSoloIo_V1Alpha2_Meshes(ctx, discoveryMeshGlooSoloIoV1Alpha2Meshes, opts.DiscoveryMeshGlooSoloIo_V1Alpha2_Meshes); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertNetworkingMeshGlooSoloIo_V1Alpha2_TrafficPolicies(ctx, networkingMeshGlooSoloIoV1Alpha2TrafficPolicies, opts.NetworkingMeshGlooSoloIo_V1Alpha2_TrafficPolicies); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertNetworkingMeshGlooSoloIo_V1Alpha2_AccessPolicies(ctx, networkingMeshGlooSoloIoV1Alpha2AccessPolicies, opts.NetworkingMeshGlooSoloIo_V1Alpha2_AccessPolicies); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertNetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes(ctx, networkingMeshGlooSoloIoV1Alpha2VirtualMeshes, opts.NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertNetworkingMeshGlooSoloIo_V1Alpha2_FailoverServices(ctx, networkingMeshGlooSoloIoV1Alpha2FailoverServices, opts.NetworkingMeshGlooSoloIo_V1Alpha2_FailoverServices); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertNetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeployments(ctx, networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments, opts.NetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeployments); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecords(ctx, observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords, opts.ObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecords); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertV1_Secrets(ctx, v1Secrets, opts.V1_Secrets); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertMulticlusterSoloIo_V1Alpha1_KubernetesClusters(ctx, multiclusterSoloIoV1Alpha1KubernetesClusters, opts.MulticlusterSoloIo_V1Alpha1_KubernetesClusters); err != nil {
		errs = multierror.Append(errs, err)
	}

	outputSnap := NewLocalSnapshot(
		name,

		settingsMeshGlooSoloIoV1Alpha2Settings,
		discoveryMeshGlooSoloIoV1Alpha2TrafficTargets,
		discoveryMeshGlooSoloIoV1Alpha2Workloads,
		discoveryMeshGlooSoloIoV1Alpha2Meshes,
		networkingMeshGlooSoloIoV1Alpha2TrafficPolicies,
		networkingMeshGlooSoloIoV1Alpha2AccessPolicies,
		networkingMeshGlooSoloIoV1Alpha2VirtualMeshes,
		networkingMeshGlooSoloIoV1Alpha2FailoverServices,
		networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments,
		observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords,
		v1Secrets,
		multiclusterSoloIoV1Alpha1KubernetesClusters,
	)

	return outputSnap, errs
}

func (b *singleClusterLocalBuilder) insertSettingsMeshGlooSoloIo_V1Alpha2_Settings(ctx context.Context, settingsMeshGlooSoloIoV1Alpha2Settings settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "settings.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "Settings",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	settingsMeshGlooSoloIoV1Alpha2SettingsList, err := settings_mesh_gloo_solo_io_v1alpha2.NewSettingsClient(b.mgr.GetClient()).ListSettings(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range settingsMeshGlooSoloIoV1Alpha2SettingsList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		settingsMeshGlooSoloIoV1Alpha2Settings.Insert(&item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertDiscoveryMeshGlooSoloIo_V1Alpha2_TrafficTargets(ctx context.Context, discoveryMeshGlooSoloIoV1Alpha2TrafficTargets discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "TrafficTarget",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	discoveryMeshGlooSoloIoV1Alpha2TrafficTargetList, err := discovery_mesh_gloo_solo_io_v1alpha2.NewTrafficTargetClient(b.mgr.GetClient()).ListTrafficTarget(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range discoveryMeshGlooSoloIoV1Alpha2TrafficTargetList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		discoveryMeshGlooSoloIoV1Alpha2TrafficTargets.Insert(&item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertDiscoveryMeshGlooSoloIo_V1Alpha2_Workloads(ctx context.Context, discoveryMeshGlooSoloIoV1Alpha2Workloads discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "Workload",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	discoveryMeshGlooSoloIoV1Alpha2WorkloadList, err := discovery_mesh_gloo_solo_io_v1alpha2.NewWorkloadClient(b.mgr.GetClient()).ListWorkload(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range discoveryMeshGlooSoloIoV1Alpha2WorkloadList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		discoveryMeshGlooSoloIoV1Alpha2Workloads.Insert(&item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertDiscoveryMeshGlooSoloIo_V1Alpha2_Meshes(ctx context.Context, discoveryMeshGlooSoloIoV1Alpha2Meshes discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "discovery.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "Mesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	discoveryMeshGlooSoloIoV1Alpha2MeshList, err := discovery_mesh_gloo_solo_io_v1alpha2.NewMeshClient(b.mgr.GetClient()).ListMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range discoveryMeshGlooSoloIoV1Alpha2MeshList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		discoveryMeshGlooSoloIoV1Alpha2Meshes.Insert(&item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertNetworkingMeshGlooSoloIo_V1Alpha2_TrafficPolicies(ctx context.Context, networkingMeshGlooSoloIoV1Alpha2TrafficPolicies networking_mesh_gloo_solo_io_v1alpha2_sets.TrafficPolicySet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "TrafficPolicy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingMeshGlooSoloIoV1Alpha2TrafficPolicyList, err := networking_mesh_gloo_solo_io_v1alpha2.NewTrafficPolicyClient(b.mgr.GetClient()).ListTrafficPolicy(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingMeshGlooSoloIoV1Alpha2TrafficPolicyList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		networkingMeshGlooSoloIoV1Alpha2TrafficPolicies.Insert(&item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertNetworkingMeshGlooSoloIo_V1Alpha2_AccessPolicies(ctx context.Context, networkingMeshGlooSoloIoV1Alpha2AccessPolicies networking_mesh_gloo_solo_io_v1alpha2_sets.AccessPolicySet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "AccessPolicy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingMeshGlooSoloIoV1Alpha2AccessPolicyList, err := networking_mesh_gloo_solo_io_v1alpha2.NewAccessPolicyClient(b.mgr.GetClient()).ListAccessPolicy(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingMeshGlooSoloIoV1Alpha2AccessPolicyList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		networkingMeshGlooSoloIoV1Alpha2AccessPolicies.Insert(&item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertNetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes(ctx context.Context, networkingMeshGlooSoloIoV1Alpha2VirtualMeshes networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "VirtualMesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingMeshGlooSoloIoV1Alpha2VirtualMeshList, err := networking_mesh_gloo_solo_io_v1alpha2.NewVirtualMeshClient(b.mgr.GetClient()).ListVirtualMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingMeshGlooSoloIoV1Alpha2VirtualMeshList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		networkingMeshGlooSoloIoV1Alpha2VirtualMeshes.Insert(&item)
	}

	return nil
}
func (b *singleClusterLocalBuilder) insertNetworkingMeshGlooSoloIo_V1Alpha2_FailoverServices(ctx context.Context, networkingMeshGlooSoloIoV1Alpha2FailoverServices networking_mesh_gloo_solo_io_v1alpha2_sets.FailoverServiceSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "FailoverService",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingMeshGlooSoloIoV1Alpha2FailoverServiceList, err := networking_mesh_gloo_solo_io_v1alpha2.NewFailoverServiceClient(b.mgr.GetClient()).ListFailoverService(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingMeshGlooSoloIoV1Alpha2FailoverServiceList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		networkingMeshGlooSoloIoV1Alpha2FailoverServices.Insert(&item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertNetworkingEnterpriseMeshGlooSoloIo_V1Alpha1_WasmDeployments(ctx context.Context, networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments networking_enterprise_mesh_gloo_solo_io_v1alpha1_sets.WasmDeploymentSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.enterprise.mesh.gloo.solo.io",
			Version: "v1alpha1",
			Kind:    "WasmDeployment",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeploymentList, err := networking_enterprise_mesh_gloo_solo_io_v1alpha1.NewWasmDeploymentClient(b.mgr.GetClient()).ListWasmDeployment(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeploymentList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		networkingEnterpriseMeshGlooSoloIoV1Alpha1WasmDeployments.Insert(&item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertObservabilityEnterpriseMeshGlooSoloIo_V1Alpha1_AccessLogRecords(ctx context.Context, observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords observability_enterprise_mesh_gloo_solo_io_v1alpha1_sets.AccessLogRecordSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "observability.enterprise.mesh.gloo.solo.io",
			Version: "v1alpha1",
			Kind:    "AccessLogRecord",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecordList, err := observability_enterprise_mesh_gloo_solo_io_v1alpha1.NewAccessLogRecordClient(b.mgr.GetClient()).ListAccessLogRecord(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecordList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		observabilityEnterpriseMeshGlooSoloIoV1Alpha1AccessLogRecords.Insert(&item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertV1_Secrets(ctx context.Context, v1Secrets v1_sets.SecretSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Secret",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	v1SecretList, err := v1.NewSecretClient(b.mgr.GetClient()).ListSecret(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range v1SecretList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		v1Secrets.Insert(&item)
	}

	return nil
}

func (b *singleClusterLocalBuilder) insertMulticlusterSoloIo_V1Alpha1_KubernetesClusters(ctx context.Context, multiclusterSoloIoV1Alpha1KubernetesClusters multicluster_solo_io_v1alpha1_sets.KubernetesClusterSet, opts ResourceLocalBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "multicluster.solo.io",
			Version: "v1alpha1",
			Kind:    "KubernetesCluster",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	multiclusterSoloIoV1Alpha1KubernetesClusterList, err := multicluster_solo_io_v1alpha1.NewKubernetesClusterClient(b.mgr.GetClient()).ListKubernetesCluster(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range multiclusterSoloIoV1Alpha1KubernetesClusterList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		multiclusterSoloIoV1Alpha1KubernetesClusters.Insert(&item)
	}

	return nil
}
