// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./remote_snapshot.go -destination mocks/remote_snapshot.go

// The Input RemoteSnapshot contains the set of all:
// * CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates
// * CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives
// * XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs
// * NetworkingIstioIo_V1Alpha3_DestinationRules
// * NetworkingIstioIo_V1Alpha3_EnvoyFilters
// * NetworkingIstioIo_V1Alpha3_Gateways
// * NetworkingIstioIo_V1Alpha3_ServiceEntries
// * NetworkingIstioIo_V1Alpha3_VirtualServices
// * SecurityIstioIo_V1Beta1_AuthorizationPolicies
// * V1_ConfigMaps
// read from a given cluster or set of clusters, across all namespaces.
//
// A snapshot can be constructed from either a single Manager (for a single cluster)
// or a ClusterWatcher (for multiple clusters) using the RemoteSnapshotBuilder.
//
// Resources in a MultiCluster snapshot will have their ClusterName set to the
// name of the cluster from which the resource was read.

package input

import (
	"context"
	"encoding/json"

	"github.com/solo-io/skv2/pkg/verifier"
	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/hashicorp/go-multierror"

	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/manager"

	certificates_mesh_gloo_solo_io_v1alpha2 "github.com/solo-io/gloo-mesh/pkg/api/certificates.mesh.gloo.solo.io/v1alpha2"
	certificates_mesh_gloo_solo_io_v1alpha2_sets "github.com/solo-io/gloo-mesh/pkg/api/certificates.mesh.gloo.solo.io/v1alpha2/sets"

	xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1 "github.com/solo-io/gloo-mesh/pkg/api/xds.agent.enterprise.mesh.gloo.solo.io/v1alpha1"
	xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets "github.com/solo-io/gloo-mesh/pkg/api/xds.agent.enterprise.mesh.gloo.solo.io/v1alpha1/sets"

	networking_istio_io_v1alpha3 "github.com/solo-io/external-apis/pkg/api/istio/networking.istio.io/v1alpha3"
	networking_istio_io_v1alpha3_sets "github.com/solo-io/external-apis/pkg/api/istio/networking.istio.io/v1alpha3/sets"

	security_istio_io_v1beta1 "github.com/solo-io/external-apis/pkg/api/istio/security.istio.io/v1beta1"
	security_istio_io_v1beta1_sets "github.com/solo-io/external-apis/pkg/api/istio/security.istio.io/v1beta1/sets"

	v1 "github.com/solo-io/external-apis/pkg/api/k8s/core/v1"
	v1_sets "github.com/solo-io/external-apis/pkg/api/k8s/core/v1/sets"
)

// the snapshot of input resources consumed by translation
type RemoteSnapshot interface {

	// return the set of input CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates
	CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates() certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet
	// return the set of input CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives
	CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives() certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet

	// return the set of input XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs
	XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs() xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet

	// return the set of input NetworkingIstioIo_V1Alpha3_DestinationRules
	NetworkingIstioIo_V1Alpha3_DestinationRules() networking_istio_io_v1alpha3_sets.DestinationRuleSet
	// return the set of input NetworkingIstioIo_V1Alpha3_EnvoyFilters
	NetworkingIstioIo_V1Alpha3_EnvoyFilters() networking_istio_io_v1alpha3_sets.EnvoyFilterSet
	// return the set of input NetworkingIstioIo_V1Alpha3_Gateways
	NetworkingIstioIo_V1Alpha3_Gateways() networking_istio_io_v1alpha3_sets.GatewaySet
	// return the set of input NetworkingIstioIo_V1Alpha3_ServiceEntries
	NetworkingIstioIo_V1Alpha3_ServiceEntries() networking_istio_io_v1alpha3_sets.ServiceEntrySet
	// return the set of input NetworkingIstioIo_V1Alpha3_VirtualServices
	NetworkingIstioIo_V1Alpha3_VirtualServices() networking_istio_io_v1alpha3_sets.VirtualServiceSet

	// return the set of input SecurityIstioIo_V1Beta1_AuthorizationPolicies
	SecurityIstioIo_V1Beta1_AuthorizationPolicies() security_istio_io_v1beta1_sets.AuthorizationPolicySet

	// return the set of input V1_ConfigMaps
	V1_ConfigMaps() v1_sets.ConfigMapSet
	// update the status of all input objects which support
	// the Status subresource (across multiple clusters)
	SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client, opts RemoteSyncStatusOptions) error
	// update the status of all input objects which support
	// the Status subresource (in the local cluster)
	SyncStatuses(ctx context.Context, c client.Client, opts RemoteSyncStatusOptions) error
	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)
}

// options for syncing input object statuses
type RemoteSyncStatusOptions struct {

	// sync status of CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificate objects
	CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificate bool
	// sync status of CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirective objects
	CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirective bool

	// sync status of XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfig objects
	XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfig bool

	// sync status of NetworkingIstioIo_V1Alpha3_DestinationRule objects
	NetworkingIstioIo_V1Alpha3_DestinationRule bool
	// sync status of NetworkingIstioIo_V1Alpha3_EnvoyFilter objects
	NetworkingIstioIo_V1Alpha3_EnvoyFilter bool
	// sync status of NetworkingIstioIo_V1Alpha3_Gateway objects
	NetworkingIstioIo_V1Alpha3_Gateway bool
	// sync status of NetworkingIstioIo_V1Alpha3_ServiceEntry objects
	NetworkingIstioIo_V1Alpha3_ServiceEntry bool
	// sync status of NetworkingIstioIo_V1Alpha3_VirtualService objects
	NetworkingIstioIo_V1Alpha3_VirtualService bool

	// sync status of SecurityIstioIo_V1Beta1_AuthorizationPolicy objects
	SecurityIstioIo_V1Beta1_AuthorizationPolicy bool

	// sync status of V1_ConfigMap objects
	V1_ConfigMap bool
}

type snapshotRemote struct {
	name string

	certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates  certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet
	certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet

	xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet

	networkingIstioIoV1Alpha3DestinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet
	networkingIstioIoV1Alpha3EnvoyFilters     networking_istio_io_v1alpha3_sets.EnvoyFilterSet
	networkingIstioIoV1Alpha3Gateways         networking_istio_io_v1alpha3_sets.GatewaySet
	networkingIstioIoV1Alpha3ServiceEntries   networking_istio_io_v1alpha3_sets.ServiceEntrySet
	networkingIstioIoV1Alpha3VirtualServices  networking_istio_io_v1alpha3_sets.VirtualServiceSet

	securityIstioIoV1Beta1AuthorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet

	v1ConfigMaps v1_sets.ConfigMapSet
}

func NewRemoteSnapshot(
	name string,

	certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet,
	certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet,

	xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet,

	networkingIstioIoV1Alpha3DestinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet,
	networkingIstioIoV1Alpha3EnvoyFilters networking_istio_io_v1alpha3_sets.EnvoyFilterSet,
	networkingIstioIoV1Alpha3Gateways networking_istio_io_v1alpha3_sets.GatewaySet,
	networkingIstioIoV1Alpha3ServiceEntries networking_istio_io_v1alpha3_sets.ServiceEntrySet,
	networkingIstioIoV1Alpha3VirtualServices networking_istio_io_v1alpha3_sets.VirtualServiceSet,

	securityIstioIoV1Beta1AuthorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet,

	v1ConfigMaps v1_sets.ConfigMapSet,

) RemoteSnapshot {
	return &snapshotRemote{
		name: name,

		certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates:  certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates,
		certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives: certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives,
		xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs:    xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs,
		networkingIstioIoV1Alpha3DestinationRules:             networkingIstioIoV1Alpha3DestinationRules,
		networkingIstioIoV1Alpha3EnvoyFilters:                 networkingIstioIoV1Alpha3EnvoyFilters,
		networkingIstioIoV1Alpha3Gateways:                     networkingIstioIoV1Alpha3Gateways,
		networkingIstioIoV1Alpha3ServiceEntries:               networkingIstioIoV1Alpha3ServiceEntries,
		networkingIstioIoV1Alpha3VirtualServices:              networkingIstioIoV1Alpha3VirtualServices,
		securityIstioIoV1Beta1AuthorizationPolicies:           securityIstioIoV1Beta1AuthorizationPolicies,
		v1ConfigMaps: v1ConfigMaps,
	}
}

func (s snapshotRemote) CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates() certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet {
	return s.certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates
}

func (s snapshotRemote) CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives() certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet {
	return s.certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives
}

func (s snapshotRemote) XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs() xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet {
	return s.xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs
}

func (s snapshotRemote) NetworkingIstioIo_V1Alpha3_DestinationRules() networking_istio_io_v1alpha3_sets.DestinationRuleSet {
	return s.networkingIstioIoV1Alpha3DestinationRules
}

func (s snapshotRemote) NetworkingIstioIo_V1Alpha3_EnvoyFilters() networking_istio_io_v1alpha3_sets.EnvoyFilterSet {
	return s.networkingIstioIoV1Alpha3EnvoyFilters
}

func (s snapshotRemote) NetworkingIstioIo_V1Alpha3_Gateways() networking_istio_io_v1alpha3_sets.GatewaySet {
	return s.networkingIstioIoV1Alpha3Gateways
}

func (s snapshotRemote) NetworkingIstioIo_V1Alpha3_ServiceEntries() networking_istio_io_v1alpha3_sets.ServiceEntrySet {
	return s.networkingIstioIoV1Alpha3ServiceEntries
}

func (s snapshotRemote) NetworkingIstioIo_V1Alpha3_VirtualServices() networking_istio_io_v1alpha3_sets.VirtualServiceSet {
	return s.networkingIstioIoV1Alpha3VirtualServices
}

func (s snapshotRemote) SecurityIstioIo_V1Beta1_AuthorizationPolicies() security_istio_io_v1beta1_sets.AuthorizationPolicySet {
	return s.securityIstioIoV1Beta1AuthorizationPolicies
}

func (s snapshotRemote) V1_ConfigMaps() v1_sets.ConfigMapSet {
	return s.v1ConfigMaps
}

func (s snapshotRemote) SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client, opts RemoteSyncStatusOptions) error {
	var errs error

	if opts.CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificate {
		for _, obj := range s.CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirective {
		for _, obj := range s.CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfig {
		for _, obj := range s.XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	return errs
}

func (s snapshotRemote) SyncStatuses(ctx context.Context, c client.Client, opts RemoteSyncStatusOptions) error {
	var errs error

	if opts.CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificate {
		for _, obj := range s.CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	if opts.CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirective {
		for _, obj := range s.CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfig {
		for _, obj := range s.XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	return errs
}

func (s snapshotRemote) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	snapshotMap["certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates"] = s.certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates.List()
	snapshotMap["certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives"] = s.certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives.List()
	snapshotMap["xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs"] = s.xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs.List()
	snapshotMap["networkingIstioIoV1Alpha3DestinationRules"] = s.networkingIstioIoV1Alpha3DestinationRules.List()
	snapshotMap["networkingIstioIoV1Alpha3EnvoyFilters"] = s.networkingIstioIoV1Alpha3EnvoyFilters.List()
	snapshotMap["networkingIstioIoV1Alpha3Gateways"] = s.networkingIstioIoV1Alpha3Gateways.List()
	snapshotMap["networkingIstioIoV1Alpha3ServiceEntries"] = s.networkingIstioIoV1Alpha3ServiceEntries.List()
	snapshotMap["networkingIstioIoV1Alpha3VirtualServices"] = s.networkingIstioIoV1Alpha3VirtualServices.List()
	snapshotMap["securityIstioIoV1Beta1AuthorizationPolicies"] = s.securityIstioIoV1Beta1AuthorizationPolicies.List()
	snapshotMap["v1ConfigMaps"] = s.v1ConfigMaps.List()
	return json.Marshal(snapshotMap)
}

// builds the input snapshot from API Clients.
type RemoteBuilder interface {
	BuildSnapshot(ctx context.Context, name string, opts RemoteBuildOptions) (RemoteSnapshot, error)
}

// Options for building a snapshot
type RemoteBuildOptions struct {

	// List options for composing a snapshot from CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates
	CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates ResourceRemoteBuildOptions
	// List options for composing a snapshot from CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives
	CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives ResourceRemoteBuildOptions

	// List options for composing a snapshot from XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs
	XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs ResourceRemoteBuildOptions

	// List options for composing a snapshot from NetworkingIstioIo_V1Alpha3_DestinationRules
	NetworkingIstioIo_V1Alpha3_DestinationRules ResourceRemoteBuildOptions
	// List options for composing a snapshot from NetworkingIstioIo_V1Alpha3_EnvoyFilters
	NetworkingIstioIo_V1Alpha3_EnvoyFilters ResourceRemoteBuildOptions
	// List options for composing a snapshot from NetworkingIstioIo_V1Alpha3_Gateways
	NetworkingIstioIo_V1Alpha3_Gateways ResourceRemoteBuildOptions
	// List options for composing a snapshot from NetworkingIstioIo_V1Alpha3_ServiceEntries
	NetworkingIstioIo_V1Alpha3_ServiceEntries ResourceRemoteBuildOptions
	// List options for composing a snapshot from NetworkingIstioIo_V1Alpha3_VirtualServices
	NetworkingIstioIo_V1Alpha3_VirtualServices ResourceRemoteBuildOptions

	// List options for composing a snapshot from SecurityIstioIo_V1Beta1_AuthorizationPolicies
	SecurityIstioIo_V1Beta1_AuthorizationPolicies ResourceRemoteBuildOptions

	// List options for composing a snapshot from V1_ConfigMaps
	V1_ConfigMaps ResourceRemoteBuildOptions
}

// Options for reading resources of a given type
type ResourceRemoteBuildOptions struct {

	// List options for composing a snapshot from a resource type
	ListOptions []client.ListOption

	// If provided, ensure the resource has been verified before adding it to snapshots
	Verifier verifier.ServerResourceVerifier
}

// build a snapshot from resources across multiple clusters
type multiClusterRemoteBuilder struct {
	clusters multicluster.Interface
	client   multicluster.Client
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewMultiClusterRemoteBuilder(
	clusters multicluster.Interface,
	client multicluster.Client,
) RemoteBuilder {
	return &multiClusterRemoteBuilder{
		clusters: clusters,
		client:   client,
	}
}

func (b *multiClusterRemoteBuilder) BuildSnapshot(ctx context.Context, name string, opts RemoteBuildOptions) (RemoteSnapshot, error) {

	certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates := certificates_mesh_gloo_solo_io_v1alpha2_sets.NewIssuedCertificateSet()
	certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives := certificates_mesh_gloo_solo_io_v1alpha2_sets.NewPodBounceDirectiveSet()

	xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs := xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.NewXdsConfigSet()

	networkingIstioIoV1Alpha3DestinationRules := networking_istio_io_v1alpha3_sets.NewDestinationRuleSet()
	networkingIstioIoV1Alpha3EnvoyFilters := networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet()
	networkingIstioIoV1Alpha3Gateways := networking_istio_io_v1alpha3_sets.NewGatewaySet()
	networkingIstioIoV1Alpha3ServiceEntries := networking_istio_io_v1alpha3_sets.NewServiceEntrySet()
	networkingIstioIoV1Alpha3VirtualServices := networking_istio_io_v1alpha3_sets.NewVirtualServiceSet()

	securityIstioIoV1Beta1AuthorizationPolicies := security_istio_io_v1beta1_sets.NewAuthorizationPolicySet()

	v1ConfigMaps := v1_sets.NewConfigMapSet()

	var errs error

	for _, cluster := range b.clusters.ListClusters() {

		if err := b.insertCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificatesFromCluster(ctx, cluster, certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates, opts.CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectivesFromCluster(ctx, cluster, certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives, opts.CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigsFromCluster(ctx, cluster, xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs, opts.XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertNetworkingIstioIo_V1Alpha3_DestinationRulesFromCluster(ctx, cluster, networkingIstioIoV1Alpha3DestinationRules, opts.NetworkingIstioIo_V1Alpha3_DestinationRules); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertNetworkingIstioIo_V1Alpha3_EnvoyFiltersFromCluster(ctx, cluster, networkingIstioIoV1Alpha3EnvoyFilters, opts.NetworkingIstioIo_V1Alpha3_EnvoyFilters); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertNetworkingIstioIo_V1Alpha3_GatewaysFromCluster(ctx, cluster, networkingIstioIoV1Alpha3Gateways, opts.NetworkingIstioIo_V1Alpha3_Gateways); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertNetworkingIstioIo_V1Alpha3_ServiceEntriesFromCluster(ctx, cluster, networkingIstioIoV1Alpha3ServiceEntries, opts.NetworkingIstioIo_V1Alpha3_ServiceEntries); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertNetworkingIstioIo_V1Alpha3_VirtualServicesFromCluster(ctx, cluster, networkingIstioIoV1Alpha3VirtualServices, opts.NetworkingIstioIo_V1Alpha3_VirtualServices); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertSecurityIstioIo_V1Beta1_AuthorizationPoliciesFromCluster(ctx, cluster, securityIstioIoV1Beta1AuthorizationPolicies, opts.SecurityIstioIo_V1Beta1_AuthorizationPolicies); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertV1_ConfigMapsFromCluster(ctx, cluster, v1ConfigMaps, opts.V1_ConfigMaps); err != nil {
			errs = multierror.Append(errs, err)
		}

	}

	outputSnap := NewRemoteSnapshot(
		name,

		certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates,
		certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives,
		xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs,
		networkingIstioIoV1Alpha3DestinationRules,
		networkingIstioIoV1Alpha3EnvoyFilters,
		networkingIstioIoV1Alpha3Gateways,
		networkingIstioIoV1Alpha3ServiceEntries,
		networkingIstioIoV1Alpha3VirtualServices,
		securityIstioIoV1Beta1AuthorizationPolicies,
		v1ConfigMaps,
	)

	return outputSnap, errs
}

func (b *multiClusterRemoteBuilder) insertCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificatesFromCluster(ctx context.Context, cluster string, certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet, opts ResourceRemoteBuildOptions) error {
	certificatesMeshGlooSoloIoV1Alpha2IssuedCertificateClient, err := certificates_mesh_gloo_solo_io_v1alpha2.NewMulticlusterIssuedCertificateClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "IssuedCertificate",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	certificatesMeshGlooSoloIoV1Alpha2IssuedCertificateList, err := certificatesMeshGlooSoloIoV1Alpha2IssuedCertificateClient.ListIssuedCertificate(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range certificatesMeshGlooSoloIoV1Alpha2IssuedCertificateList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates.Insert(&item)
	}

	return nil
}
func (b *multiClusterRemoteBuilder) insertCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectivesFromCluster(ctx context.Context, cluster string, certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet, opts ResourceRemoteBuildOptions) error {
	certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectiveClient, err := certificates_mesh_gloo_solo_io_v1alpha2.NewMulticlusterPodBounceDirectiveClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "PodBounceDirective",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectiveList, err := certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectiveClient.ListPodBounceDirective(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectiveList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives.Insert(&item)
	}

	return nil
}

func (b *multiClusterRemoteBuilder) insertXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigsFromCluster(ctx context.Context, cluster string, xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet, opts ResourceRemoteBuildOptions) error {
	xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigClient, err := xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1.NewMulticlusterXdsConfigClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "xds.agent.enterprise.mesh.gloo.solo.io",
			Version: "v1alpha1",
			Kind:    "XdsConfig",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigList, err := xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigClient.ListXdsConfig(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs.Insert(&item)
	}

	return nil
}

func (b *multiClusterRemoteBuilder) insertNetworkingIstioIo_V1Alpha3_DestinationRulesFromCluster(ctx context.Context, cluster string, networkingIstioIoV1Alpha3DestinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet, opts ResourceRemoteBuildOptions) error {
	networkingIstioIoV1Alpha3DestinationRuleClient, err := networking_istio_io_v1alpha3.NewMulticlusterDestinationRuleClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "DestinationRule",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingIstioIoV1Alpha3DestinationRuleList, err := networkingIstioIoV1Alpha3DestinationRuleClient.ListDestinationRule(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingIstioIoV1Alpha3DestinationRuleList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		networkingIstioIoV1Alpha3DestinationRules.Insert(&item)
	}

	return nil
}
func (b *multiClusterRemoteBuilder) insertNetworkingIstioIo_V1Alpha3_EnvoyFiltersFromCluster(ctx context.Context, cluster string, networkingIstioIoV1Alpha3EnvoyFilters networking_istio_io_v1alpha3_sets.EnvoyFilterSet, opts ResourceRemoteBuildOptions) error {
	networkingIstioIoV1Alpha3EnvoyFilterClient, err := networking_istio_io_v1alpha3.NewMulticlusterEnvoyFilterClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "EnvoyFilter",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingIstioIoV1Alpha3EnvoyFilterList, err := networkingIstioIoV1Alpha3EnvoyFilterClient.ListEnvoyFilter(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingIstioIoV1Alpha3EnvoyFilterList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		networkingIstioIoV1Alpha3EnvoyFilters.Insert(&item)
	}

	return nil
}
func (b *multiClusterRemoteBuilder) insertNetworkingIstioIo_V1Alpha3_GatewaysFromCluster(ctx context.Context, cluster string, networkingIstioIoV1Alpha3Gateways networking_istio_io_v1alpha3_sets.GatewaySet, opts ResourceRemoteBuildOptions) error {
	networkingIstioIoV1Alpha3GatewayClient, err := networking_istio_io_v1alpha3.NewMulticlusterGatewayClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "Gateway",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingIstioIoV1Alpha3GatewayList, err := networkingIstioIoV1Alpha3GatewayClient.ListGateway(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingIstioIoV1Alpha3GatewayList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		networkingIstioIoV1Alpha3Gateways.Insert(&item)
	}

	return nil
}
func (b *multiClusterRemoteBuilder) insertNetworkingIstioIo_V1Alpha3_ServiceEntriesFromCluster(ctx context.Context, cluster string, networkingIstioIoV1Alpha3ServiceEntries networking_istio_io_v1alpha3_sets.ServiceEntrySet, opts ResourceRemoteBuildOptions) error {
	networkingIstioIoV1Alpha3ServiceEntryClient, err := networking_istio_io_v1alpha3.NewMulticlusterServiceEntryClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "ServiceEntry",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingIstioIoV1Alpha3ServiceEntryList, err := networkingIstioIoV1Alpha3ServiceEntryClient.ListServiceEntry(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingIstioIoV1Alpha3ServiceEntryList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		networkingIstioIoV1Alpha3ServiceEntries.Insert(&item)
	}

	return nil
}
func (b *multiClusterRemoteBuilder) insertNetworkingIstioIo_V1Alpha3_VirtualServicesFromCluster(ctx context.Context, cluster string, networkingIstioIoV1Alpha3VirtualServices networking_istio_io_v1alpha3_sets.VirtualServiceSet, opts ResourceRemoteBuildOptions) error {
	networkingIstioIoV1Alpha3VirtualServiceClient, err := networking_istio_io_v1alpha3.NewMulticlusterVirtualServiceClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "VirtualService",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingIstioIoV1Alpha3VirtualServiceList, err := networkingIstioIoV1Alpha3VirtualServiceClient.ListVirtualService(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingIstioIoV1Alpha3VirtualServiceList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		networkingIstioIoV1Alpha3VirtualServices.Insert(&item)
	}

	return nil
}

func (b *multiClusterRemoteBuilder) insertSecurityIstioIo_V1Beta1_AuthorizationPoliciesFromCluster(ctx context.Context, cluster string, securityIstioIoV1Beta1AuthorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet, opts ResourceRemoteBuildOptions) error {
	securityIstioIoV1Beta1AuthorizationPolicyClient, err := security_istio_io_v1beta1.NewMulticlusterAuthorizationPolicyClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "security.istio.io",
			Version: "v1beta1",
			Kind:    "AuthorizationPolicy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	securityIstioIoV1Beta1AuthorizationPolicyList, err := securityIstioIoV1Beta1AuthorizationPolicyClient.ListAuthorizationPolicy(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range securityIstioIoV1Beta1AuthorizationPolicyList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		securityIstioIoV1Beta1AuthorizationPolicies.Insert(&item)
	}

	return nil
}

func (b *multiClusterRemoteBuilder) insertV1_ConfigMapsFromCluster(ctx context.Context, cluster string, v1ConfigMaps v1_sets.ConfigMapSet, opts ResourceRemoteBuildOptions) error {
	v1ConfigMapClient, err := v1.NewMulticlusterConfigMapClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "ConfigMap",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	v1ConfigMapList, err := v1ConfigMapClient.ListConfigMap(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range v1ConfigMapList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		v1ConfigMaps.Insert(&item)
	}

	return nil
}

// build a snapshot from resources in a single cluster
type singleClusterRemoteBuilder struct {
	mgr         manager.Manager
	clusterName string
}

// Produces snapshots of resources read from the manager for the given cluster
func NewSingleClusterRemoteBuilder(
	mgr manager.Manager,
) RemoteBuilder {
	return NewSingleClusterRemoteBuilderWithClusterName(mgr, "")
}

// Produces snapshots of resources read from the manager for the given cluster.
// Snapshot resources will be marked with the given ClusterName.
func NewSingleClusterRemoteBuilderWithClusterName(
	mgr manager.Manager,
	clusterName string,
) RemoteBuilder {
	return &singleClusterRemoteBuilder{
		mgr:         mgr,
		clusterName: clusterName,
	}
}

func (b *singleClusterRemoteBuilder) BuildSnapshot(ctx context.Context, name string, opts RemoteBuildOptions) (RemoteSnapshot, error) {

	certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates := certificates_mesh_gloo_solo_io_v1alpha2_sets.NewIssuedCertificateSet()
	certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives := certificates_mesh_gloo_solo_io_v1alpha2_sets.NewPodBounceDirectiveSet()

	xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs := xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.NewXdsConfigSet()

	networkingIstioIoV1Alpha3DestinationRules := networking_istio_io_v1alpha3_sets.NewDestinationRuleSet()
	networkingIstioIoV1Alpha3EnvoyFilters := networking_istio_io_v1alpha3_sets.NewEnvoyFilterSet()
	networkingIstioIoV1Alpha3Gateways := networking_istio_io_v1alpha3_sets.NewGatewaySet()
	networkingIstioIoV1Alpha3ServiceEntries := networking_istio_io_v1alpha3_sets.NewServiceEntrySet()
	networkingIstioIoV1Alpha3VirtualServices := networking_istio_io_v1alpha3_sets.NewVirtualServiceSet()

	securityIstioIoV1Beta1AuthorizationPolicies := security_istio_io_v1beta1_sets.NewAuthorizationPolicySet()

	v1ConfigMaps := v1_sets.NewConfigMapSet()

	var errs error

	if err := b.insertCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates(ctx, certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates, opts.CertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives(ctx, certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives, opts.CertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs(ctx, xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs, opts.XdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertNetworkingIstioIo_V1Alpha3_DestinationRules(ctx, networkingIstioIoV1Alpha3DestinationRules, opts.NetworkingIstioIo_V1Alpha3_DestinationRules); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertNetworkingIstioIo_V1Alpha3_EnvoyFilters(ctx, networkingIstioIoV1Alpha3EnvoyFilters, opts.NetworkingIstioIo_V1Alpha3_EnvoyFilters); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertNetworkingIstioIo_V1Alpha3_Gateways(ctx, networkingIstioIoV1Alpha3Gateways, opts.NetworkingIstioIo_V1Alpha3_Gateways); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertNetworkingIstioIo_V1Alpha3_ServiceEntries(ctx, networkingIstioIoV1Alpha3ServiceEntries, opts.NetworkingIstioIo_V1Alpha3_ServiceEntries); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertNetworkingIstioIo_V1Alpha3_VirtualServices(ctx, networkingIstioIoV1Alpha3VirtualServices, opts.NetworkingIstioIo_V1Alpha3_VirtualServices); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertSecurityIstioIo_V1Beta1_AuthorizationPolicies(ctx, securityIstioIoV1Beta1AuthorizationPolicies, opts.SecurityIstioIo_V1Beta1_AuthorizationPolicies); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertV1_ConfigMaps(ctx, v1ConfigMaps, opts.V1_ConfigMaps); err != nil {
		errs = multierror.Append(errs, err)
	}

	outputSnap := NewRemoteSnapshot(
		name,

		certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates,
		certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives,
		xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs,
		networkingIstioIoV1Alpha3DestinationRules,
		networkingIstioIoV1Alpha3EnvoyFilters,
		networkingIstioIoV1Alpha3Gateways,
		networkingIstioIoV1Alpha3ServiceEntries,
		networkingIstioIoV1Alpha3VirtualServices,
		securityIstioIoV1Beta1AuthorizationPolicies,
		v1ConfigMaps,
	)

	return outputSnap, errs
}

func (b *singleClusterRemoteBuilder) insertCertificatesMeshGlooSoloIo_V1Alpha2_IssuedCertificates(ctx context.Context, certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates certificates_mesh_gloo_solo_io_v1alpha2_sets.IssuedCertificateSet, opts ResourceRemoteBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "IssuedCertificate",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	certificatesMeshGlooSoloIoV1Alpha2IssuedCertificateList, err := certificates_mesh_gloo_solo_io_v1alpha2.NewIssuedCertificateClient(b.mgr.GetClient()).ListIssuedCertificate(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range certificatesMeshGlooSoloIoV1Alpha2IssuedCertificateList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		certificatesMeshGlooSoloIoV1Alpha2IssuedCertificates.Insert(&item)
	}

	return nil
}
func (b *singleClusterRemoteBuilder) insertCertificatesMeshGlooSoloIo_V1Alpha2_PodBounceDirectives(ctx context.Context, certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives certificates_mesh_gloo_solo_io_v1alpha2_sets.PodBounceDirectiveSet, opts ResourceRemoteBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "certificates.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "PodBounceDirective",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectiveList, err := certificates_mesh_gloo_solo_io_v1alpha2.NewPodBounceDirectiveClient(b.mgr.GetClient()).ListPodBounceDirective(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectiveList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		certificatesMeshGlooSoloIoV1Alpha2PodBounceDirectives.Insert(&item)
	}

	return nil
}

func (b *singleClusterRemoteBuilder) insertXdsAgentEnterpriseMeshGlooSoloIo_V1Alpha1_XdsConfigs(ctx context.Context, xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1_sets.XdsConfigSet, opts ResourceRemoteBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "xds.agent.enterprise.mesh.gloo.solo.io",
			Version: "v1alpha1",
			Kind:    "XdsConfig",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigList, err := xds_agent_enterprise_mesh_gloo_solo_io_v1alpha1.NewXdsConfigClient(b.mgr.GetClient()).ListXdsConfig(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		xdsAgentEnterpriseMeshGlooSoloIoV1Alpha1XdsConfigs.Insert(&item)
	}

	return nil
}

func (b *singleClusterRemoteBuilder) insertNetworkingIstioIo_V1Alpha3_DestinationRules(ctx context.Context, networkingIstioIoV1Alpha3DestinationRules networking_istio_io_v1alpha3_sets.DestinationRuleSet, opts ResourceRemoteBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "DestinationRule",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingIstioIoV1Alpha3DestinationRuleList, err := networking_istio_io_v1alpha3.NewDestinationRuleClient(b.mgr.GetClient()).ListDestinationRule(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingIstioIoV1Alpha3DestinationRuleList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		networkingIstioIoV1Alpha3DestinationRules.Insert(&item)
	}

	return nil
}
func (b *singleClusterRemoteBuilder) insertNetworkingIstioIo_V1Alpha3_EnvoyFilters(ctx context.Context, networkingIstioIoV1Alpha3EnvoyFilters networking_istio_io_v1alpha3_sets.EnvoyFilterSet, opts ResourceRemoteBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "EnvoyFilter",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingIstioIoV1Alpha3EnvoyFilterList, err := networking_istio_io_v1alpha3.NewEnvoyFilterClient(b.mgr.GetClient()).ListEnvoyFilter(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingIstioIoV1Alpha3EnvoyFilterList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		networkingIstioIoV1Alpha3EnvoyFilters.Insert(&item)
	}

	return nil
}
func (b *singleClusterRemoteBuilder) insertNetworkingIstioIo_V1Alpha3_Gateways(ctx context.Context, networkingIstioIoV1Alpha3Gateways networking_istio_io_v1alpha3_sets.GatewaySet, opts ResourceRemoteBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "Gateway",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingIstioIoV1Alpha3GatewayList, err := networking_istio_io_v1alpha3.NewGatewayClient(b.mgr.GetClient()).ListGateway(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingIstioIoV1Alpha3GatewayList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		networkingIstioIoV1Alpha3Gateways.Insert(&item)
	}

	return nil
}
func (b *singleClusterRemoteBuilder) insertNetworkingIstioIo_V1Alpha3_ServiceEntries(ctx context.Context, networkingIstioIoV1Alpha3ServiceEntries networking_istio_io_v1alpha3_sets.ServiceEntrySet, opts ResourceRemoteBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "ServiceEntry",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingIstioIoV1Alpha3ServiceEntryList, err := networking_istio_io_v1alpha3.NewServiceEntryClient(b.mgr.GetClient()).ListServiceEntry(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingIstioIoV1Alpha3ServiceEntryList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		networkingIstioIoV1Alpha3ServiceEntries.Insert(&item)
	}

	return nil
}
func (b *singleClusterRemoteBuilder) insertNetworkingIstioIo_V1Alpha3_VirtualServices(ctx context.Context, networkingIstioIoV1Alpha3VirtualServices networking_istio_io_v1alpha3_sets.VirtualServiceSet, opts ResourceRemoteBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.istio.io",
			Version: "v1alpha3",
			Kind:    "VirtualService",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingIstioIoV1Alpha3VirtualServiceList, err := networking_istio_io_v1alpha3.NewVirtualServiceClient(b.mgr.GetClient()).ListVirtualService(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingIstioIoV1Alpha3VirtualServiceList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		networkingIstioIoV1Alpha3VirtualServices.Insert(&item)
	}

	return nil
}

func (b *singleClusterRemoteBuilder) insertSecurityIstioIo_V1Beta1_AuthorizationPolicies(ctx context.Context, securityIstioIoV1Beta1AuthorizationPolicies security_istio_io_v1beta1_sets.AuthorizationPolicySet, opts ResourceRemoteBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "security.istio.io",
			Version: "v1beta1",
			Kind:    "AuthorizationPolicy",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	securityIstioIoV1Beta1AuthorizationPolicyList, err := security_istio_io_v1beta1.NewAuthorizationPolicyClient(b.mgr.GetClient()).ListAuthorizationPolicy(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range securityIstioIoV1Beta1AuthorizationPolicyList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		securityIstioIoV1Beta1AuthorizationPolicies.Insert(&item)
	}

	return nil
}

func (b *singleClusterRemoteBuilder) insertV1_ConfigMaps(ctx context.Context, v1ConfigMaps v1_sets.ConfigMapSet, opts ResourceRemoteBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "ConfigMap",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	v1ConfigMapList, err := v1.NewConfigMapClient(b.mgr.GetClient()).ListConfigMap(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range v1ConfigMapList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		v1ConfigMaps.Insert(&item)
	}

	return nil
}
