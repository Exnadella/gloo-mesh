// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./local_snapshot.go -destination mocks/local_snapshot.go

// The Input SettingsSnapshot contains the set of all:
// * SettingsMeshGlooSoloIo_V1Alpha2_Settings
// * NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes
// read from a given cluster or set of clusters, across all namespaces.
//
// A snapshot can be constructed from either a single Manager (for a single cluster)
// or a ClusterWatcher (for multiple clusters) using the SettingsSnapshotBuilder.
//
// Resources in a MultiCluster snapshot will have their ClusterName set to the
// name of the cluster from which the resource was read.

package input

import (
	"context"
	"encoding/json"

	"github.com/solo-io/skv2/pkg/verifier"
	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/hashicorp/go-multierror"

	"github.com/solo-io/skv2/pkg/controllerutils"
	"github.com/solo-io/skv2/pkg/multicluster"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/manager"

	settings_mesh_gloo_solo_io_v1alpha2 "github.com/solo-io/gloo-mesh/pkg/api/settings.mesh.gloo.solo.io/v1alpha2"
	settings_mesh_gloo_solo_io_v1alpha2_sets "github.com/solo-io/gloo-mesh/pkg/api/settings.mesh.gloo.solo.io/v1alpha2/sets"

	networking_mesh_gloo_solo_io_v1alpha2 "github.com/solo-io/gloo-mesh/pkg/api/networking.mesh.gloo.solo.io/v1alpha2"
	networking_mesh_gloo_solo_io_v1alpha2_sets "github.com/solo-io/gloo-mesh/pkg/api/networking.mesh.gloo.solo.io/v1alpha2/sets"
)

// the snapshot of input resources consumed by translation
type SettingsSnapshot interface {

	// return the set of input SettingsMeshGlooSoloIo_V1Alpha2_Settings
	SettingsMeshGlooSoloIo_V1Alpha2_Settings() settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet

	// return the set of input NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes
	NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes() networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet
	// update the status of all input objects which support
	// the Status subresource (across multiple clusters)
	SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client, opts SettingsSyncStatusOptions) error
	// update the status of all input objects which support
	// the Status subresource (in the local cluster)
	SyncStatuses(ctx context.Context, c client.Client, opts SettingsSyncStatusOptions) error
	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)
}

// options for syncing input object statuses
type SettingsSyncStatusOptions struct {

	// sync status of SettingsMeshGlooSoloIo_V1Alpha2_Settings objects
	SettingsMeshGlooSoloIo_V1Alpha2_Settings bool

	// sync status of NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMesh objects
	NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMesh bool
}

type snapshotSettings struct {
	name string

	settingsMeshGlooSoloIoV1Alpha2Settings settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet

	networkingMeshGlooSoloIoV1Alpha2VirtualMeshes networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet
}

func NewSettingsSnapshot(
	name string,

	settingsMeshGlooSoloIoV1Alpha2Settings settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet,

	networkingMeshGlooSoloIoV1Alpha2VirtualMeshes networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet,

) SettingsSnapshot {
	return &snapshotSettings{
		name: name,

		settingsMeshGlooSoloIoV1Alpha2Settings:        settingsMeshGlooSoloIoV1Alpha2Settings,
		networkingMeshGlooSoloIoV1Alpha2VirtualMeshes: networkingMeshGlooSoloIoV1Alpha2VirtualMeshes,
	}
}

func (s snapshotSettings) SettingsMeshGlooSoloIo_V1Alpha2_Settings() settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet {
	return s.settingsMeshGlooSoloIoV1Alpha2Settings
}

func (s snapshotSettings) NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes() networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet {
	return s.networkingMeshGlooSoloIoV1Alpha2VirtualMeshes
}

func (s snapshotSettings) SyncStatusesMultiCluster(ctx context.Context, mcClient multicluster.Client, opts SettingsSyncStatusOptions) error {
	var errs error

	if opts.SettingsMeshGlooSoloIo_V1Alpha2_Settings {
		for _, obj := range s.SettingsMeshGlooSoloIo_V1Alpha2_Settings().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMesh {
		for _, obj := range s.NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes().List() {
			clusterClient, err := mcClient.Cluster(obj.ClusterName)
			if err != nil {
				errs = multierror.Append(errs, err)
				continue
			}
			if _, err := controllerutils.UpdateStatus(ctx, clusterClient, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	return errs
}

func (s snapshotSettings) SyncStatuses(ctx context.Context, c client.Client, opts SettingsSyncStatusOptions) error {
	var errs error

	if opts.SettingsMeshGlooSoloIo_V1Alpha2_Settings {
		for _, obj := range s.SettingsMeshGlooSoloIo_V1Alpha2_Settings().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}

	if opts.NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMesh {
		for _, obj := range s.NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes().List() {
			if _, err := controllerutils.UpdateStatus(ctx, c, obj); err != nil {
				errs = multierror.Append(errs, err)
			}
		}
	}
	return errs
}

func (s snapshotSettings) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	snapshotMap["settingsMeshGlooSoloIoV1Alpha2Settings"] = s.settingsMeshGlooSoloIoV1Alpha2Settings.List()
	snapshotMap["networkingMeshGlooSoloIoV1Alpha2VirtualMeshes"] = s.networkingMeshGlooSoloIoV1Alpha2VirtualMeshes.List()
	return json.Marshal(snapshotMap)
}

// builds the input snapshot from API Clients.
type SettingsBuilder interface {
	BuildSnapshot(ctx context.Context, name string, opts SettingsBuildOptions) (SettingsSnapshot, error)
}

// Options for building a snapshot
type SettingsBuildOptions struct {

	// List options for composing a snapshot from SettingsMeshGlooSoloIo_V1Alpha2_Settings
	SettingsMeshGlooSoloIo_V1Alpha2_Settings ResourceSettingsBuildOptions

	// List options for composing a snapshot from NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes
	NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes ResourceSettingsBuildOptions
}

// Options for reading resources of a given type
type ResourceSettingsBuildOptions struct {

	// List options for composing a snapshot from a resource type
	ListOptions []client.ListOption

	// If provided, ensure the resource has been verified before adding it to snapshots
	Verifier verifier.ServerResourceVerifier
}

// build a snapshot from resources across multiple clusters
type multiClusterSettingsBuilder struct {
	clusters multicluster.Interface
	client   multicluster.Client
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewMultiClusterSettingsBuilder(
	clusters multicluster.Interface,
	client multicluster.Client,
) SettingsBuilder {
	return &multiClusterSettingsBuilder{
		clusters: clusters,
		client:   client,
	}
}

func (b *multiClusterSettingsBuilder) BuildSnapshot(ctx context.Context, name string, opts SettingsBuildOptions) (SettingsSnapshot, error) {

	settingsMeshGlooSoloIoV1Alpha2Settings := settings_mesh_gloo_solo_io_v1alpha2_sets.NewSettingsSet()

	networkingMeshGlooSoloIoV1Alpha2VirtualMeshes := networking_mesh_gloo_solo_io_v1alpha2_sets.NewVirtualMeshSet()

	var errs error

	for _, cluster := range b.clusters.ListClusters() {

		if err := b.insertSettingsMeshGlooSoloIo_V1Alpha2_SettingsFromCluster(ctx, cluster, settingsMeshGlooSoloIoV1Alpha2Settings, opts.SettingsMeshGlooSoloIo_V1Alpha2_Settings); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertNetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshesFromCluster(ctx, cluster, networkingMeshGlooSoloIoV1Alpha2VirtualMeshes, opts.NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes); err != nil {
			errs = multierror.Append(errs, err)
		}

	}

	outputSnap := NewSettingsSnapshot(
		name,

		settingsMeshGlooSoloIoV1Alpha2Settings,
		networkingMeshGlooSoloIoV1Alpha2VirtualMeshes,
	)

	return outputSnap, errs
}

func (b *multiClusterSettingsBuilder) insertSettingsMeshGlooSoloIo_V1Alpha2_SettingsFromCluster(ctx context.Context, cluster string, settingsMeshGlooSoloIoV1Alpha2Settings settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet, opts ResourceSettingsBuildOptions) error {
	settingsMeshGlooSoloIoV1Alpha2SettingsClient, err := settings_mesh_gloo_solo_io_v1alpha2.NewMulticlusterSettingsClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "settings.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "Settings",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	settingsMeshGlooSoloIoV1Alpha2SettingsList, err := settingsMeshGlooSoloIoV1Alpha2SettingsClient.ListSettings(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range settingsMeshGlooSoloIoV1Alpha2SettingsList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		settingsMeshGlooSoloIoV1Alpha2Settings.Insert(&item)
	}

	return nil
}

func (b *multiClusterSettingsBuilder) insertNetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshesFromCluster(ctx context.Context, cluster string, networkingMeshGlooSoloIoV1Alpha2VirtualMeshes networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet, opts ResourceSettingsBuildOptions) error {
	networkingMeshGlooSoloIoV1Alpha2VirtualMeshClient, err := networking_mesh_gloo_solo_io_v1alpha2.NewMulticlusterVirtualMeshClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "VirtualMesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingMeshGlooSoloIoV1Alpha2VirtualMeshList, err := networkingMeshGlooSoloIoV1Alpha2VirtualMeshClient.ListVirtualMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingMeshGlooSoloIoV1Alpha2VirtualMeshList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		networkingMeshGlooSoloIoV1Alpha2VirtualMeshes.Insert(&item)
	}

	return nil
}

// build a snapshot from resources in a single cluster
type singleClusterSettingsBuilder struct {
	mgr         manager.Manager
	clusterName string
}

// Produces snapshots of resources read from the manager for the given cluster
func NewSingleClusterSettingsBuilder(
	mgr manager.Manager,
) SettingsBuilder {
	return NewSingleClusterSettingsBuilderWithClusterName(mgr, "")
}

// Produces snapshots of resources read from the manager for the given cluster.
// Snapshot resources will be marked with the given ClusterName.
func NewSingleClusterSettingsBuilderWithClusterName(
	mgr manager.Manager,
	clusterName string,
) SettingsBuilder {
	return &singleClusterSettingsBuilder{
		mgr:         mgr,
		clusterName: clusterName,
	}
}

func (b *singleClusterSettingsBuilder) BuildSnapshot(ctx context.Context, name string, opts SettingsBuildOptions) (SettingsSnapshot, error) {

	settingsMeshGlooSoloIoV1Alpha2Settings := settings_mesh_gloo_solo_io_v1alpha2_sets.NewSettingsSet()

	networkingMeshGlooSoloIoV1Alpha2VirtualMeshes := networking_mesh_gloo_solo_io_v1alpha2_sets.NewVirtualMeshSet()

	var errs error

	if err := b.insertSettingsMeshGlooSoloIo_V1Alpha2_Settings(ctx, settingsMeshGlooSoloIoV1Alpha2Settings, opts.SettingsMeshGlooSoloIo_V1Alpha2_Settings); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertNetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes(ctx, networkingMeshGlooSoloIoV1Alpha2VirtualMeshes, opts.NetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes); err != nil {
		errs = multierror.Append(errs, err)
	}

	outputSnap := NewSettingsSnapshot(
		name,

		settingsMeshGlooSoloIoV1Alpha2Settings,
		networkingMeshGlooSoloIoV1Alpha2VirtualMeshes,
	)

	return outputSnap, errs
}

func (b *singleClusterSettingsBuilder) insertSettingsMeshGlooSoloIo_V1Alpha2_Settings(ctx context.Context, settingsMeshGlooSoloIoV1Alpha2Settings settings_mesh_gloo_solo_io_v1alpha2_sets.SettingsSet, opts ResourceSettingsBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "settings.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "Settings",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	settingsMeshGlooSoloIoV1Alpha2SettingsList, err := settings_mesh_gloo_solo_io_v1alpha2.NewSettingsClient(b.mgr.GetClient()).ListSettings(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range settingsMeshGlooSoloIoV1Alpha2SettingsList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		settingsMeshGlooSoloIoV1Alpha2Settings.Insert(&item)
	}

	return nil
}

func (b *singleClusterSettingsBuilder) insertNetworkingMeshGlooSoloIo_V1Alpha2_VirtualMeshes(ctx context.Context, networkingMeshGlooSoloIoV1Alpha2VirtualMeshes networking_mesh_gloo_solo_io_v1alpha2_sets.VirtualMeshSet, opts ResourceSettingsBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "networking.mesh.gloo.solo.io",
			Version: "v1alpha2",
			Kind:    "VirtualMesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	networkingMeshGlooSoloIoV1Alpha2VirtualMeshList, err := networking_mesh_gloo_solo_io_v1alpha2.NewVirtualMeshClient(b.mgr.GetClient()).ListVirtualMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range networkingMeshGlooSoloIoV1Alpha2VirtualMeshList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		networkingMeshGlooSoloIoV1Alpha2VirtualMeshes.Insert(&item)
	}

	return nil
}
