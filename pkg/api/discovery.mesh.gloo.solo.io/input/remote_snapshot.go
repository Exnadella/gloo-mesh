// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./remote_snapshot.go -destination mocks/remote_snapshot.go

// The Input DiscoveryInputSnapshot contains the set of all:
// * AppmeshK8SAws_V1Beta2_Meshes
// * V1_ConfigMaps
// * V1_Services
// * V1_Pods
// * V1_Endpoints
// * V1_Nodes
// * Apps_V1_Deployments
// * Apps_V1_ReplicaSets
// * Apps_V1_DaemonSets
// * Apps_V1_StatefulSets
// read from a given cluster or set of clusters, across all namespaces.
//
// A snapshot can be constructed from either a single Manager (for a single cluster)
// or a ClusterWatcher (for multiple clusters) using the DiscoveryInputSnapshotBuilder.
//
// Resources in a MultiCluster snapshot will have their ClusterName set to the
// name of the cluster from which the resource was read.

package input

import (
	"context"
	"encoding/json"

	"github.com/solo-io/skv2/pkg/verifier"
	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/hashicorp/go-multierror"

	"github.com/solo-io/skv2/pkg/multicluster"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/manager"

	appmesh_k8s_aws_v1beta2 "github.com/solo-io/external-apis/pkg/api/appmesh/appmesh.k8s.aws/v1beta2"
	appmesh_k8s_aws_v1beta2_sets "github.com/solo-io/external-apis/pkg/api/appmesh/appmesh.k8s.aws/v1beta2/sets"

	v1 "github.com/solo-io/external-apis/pkg/api/k8s/core/v1"
	v1_sets "github.com/solo-io/external-apis/pkg/api/k8s/core/v1/sets"

	apps_v1 "github.com/solo-io/external-apis/pkg/api/k8s/apps/v1"
	apps_v1_sets "github.com/solo-io/external-apis/pkg/api/k8s/apps/v1/sets"
)

// the snapshot of input resources consumed by translation
type DiscoveryInputSnapshot interface {

	// return the set of input AppmeshK8SAws_V1Beta2_Meshes
	AppmeshK8SAws_V1Beta2_Meshes() appmesh_k8s_aws_v1beta2_sets.MeshSet

	// return the set of input V1_ConfigMaps
	V1_ConfigMaps() v1_sets.ConfigMapSet
	// return the set of input V1_Services
	V1_Services() v1_sets.ServiceSet
	// return the set of input V1_Pods
	V1_Pods() v1_sets.PodSet
	// return the set of input V1_Endpoints
	V1_Endpoints() v1_sets.EndpointsSet
	// return the set of input V1_Nodes
	V1_Nodes() v1_sets.NodeSet

	// return the set of input Apps_V1_Deployments
	Apps_V1_Deployments() apps_v1_sets.DeploymentSet
	// return the set of input Apps_V1_ReplicaSets
	Apps_V1_ReplicaSets() apps_v1_sets.ReplicaSetSet
	// return the set of input Apps_V1_DaemonSets
	Apps_V1_DaemonSets() apps_v1_sets.DaemonSetSet
	// return the set of input Apps_V1_StatefulSets
	Apps_V1_StatefulSets() apps_v1_sets.StatefulSetSet
	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)
}

// options for syncing input object statuses
type DiscoveryInputSyncStatusOptions struct {

	// sync status of AppmeshK8SAws_V1Beta2_Mesh objects
	AppmeshK8SAws_V1Beta2_Mesh bool

	// sync status of V1_ConfigMap objects
	V1_ConfigMap bool
	// sync status of V1_Service objects
	V1_Service bool
	// sync status of V1_Pod objects
	V1_Pod bool
	// sync status of V1_Endpoints objects
	V1_Endpoints bool
	// sync status of V1_Node objects
	V1_Node bool

	// sync status of Apps_V1_Deployment objects
	Apps_V1_Deployment bool
	// sync status of Apps_V1_ReplicaSet objects
	Apps_V1_ReplicaSet bool
	// sync status of Apps_V1_DaemonSet objects
	Apps_V1_DaemonSet bool
	// sync status of Apps_V1_StatefulSet objects
	Apps_V1_StatefulSet bool
}

type snapshotDiscoveryInput struct {
	name string

	appmeshK8SAwsV1Beta2Meshes appmesh_k8s_aws_v1beta2_sets.MeshSet

	v1ConfigMaps v1_sets.ConfigMapSet
	v1Services   v1_sets.ServiceSet
	v1Pods       v1_sets.PodSet
	v1Endpoints  v1_sets.EndpointsSet
	v1Nodes      v1_sets.NodeSet

	appsV1Deployments  apps_v1_sets.DeploymentSet
	appsV1ReplicaSets  apps_v1_sets.ReplicaSetSet
	appsV1DaemonSets   apps_v1_sets.DaemonSetSet
	appsV1StatefulSets apps_v1_sets.StatefulSetSet
}

func NewDiscoveryInputSnapshot(
	name string,

	appmeshK8SAwsV1Beta2Meshes appmesh_k8s_aws_v1beta2_sets.MeshSet,

	v1ConfigMaps v1_sets.ConfigMapSet,
	v1Services v1_sets.ServiceSet,
	v1Pods v1_sets.PodSet,
	v1Endpoints v1_sets.EndpointsSet,
	v1Nodes v1_sets.NodeSet,

	appsV1Deployments apps_v1_sets.DeploymentSet,
	appsV1ReplicaSets apps_v1_sets.ReplicaSetSet,
	appsV1DaemonSets apps_v1_sets.DaemonSetSet,
	appsV1StatefulSets apps_v1_sets.StatefulSetSet,

) DiscoveryInputSnapshot {
	return &snapshotDiscoveryInput{
		name: name,

		appmeshK8SAwsV1Beta2Meshes: appmeshK8SAwsV1Beta2Meshes,
		v1ConfigMaps:               v1ConfigMaps,
		v1Services:                 v1Services,
		v1Pods:                     v1Pods,
		v1Endpoints:                v1Endpoints,
		v1Nodes:                    v1Nodes,
		appsV1Deployments:          appsV1Deployments,
		appsV1ReplicaSets:          appsV1ReplicaSets,
		appsV1DaemonSets:           appsV1DaemonSets,
		appsV1StatefulSets:         appsV1StatefulSets,
	}
}

func (s snapshotDiscoveryInput) AppmeshK8SAws_V1Beta2_Meshes() appmesh_k8s_aws_v1beta2_sets.MeshSet {
	return s.appmeshK8SAwsV1Beta2Meshes
}

func (s snapshotDiscoveryInput) V1_ConfigMaps() v1_sets.ConfigMapSet {
	return s.v1ConfigMaps
}

func (s snapshotDiscoveryInput) V1_Services() v1_sets.ServiceSet {
	return s.v1Services
}

func (s snapshotDiscoveryInput) V1_Pods() v1_sets.PodSet {
	return s.v1Pods
}

func (s snapshotDiscoveryInput) V1_Endpoints() v1_sets.EndpointsSet {
	return s.v1Endpoints
}

func (s snapshotDiscoveryInput) V1_Nodes() v1_sets.NodeSet {
	return s.v1Nodes
}

func (s snapshotDiscoveryInput) Apps_V1_Deployments() apps_v1_sets.DeploymentSet {
	return s.appsV1Deployments
}

func (s snapshotDiscoveryInput) Apps_V1_ReplicaSets() apps_v1_sets.ReplicaSetSet {
	return s.appsV1ReplicaSets
}

func (s snapshotDiscoveryInput) Apps_V1_DaemonSets() apps_v1_sets.DaemonSetSet {
	return s.appsV1DaemonSets
}

func (s snapshotDiscoveryInput) Apps_V1_StatefulSets() apps_v1_sets.StatefulSetSet {
	return s.appsV1StatefulSets
}

func (s snapshotDiscoveryInput) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	snapshotMap["appmeshK8SAwsV1Beta2Meshes"] = s.appmeshK8SAwsV1Beta2Meshes.List()
	snapshotMap["v1ConfigMaps"] = s.v1ConfigMaps.List()
	snapshotMap["v1Services"] = s.v1Services.List()
	snapshotMap["v1Pods"] = s.v1Pods.List()
	snapshotMap["v1Endpoints"] = s.v1Endpoints.List()
	snapshotMap["v1Nodes"] = s.v1Nodes.List()
	snapshotMap["appsV1Deployments"] = s.appsV1Deployments.List()
	snapshotMap["appsV1ReplicaSets"] = s.appsV1ReplicaSets.List()
	snapshotMap["appsV1DaemonSets"] = s.appsV1DaemonSets.List()
	snapshotMap["appsV1StatefulSets"] = s.appsV1StatefulSets.List()
	return json.Marshal(snapshotMap)
}

// builds the input snapshot from API Clients.
type DiscoveryInputBuilder interface {
	BuildSnapshot(ctx context.Context, name string, opts DiscoveryInputBuildOptions) (DiscoveryInputSnapshot, error)
}

// Options for building a snapshot
type DiscoveryInputBuildOptions struct {

	// List options for composing a snapshot from AppmeshK8SAws_V1Beta2_Meshes
	AppmeshK8SAws_V1Beta2_Meshes ResourceDiscoveryInputBuildOptions

	// List options for composing a snapshot from V1_ConfigMaps
	V1_ConfigMaps ResourceDiscoveryInputBuildOptions
	// List options for composing a snapshot from V1_Services
	V1_Services ResourceDiscoveryInputBuildOptions
	// List options for composing a snapshot from V1_Pods
	V1_Pods ResourceDiscoveryInputBuildOptions
	// List options for composing a snapshot from V1_Endpoints
	V1_Endpoints ResourceDiscoveryInputBuildOptions
	// List options for composing a snapshot from V1_Nodes
	V1_Nodes ResourceDiscoveryInputBuildOptions

	// List options for composing a snapshot from Apps_V1_Deployments
	Apps_V1_Deployments ResourceDiscoveryInputBuildOptions
	// List options for composing a snapshot from Apps_V1_ReplicaSets
	Apps_V1_ReplicaSets ResourceDiscoveryInputBuildOptions
	// List options for composing a snapshot from Apps_V1_DaemonSets
	Apps_V1_DaemonSets ResourceDiscoveryInputBuildOptions
	// List options for composing a snapshot from Apps_V1_StatefulSets
	Apps_V1_StatefulSets ResourceDiscoveryInputBuildOptions
}

// Options for reading resources of a given type
type ResourceDiscoveryInputBuildOptions struct {

	// List options for composing a snapshot from a resource type
	ListOptions []client.ListOption

	// If provided, ensure the resource has been verified before adding it to snapshots
	Verifier verifier.ServerResourceVerifier
}

// build a snapshot from resources across multiple clusters
type multiClusterDiscoveryInputBuilder struct {
	clusters multicluster.Interface
	client   multicluster.Client
}

// Produces snapshots of resources across all clusters defined in the ClusterSet
func NewMultiClusterDiscoveryInputBuilder(
	clusters multicluster.Interface,
	client multicluster.Client,
) DiscoveryInputBuilder {
	return &multiClusterDiscoveryInputBuilder{
		clusters: clusters,
		client:   client,
	}
}

func (b *multiClusterDiscoveryInputBuilder) BuildSnapshot(ctx context.Context, name string, opts DiscoveryInputBuildOptions) (DiscoveryInputSnapshot, error) {

	appmeshK8SAwsV1Beta2Meshes := appmesh_k8s_aws_v1beta2_sets.NewMeshSet()

	v1ConfigMaps := v1_sets.NewConfigMapSet()
	v1Services := v1_sets.NewServiceSet()
	v1Pods := v1_sets.NewPodSet()
	v1Endpoints := v1_sets.NewEndpointsSet()
	v1Nodes := v1_sets.NewNodeSet()

	appsV1Deployments := apps_v1_sets.NewDeploymentSet()
	appsV1ReplicaSets := apps_v1_sets.NewReplicaSetSet()
	appsV1DaemonSets := apps_v1_sets.NewDaemonSetSet()
	appsV1StatefulSets := apps_v1_sets.NewStatefulSetSet()

	var errs error

	for _, cluster := range b.clusters.ListClusters() {

		if err := b.insertAppmeshK8SAws_V1Beta2_MeshesFromCluster(ctx, cluster, appmeshK8SAwsV1Beta2Meshes, opts.AppmeshK8SAws_V1Beta2_Meshes); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertV1_ConfigMapsFromCluster(ctx, cluster, v1ConfigMaps, opts.V1_ConfigMaps); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertV1_ServicesFromCluster(ctx, cluster, v1Services, opts.V1_Services); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertV1_PodsFromCluster(ctx, cluster, v1Pods, opts.V1_Pods); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertV1_EndpointsFromCluster(ctx, cluster, v1Endpoints, opts.V1_Endpoints); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertV1_NodesFromCluster(ctx, cluster, v1Nodes, opts.V1_Nodes); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertApps_V1_DeploymentsFromCluster(ctx, cluster, appsV1Deployments, opts.Apps_V1_Deployments); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertApps_V1_ReplicaSetsFromCluster(ctx, cluster, appsV1ReplicaSets, opts.Apps_V1_ReplicaSets); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertApps_V1_DaemonSetsFromCluster(ctx, cluster, appsV1DaemonSets, opts.Apps_V1_DaemonSets); err != nil {
			errs = multierror.Append(errs, err)
		}
		if err := b.insertApps_V1_StatefulSetsFromCluster(ctx, cluster, appsV1StatefulSets, opts.Apps_V1_StatefulSets); err != nil {
			errs = multierror.Append(errs, err)
		}

	}

	outputSnap := NewDiscoveryInputSnapshot(
		name,

		appmeshK8SAwsV1Beta2Meshes,
		v1ConfigMaps,
		v1Services,
		v1Pods,
		v1Endpoints,
		v1Nodes,
		appsV1Deployments,
		appsV1ReplicaSets,
		appsV1DaemonSets,
		appsV1StatefulSets,
	)

	return outputSnap, errs
}

func (b *multiClusterDiscoveryInputBuilder) insertAppmeshK8SAws_V1Beta2_MeshesFromCluster(ctx context.Context, cluster string, appmeshK8SAwsV1Beta2Meshes appmesh_k8s_aws_v1beta2_sets.MeshSet, opts ResourceDiscoveryInputBuildOptions) error {
	appmeshK8SAwsV1Beta2MeshClient, err := appmesh_k8s_aws_v1beta2.NewMulticlusterMeshClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "appmesh.k8s.aws",
			Version: "v1beta2",
			Kind:    "Mesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	appmeshK8SAwsV1Beta2MeshList, err := appmeshK8SAwsV1Beta2MeshClient.ListMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range appmeshK8SAwsV1Beta2MeshList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		appmeshK8SAwsV1Beta2Meshes.Insert(&item)
	}

	return nil
}

func (b *multiClusterDiscoveryInputBuilder) insertV1_ConfigMapsFromCluster(ctx context.Context, cluster string, v1ConfigMaps v1_sets.ConfigMapSet, opts ResourceDiscoveryInputBuildOptions) error {
	v1ConfigMapClient, err := v1.NewMulticlusterConfigMapClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "ConfigMap",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	v1ConfigMapList, err := v1ConfigMapClient.ListConfigMap(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range v1ConfigMapList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		v1ConfigMaps.Insert(&item)
	}

	return nil
}
func (b *multiClusterDiscoveryInputBuilder) insertV1_ServicesFromCluster(ctx context.Context, cluster string, v1Services v1_sets.ServiceSet, opts ResourceDiscoveryInputBuildOptions) error {
	v1ServiceClient, err := v1.NewMulticlusterServiceClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Service",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	v1ServiceList, err := v1ServiceClient.ListService(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range v1ServiceList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		v1Services.Insert(&item)
	}

	return nil
}
func (b *multiClusterDiscoveryInputBuilder) insertV1_PodsFromCluster(ctx context.Context, cluster string, v1Pods v1_sets.PodSet, opts ResourceDiscoveryInputBuildOptions) error {
	v1PodClient, err := v1.NewMulticlusterPodClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Pod",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	v1PodList, err := v1PodClient.ListPod(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range v1PodList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		v1Pods.Insert(&item)
	}

	return nil
}
func (b *multiClusterDiscoveryInputBuilder) insertV1_EndpointsFromCluster(ctx context.Context, cluster string, v1Endpoints v1_sets.EndpointsSet, opts ResourceDiscoveryInputBuildOptions) error {
	v1EndpointsClient, err := v1.NewMulticlusterEndpointsClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Endpoints",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	v1EndpointsList, err := v1EndpointsClient.ListEndpoints(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range v1EndpointsList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		v1Endpoints.Insert(&item)
	}

	return nil
}
func (b *multiClusterDiscoveryInputBuilder) insertV1_NodesFromCluster(ctx context.Context, cluster string, v1Nodes v1_sets.NodeSet, opts ResourceDiscoveryInputBuildOptions) error {
	v1NodeClient, err := v1.NewMulticlusterNodeClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Node",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	v1NodeList, err := v1NodeClient.ListNode(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range v1NodeList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		v1Nodes.Insert(&item)
	}

	return nil
}

func (b *multiClusterDiscoveryInputBuilder) insertApps_V1_DeploymentsFromCluster(ctx context.Context, cluster string, appsV1Deployments apps_v1_sets.DeploymentSet, opts ResourceDiscoveryInputBuildOptions) error {
	appsV1DeploymentClient, err := apps_v1.NewMulticlusterDeploymentClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "Deployment",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	appsV1DeploymentList, err := appsV1DeploymentClient.ListDeployment(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range appsV1DeploymentList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		appsV1Deployments.Insert(&item)
	}

	return nil
}
func (b *multiClusterDiscoveryInputBuilder) insertApps_V1_ReplicaSetsFromCluster(ctx context.Context, cluster string, appsV1ReplicaSets apps_v1_sets.ReplicaSetSet, opts ResourceDiscoveryInputBuildOptions) error {
	appsV1ReplicaSetClient, err := apps_v1.NewMulticlusterReplicaSetClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "ReplicaSet",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	appsV1ReplicaSetList, err := appsV1ReplicaSetClient.ListReplicaSet(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range appsV1ReplicaSetList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		appsV1ReplicaSets.Insert(&item)
	}

	return nil
}
func (b *multiClusterDiscoveryInputBuilder) insertApps_V1_DaemonSetsFromCluster(ctx context.Context, cluster string, appsV1DaemonSets apps_v1_sets.DaemonSetSet, opts ResourceDiscoveryInputBuildOptions) error {
	appsV1DaemonSetClient, err := apps_v1.NewMulticlusterDaemonSetClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "DaemonSet",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	appsV1DaemonSetList, err := appsV1DaemonSetClient.ListDaemonSet(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range appsV1DaemonSetList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		appsV1DaemonSets.Insert(&item)
	}

	return nil
}
func (b *multiClusterDiscoveryInputBuilder) insertApps_V1_StatefulSetsFromCluster(ctx context.Context, cluster string, appsV1StatefulSets apps_v1_sets.StatefulSetSet, opts ResourceDiscoveryInputBuildOptions) error {
	appsV1StatefulSetClient, err := apps_v1.NewMulticlusterStatefulSetClient(b.client).Cluster(cluster)
	if err != nil {
		return err
	}

	if opts.Verifier != nil {
		mgr, err := b.clusters.Cluster(cluster)
		if err != nil {
			return err
		}

		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "StatefulSet",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			cluster,
			mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	appsV1StatefulSetList, err := appsV1StatefulSetClient.ListStatefulSet(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range appsV1StatefulSetList.Items {
		item := item               // pike
		item.ClusterName = cluster // set cluster for in-memory processing
		appsV1StatefulSets.Insert(&item)
	}

	return nil
}

// build a snapshot from resources in a single cluster
type singleClusterDiscoveryInputBuilder struct {
	mgr         manager.Manager
	clusterName string
}

// Produces snapshots of resources read from the manager for the given cluster
func NewSingleClusterDiscoveryInputBuilder(
	mgr manager.Manager,
) DiscoveryInputBuilder {
	return NewSingleClusterDiscoveryInputBuilderWithClusterName(mgr, "")
}

// Produces snapshots of resources read from the manager for the given cluster.
// Snapshot resources will be marked with the given ClusterName.
func NewSingleClusterDiscoveryInputBuilderWithClusterName(
	mgr manager.Manager,
	clusterName string,
) DiscoveryInputBuilder {
	return &singleClusterDiscoveryInputBuilder{
		mgr:         mgr,
		clusterName: clusterName,
	}
}

func (b *singleClusterDiscoveryInputBuilder) BuildSnapshot(ctx context.Context, name string, opts DiscoveryInputBuildOptions) (DiscoveryInputSnapshot, error) {

	appmeshK8SAwsV1Beta2Meshes := appmesh_k8s_aws_v1beta2_sets.NewMeshSet()

	v1ConfigMaps := v1_sets.NewConfigMapSet()
	v1Services := v1_sets.NewServiceSet()
	v1Pods := v1_sets.NewPodSet()
	v1Endpoints := v1_sets.NewEndpointsSet()
	v1Nodes := v1_sets.NewNodeSet()

	appsV1Deployments := apps_v1_sets.NewDeploymentSet()
	appsV1ReplicaSets := apps_v1_sets.NewReplicaSetSet()
	appsV1DaemonSets := apps_v1_sets.NewDaemonSetSet()
	appsV1StatefulSets := apps_v1_sets.NewStatefulSetSet()

	var errs error

	if err := b.insertAppmeshK8SAws_V1Beta2_Meshes(ctx, appmeshK8SAwsV1Beta2Meshes, opts.AppmeshK8SAws_V1Beta2_Meshes); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertV1_ConfigMaps(ctx, v1ConfigMaps, opts.V1_ConfigMaps); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertV1_Services(ctx, v1Services, opts.V1_Services); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertV1_Pods(ctx, v1Pods, opts.V1_Pods); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertV1_Endpoints(ctx, v1Endpoints, opts.V1_Endpoints); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertV1_Nodes(ctx, v1Nodes, opts.V1_Nodes); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertApps_V1_Deployments(ctx, appsV1Deployments, opts.Apps_V1_Deployments); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertApps_V1_ReplicaSets(ctx, appsV1ReplicaSets, opts.Apps_V1_ReplicaSets); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertApps_V1_DaemonSets(ctx, appsV1DaemonSets, opts.Apps_V1_DaemonSets); err != nil {
		errs = multierror.Append(errs, err)
	}
	if err := b.insertApps_V1_StatefulSets(ctx, appsV1StatefulSets, opts.Apps_V1_StatefulSets); err != nil {
		errs = multierror.Append(errs, err)
	}

	outputSnap := NewDiscoveryInputSnapshot(
		name,

		appmeshK8SAwsV1Beta2Meshes,
		v1ConfigMaps,
		v1Services,
		v1Pods,
		v1Endpoints,
		v1Nodes,
		appsV1Deployments,
		appsV1ReplicaSets,
		appsV1DaemonSets,
		appsV1StatefulSets,
	)

	return outputSnap, errs
}

func (b *singleClusterDiscoveryInputBuilder) insertAppmeshK8SAws_V1Beta2_Meshes(ctx context.Context, appmeshK8SAwsV1Beta2Meshes appmesh_k8s_aws_v1beta2_sets.MeshSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "appmesh.k8s.aws",
			Version: "v1beta2",
			Kind:    "Mesh",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	appmeshK8SAwsV1Beta2MeshList, err := appmesh_k8s_aws_v1beta2.NewMeshClient(b.mgr.GetClient()).ListMesh(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range appmeshK8SAwsV1Beta2MeshList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		appmeshK8SAwsV1Beta2Meshes.Insert(&item)
	}

	return nil
}

func (b *singleClusterDiscoveryInputBuilder) insertV1_ConfigMaps(ctx context.Context, v1ConfigMaps v1_sets.ConfigMapSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "ConfigMap",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	v1ConfigMapList, err := v1.NewConfigMapClient(b.mgr.GetClient()).ListConfigMap(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range v1ConfigMapList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		v1ConfigMaps.Insert(&item)
	}

	return nil
}
func (b *singleClusterDiscoveryInputBuilder) insertV1_Services(ctx context.Context, v1Services v1_sets.ServiceSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Service",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	v1ServiceList, err := v1.NewServiceClient(b.mgr.GetClient()).ListService(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range v1ServiceList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		v1Services.Insert(&item)
	}

	return nil
}
func (b *singleClusterDiscoveryInputBuilder) insertV1_Pods(ctx context.Context, v1Pods v1_sets.PodSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Pod",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	v1PodList, err := v1.NewPodClient(b.mgr.GetClient()).ListPod(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range v1PodList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		v1Pods.Insert(&item)
	}

	return nil
}
func (b *singleClusterDiscoveryInputBuilder) insertV1_Endpoints(ctx context.Context, v1Endpoints v1_sets.EndpointsSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Endpoints",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	v1EndpointsList, err := v1.NewEndpointsClient(b.mgr.GetClient()).ListEndpoints(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range v1EndpointsList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		v1Endpoints.Insert(&item)
	}

	return nil
}
func (b *singleClusterDiscoveryInputBuilder) insertV1_Nodes(ctx context.Context, v1Nodes v1_sets.NodeSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "",
			Version: "v1",
			Kind:    "Node",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	v1NodeList, err := v1.NewNodeClient(b.mgr.GetClient()).ListNode(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range v1NodeList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		v1Nodes.Insert(&item)
	}

	return nil
}

func (b *singleClusterDiscoveryInputBuilder) insertApps_V1_Deployments(ctx context.Context, appsV1Deployments apps_v1_sets.DeploymentSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "Deployment",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	appsV1DeploymentList, err := apps_v1.NewDeploymentClient(b.mgr.GetClient()).ListDeployment(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range appsV1DeploymentList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		appsV1Deployments.Insert(&item)
	}

	return nil
}
func (b *singleClusterDiscoveryInputBuilder) insertApps_V1_ReplicaSets(ctx context.Context, appsV1ReplicaSets apps_v1_sets.ReplicaSetSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "ReplicaSet",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	appsV1ReplicaSetList, err := apps_v1.NewReplicaSetClient(b.mgr.GetClient()).ListReplicaSet(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range appsV1ReplicaSetList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		appsV1ReplicaSets.Insert(&item)
	}

	return nil
}
func (b *singleClusterDiscoveryInputBuilder) insertApps_V1_DaemonSets(ctx context.Context, appsV1DaemonSets apps_v1_sets.DaemonSetSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "DaemonSet",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	appsV1DaemonSetList, err := apps_v1.NewDaemonSetClient(b.mgr.GetClient()).ListDaemonSet(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range appsV1DaemonSetList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		appsV1DaemonSets.Insert(&item)
	}

	return nil
}
func (b *singleClusterDiscoveryInputBuilder) insertApps_V1_StatefulSets(ctx context.Context, appsV1StatefulSets apps_v1_sets.StatefulSetSet, opts ResourceDiscoveryInputBuildOptions) error {

	if opts.Verifier != nil {
		gvk := schema.GroupVersionKind{
			Group:   "apps",
			Version: "v1",
			Kind:    "StatefulSet",
		}

		if resourceRegistered, err := opts.Verifier.VerifyServerResource(
			"", // verify in the local cluster
			b.mgr.GetConfig(),
			gvk,
		); err != nil {
			return err
		} else if !resourceRegistered {
			return nil
		}
	}

	appsV1StatefulSetList, err := apps_v1.NewStatefulSetClient(b.mgr.GetClient()).ListStatefulSet(ctx, opts.ListOptions...)
	if err != nil {
		return err
	}

	for _, item := range appsV1StatefulSetList.Items {
		item := item // pike
		item.ClusterName = b.clusterName
		appsV1StatefulSets.Insert(&item)
	}

	return nil
}
