// Code generated by skv2. DO NOT EDIT.

//go:generate mockgen -source ./snapshot.go -destination mocks/snapshot.go

// Definitions for Output Snapshots
package discovery

import (
	"context"
	"encoding/json"
	"sort"

	"k8s.io/apimachinery/pkg/runtime/schema"

	"github.com/solo-io/go-utils/contextutils"
	"github.com/solo-io/skv2/pkg/multicluster"

	"github.com/rotisserie/eris"
	"github.com/solo-io/skv2/contrib/pkg/output"
	"github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"sigs.k8s.io/controller-runtime/pkg/client"

	discovery_mesh_gloo_solo_io_v1alpha2 "github.com/solo-io/gloo-mesh/pkg/api/discovery.mesh.gloo.solo.io/v1alpha2"
	discovery_mesh_gloo_solo_io_v1alpha2_sets "github.com/solo-io/gloo-mesh/pkg/api/discovery.mesh.gloo.solo.io/v1alpha2/sets"
)

// this error can occur if constructing a Partitioned Snapshot from a resource
// that is missing the partition label
var MissingRequiredLabelError = func(labelKey, resourceKind string, obj ezkube.ResourceId) error {
	return eris.Errorf("expected label %v not on labels of %v %v", labelKey, resourceKind, sets.Key(obj))
}

// the snapshot of output resources produced by a translation
type Snapshot interface {

	// return the set of DiscoveryMeshGlooSoloIov1Alpha2TrafficTargets with a given set of labels
	DiscoveryMeshGlooSoloIov1Alpha2TrafficTargets() []LabeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet
	// return the set of DiscoveryMeshGlooSoloIov1Alpha2Workloads with a given set of labels
	DiscoveryMeshGlooSoloIov1Alpha2Workloads() []LabeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet
	// return the set of DiscoveryMeshGlooSoloIov1Alpha2Meshes with a given set of labels
	DiscoveryMeshGlooSoloIov1Alpha2Meshes() []LabeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet

	// apply the snapshot to the local cluster, garbage collecting stale resources
	ApplyLocalCluster(ctx context.Context, clusterClient client.Client, errHandler output.ErrorHandler)

	// apply resources from the snapshot across multiple clusters, garbage collecting stale resources
	ApplyMultiCluster(ctx context.Context, multiClusterClient multicluster.Client, errHandler output.ErrorHandler)

	// serialize the entire snapshot as JSON
	MarshalJSON() ([]byte, error)
}

type snapshot struct {
	name string

	discoveryMeshGlooSoloIov1Alpha2TrafficTargets []LabeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet
	discoveryMeshGlooSoloIov1Alpha2Workloads      []LabeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet
	discoveryMeshGlooSoloIov1Alpha2Meshes         []LabeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet
	clusters                                      []string
}

func NewSnapshot(
	name string,

	discoveryMeshGlooSoloIov1Alpha2TrafficTargets []LabeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet,
	discoveryMeshGlooSoloIov1Alpha2Workloads []LabeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet,
	discoveryMeshGlooSoloIov1Alpha2Meshes []LabeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet,
	clusters ...string, // the set of clusters to apply the snapshot to. only required for multicluster snapshots.
) Snapshot {
	return &snapshot{
		name: name,

		discoveryMeshGlooSoloIov1Alpha2TrafficTargets: discoveryMeshGlooSoloIov1Alpha2TrafficTargets,
		discoveryMeshGlooSoloIov1Alpha2Workloads:      discoveryMeshGlooSoloIov1Alpha2Workloads,
		discoveryMeshGlooSoloIov1Alpha2Meshes:         discoveryMeshGlooSoloIov1Alpha2Meshes,
		clusters:                                      clusters,
	}
}

// automatically partitions the input resources
// by the presence of the provided label.
func NewLabelPartitionedSnapshot(
	name,
	labelKey string, // the key by which to partition the resources

	discoveryMeshGlooSoloIov1Alpha2TrafficTargets discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet,
	discoveryMeshGlooSoloIov1Alpha2Workloads discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet,
	discoveryMeshGlooSoloIov1Alpha2Meshes discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet,
	clusters ...string, // the set of clusters to apply the snapshot to. only required for multicluster snapshots.
) (Snapshot, error) {

	partitionedDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets, err := partitionDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetsByLabel(labelKey, discoveryMeshGlooSoloIov1Alpha2TrafficTargets)
	if err != nil {
		return nil, err
	}
	partitionedDiscoveryMeshGlooSoloIov1Alpha2Workloads, err := partitionDiscoveryMeshGlooSoloIov1Alpha2WorkloadsByLabel(labelKey, discoveryMeshGlooSoloIov1Alpha2Workloads)
	if err != nil {
		return nil, err
	}
	partitionedDiscoveryMeshGlooSoloIov1Alpha2Meshes, err := partitionDiscoveryMeshGlooSoloIov1Alpha2MeshesByLabel(labelKey, discoveryMeshGlooSoloIov1Alpha2Meshes)
	if err != nil {
		return nil, err
	}

	return NewSnapshot(
		name,

		partitionedDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets,
		partitionedDiscoveryMeshGlooSoloIov1Alpha2Workloads,
		partitionedDiscoveryMeshGlooSoloIov1Alpha2Meshes,
		clusters...,
	), nil
}

// simplified constructor for a snapshot
// with a single label partition (i.e. all resources share a single set of labels).
func NewSinglePartitionedSnapshot(
	name string,
	snapshotLabels map[string]string, // a single set of labels shared by all resources

	discoveryMeshGlooSoloIov1Alpha2TrafficTargets discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet,
	discoveryMeshGlooSoloIov1Alpha2Workloads discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet,
	discoveryMeshGlooSoloIov1Alpha2Meshes discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet,
	clusters ...string, // the set of clusters to apply the snapshot to. only required for multicluster snapshots.
) (Snapshot, error) {

	labeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTarget, err := NewLabeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet(discoveryMeshGlooSoloIov1Alpha2TrafficTargets, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledDiscoveryMeshGlooSoloIov1Alpha2Workload, err := NewLabeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet(discoveryMeshGlooSoloIov1Alpha2Workloads, snapshotLabels)
	if err != nil {
		return nil, err
	}
	labeledDiscoveryMeshGlooSoloIov1Alpha2Mesh, err := NewLabeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet(discoveryMeshGlooSoloIov1Alpha2Meshes, snapshotLabels)
	if err != nil {
		return nil, err
	}

	return NewSnapshot(
		name,

		[]LabeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet{labeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTarget},
		[]LabeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet{labeledDiscoveryMeshGlooSoloIov1Alpha2Workload},
		[]LabeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet{labeledDiscoveryMeshGlooSoloIov1Alpha2Mesh},
		clusters...,
	), nil
}

// apply the desired resources to the cluster state; remove stale resources where necessary
func (s *snapshot) ApplyLocalCluster(ctx context.Context, cli client.Client, errHandler output.ErrorHandler) {
	var genericLists []output.ResourceList

	for _, outputSet := range s.discoveryMeshGlooSoloIov1Alpha2TrafficTargets {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.discoveryMeshGlooSoloIov1Alpha2Workloads {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.discoveryMeshGlooSoloIov1Alpha2Meshes {
		genericLists = append(genericLists, outputSet.Generic())
	}

	output.Snapshot{
		Name:        s.name,
		ListsToSync: genericLists,
	}.SyncLocalCluster(ctx, cli, errHandler)
}

// apply the desired resources to multiple cluster states; remove stale resources where necessary
func (s *snapshot) ApplyMultiCluster(ctx context.Context, multiClusterClient multicluster.Client, errHandler output.ErrorHandler) {
	var genericLists []output.ResourceList

	for _, outputSet := range s.discoveryMeshGlooSoloIov1Alpha2TrafficTargets {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.discoveryMeshGlooSoloIov1Alpha2Workloads {
		genericLists = append(genericLists, outputSet.Generic())
	}
	for _, outputSet := range s.discoveryMeshGlooSoloIov1Alpha2Meshes {
		genericLists = append(genericLists, outputSet.Generic())
	}

	output.Snapshot{
		Name:        s.name,
		Clusters:    s.clusters,
		ListsToSync: genericLists,
	}.SyncMultiCluster(ctx, multiClusterClient, errHandler)
}

func partitionDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetsByLabel(labelKey string, set discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet) ([]LabeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet, error) {
	setsByLabel := map[string]discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "DiscoveryMeshGlooSoloIov1Alpha2TrafficTarget", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "DiscoveryMeshGlooSoloIov1Alpha2TrafficTarget", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = discovery_mesh_gloo_solo_io_v1alpha2_sets.NewTrafficTargetSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets []LabeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets = append(partitionedDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets, func(i, j int) bool {
		leftLabelValue := partitionedDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets[i].Labels()[labelKey]
		rightLabelValue := partitionedDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets, nil
}

func partitionDiscoveryMeshGlooSoloIov1Alpha2WorkloadsByLabel(labelKey string, set discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet) ([]LabeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet, error) {
	setsByLabel := map[string]discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "DiscoveryMeshGlooSoloIov1Alpha2Workload", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "DiscoveryMeshGlooSoloIov1Alpha2Workload", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = discovery_mesh_gloo_solo_io_v1alpha2_sets.NewWorkloadSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedDiscoveryMeshGlooSoloIov1Alpha2Workloads []LabeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedDiscoveryMeshGlooSoloIov1Alpha2Workloads = append(partitionedDiscoveryMeshGlooSoloIov1Alpha2Workloads, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedDiscoveryMeshGlooSoloIov1Alpha2Workloads, func(i, j int) bool {
		leftLabelValue := partitionedDiscoveryMeshGlooSoloIov1Alpha2Workloads[i].Labels()[labelKey]
		rightLabelValue := partitionedDiscoveryMeshGlooSoloIov1Alpha2Workloads[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedDiscoveryMeshGlooSoloIov1Alpha2Workloads, nil
}

func partitionDiscoveryMeshGlooSoloIov1Alpha2MeshesByLabel(labelKey string, set discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet) ([]LabeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet, error) {
	setsByLabel := map[string]discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet{}

	for _, obj := range set.List() {
		if obj.Labels == nil {
			return nil, MissingRequiredLabelError(labelKey, "DiscoveryMeshGlooSoloIov1Alpha2Mesh", obj)
		}
		labelValue := obj.Labels[labelKey]
		if labelValue == "" {
			return nil, MissingRequiredLabelError(labelKey, "DiscoveryMeshGlooSoloIov1Alpha2Mesh", obj)
		}

		setForValue, ok := setsByLabel[labelValue]
		if !ok {
			setForValue = discovery_mesh_gloo_solo_io_v1alpha2_sets.NewMeshSet()
			setsByLabel[labelValue] = setForValue
		}
		setForValue.Insert(obj)
	}

	// partition by label key
	var partitionedDiscoveryMeshGlooSoloIov1Alpha2Meshes []LabeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet

	for labelValue, setForValue := range setsByLabel {
		labels := map[string]string{labelKey: labelValue}

		partitionedSet, err := NewLabeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet(setForValue, labels)
		if err != nil {
			return nil, err
		}

		partitionedDiscoveryMeshGlooSoloIov1Alpha2Meshes = append(partitionedDiscoveryMeshGlooSoloIov1Alpha2Meshes, partitionedSet)
	}

	// sort for idempotency
	sort.SliceStable(partitionedDiscoveryMeshGlooSoloIov1Alpha2Meshes, func(i, j int) bool {
		leftLabelValue := partitionedDiscoveryMeshGlooSoloIov1Alpha2Meshes[i].Labels()[labelKey]
		rightLabelValue := partitionedDiscoveryMeshGlooSoloIov1Alpha2Meshes[j].Labels()[labelKey]
		return leftLabelValue < rightLabelValue
	})

	return partitionedDiscoveryMeshGlooSoloIov1Alpha2Meshes, nil
}

func (s snapshot) DiscoveryMeshGlooSoloIov1Alpha2TrafficTargets() []LabeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet {
	return s.discoveryMeshGlooSoloIov1Alpha2TrafficTargets
}

func (s snapshot) DiscoveryMeshGlooSoloIov1Alpha2Workloads() []LabeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet {
	return s.discoveryMeshGlooSoloIov1Alpha2Workloads
}

func (s snapshot) DiscoveryMeshGlooSoloIov1Alpha2Meshes() []LabeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet {
	return s.discoveryMeshGlooSoloIov1Alpha2Meshes
}

func (s snapshot) MarshalJSON() ([]byte, error) {
	snapshotMap := map[string]interface{}{"name": s.name}

	discoveryMeshGlooSoloIov1Alpha2TrafficTargetSet := discovery_mesh_gloo_solo_io_v1alpha2_sets.NewTrafficTargetSet()
	for _, set := range s.discoveryMeshGlooSoloIov1Alpha2TrafficTargets {
		discoveryMeshGlooSoloIov1Alpha2TrafficTargetSet = discoveryMeshGlooSoloIov1Alpha2TrafficTargetSet.Union(set.Set())
	}
	snapshotMap["discoveryMeshGlooSoloIov1Alpha2TrafficTargets"] = discoveryMeshGlooSoloIov1Alpha2TrafficTargetSet.List()
	discoveryMeshGlooSoloIov1Alpha2WorkloadSet := discovery_mesh_gloo_solo_io_v1alpha2_sets.NewWorkloadSet()
	for _, set := range s.discoveryMeshGlooSoloIov1Alpha2Workloads {
		discoveryMeshGlooSoloIov1Alpha2WorkloadSet = discoveryMeshGlooSoloIov1Alpha2WorkloadSet.Union(set.Set())
	}
	snapshotMap["discoveryMeshGlooSoloIov1Alpha2Workloads"] = discoveryMeshGlooSoloIov1Alpha2WorkloadSet.List()
	discoveryMeshGlooSoloIov1Alpha2MeshSet := discovery_mesh_gloo_solo_io_v1alpha2_sets.NewMeshSet()
	for _, set := range s.discoveryMeshGlooSoloIov1Alpha2Meshes {
		discoveryMeshGlooSoloIov1Alpha2MeshSet = discoveryMeshGlooSoloIov1Alpha2MeshSet.Union(set.Set())
	}
	snapshotMap["discoveryMeshGlooSoloIov1Alpha2Meshes"] = discoveryMeshGlooSoloIov1Alpha2MeshSet.List()

	snapshotMap["clusters"] = s.clusters

	return json.Marshal(snapshotMap)
}

// LabeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet represents a set of discoveryMeshGlooSoloIov1Alpha2TrafficTargets
// which share a common set of labels.
// These labels are used to find diffs between DiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSets.
type LabeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet interface {
	// returns the set of Labels shared by this DiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet
	Labels() map[string]string

	// returns the set of TrafficTargetes with the given labels
	Set() discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet struct {
	set    discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet
	labels map[string]string
}

func NewLabeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet(set discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet, labels map[string]string) (LabeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet, error) {
	// validate that each TrafficTarget contains the labels, else this is not a valid LabeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on DiscoveryMeshGlooSoloIov1Alpha2TrafficTarget %v", k, v, item.Name)
			}
		}
	}

	return &labeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet{set: set, labels: labels}, nil
}

func (l *labeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet) Set() discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet {
	return l.set
}

func (l labeledDiscoveryMeshGlooSoloIov1Alpha2TrafficTargetSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list discovery_mesh_gloo_solo_io_v1alpha2.TrafficTargetList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "TrafficTarget",
	}
}

// LabeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet represents a set of discoveryMeshGlooSoloIov1Alpha2Workloads
// which share a common set of labels.
// These labels are used to find diffs between DiscoveryMeshGlooSoloIov1Alpha2WorkloadSets.
type LabeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet interface {
	// returns the set of Labels shared by this DiscoveryMeshGlooSoloIov1Alpha2WorkloadSet
	Labels() map[string]string

	// returns the set of Workloades with the given labels
	Set() discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet struct {
	set    discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet
	labels map[string]string
}

func NewLabeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet(set discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet, labels map[string]string) (LabeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet, error) {
	// validate that each Workload contains the labels, else this is not a valid LabeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on DiscoveryMeshGlooSoloIov1Alpha2Workload %v", k, v, item.Name)
			}
		}
	}

	return &labeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet{set: set, labels: labels}, nil
}

func (l *labeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet) Set() discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet {
	return l.set
}

func (l labeledDiscoveryMeshGlooSoloIov1Alpha2WorkloadSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list discovery_mesh_gloo_solo_io_v1alpha2.WorkloadList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "Workload",
	}
}

// LabeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet represents a set of discoveryMeshGlooSoloIov1Alpha2Meshes
// which share a common set of labels.
// These labels are used to find diffs between DiscoveryMeshGlooSoloIov1Alpha2MeshSets.
type LabeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet interface {
	// returns the set of Labels shared by this DiscoveryMeshGlooSoloIov1Alpha2MeshSet
	Labels() map[string]string

	// returns the set of Meshes with the given labels
	Set() discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet

	// converts the set to a generic format which can be applied by the Snapshot.Apply functions
	Generic() output.ResourceList
}

type labeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet struct {
	set    discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet
	labels map[string]string
}

func NewLabeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet(set discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet, labels map[string]string) (LabeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet, error) {
	// validate that each Mesh contains the labels, else this is not a valid LabeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet
	for _, item := range set.List() {
		for k, v := range labels {
			// k=v must be present in the item
			if item.Labels[k] != v {
				return nil, eris.Errorf("internal error: %v=%v missing on DiscoveryMeshGlooSoloIov1Alpha2Mesh %v", k, v, item.Name)
			}
		}
	}

	return &labeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet{set: set, labels: labels}, nil
}

func (l *labeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet) Labels() map[string]string {
	return l.labels
}

func (l *labeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet) Set() discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet {
	return l.set
}

func (l labeledDiscoveryMeshGlooSoloIov1Alpha2MeshSet) Generic() output.ResourceList {
	var desiredResources []ezkube.Object
	for _, desired := range l.set.List() {
		desiredResources = append(desiredResources, desired)
	}

	// enable list func for garbage collection
	listFunc := func(ctx context.Context, cli client.Client) ([]ezkube.Object, error) {
		var list discovery_mesh_gloo_solo_io_v1alpha2.MeshList
		if err := cli.List(ctx, &list, client.MatchingLabels(l.labels)); err != nil {
			return nil, err
		}
		var items []ezkube.Object
		for _, item := range list.Items {
			item := item // pike
			items = append(items, &item)
		}
		return items, nil
	}

	return output.ResourceList{
		Resources:    desiredResources,
		ListFunc:     listFunc,
		ResourceKind: "Mesh",
	}
}

type builder struct {
	ctx      context.Context
	name     string
	clusters []string

	discoveryMeshGlooSoloIov1Alpha2TrafficTargets discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet
	discoveryMeshGlooSoloIov1Alpha2Workloads      discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet
	discoveryMeshGlooSoloIov1Alpha2Meshes         discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet
}

func NewBuilder(ctx context.Context, name string) *builder {
	return &builder{
		ctx:  ctx,
		name: name,

		discoveryMeshGlooSoloIov1Alpha2TrafficTargets: discovery_mesh_gloo_solo_io_v1alpha2_sets.NewTrafficTargetSet(),
		discoveryMeshGlooSoloIov1Alpha2Workloads:      discovery_mesh_gloo_solo_io_v1alpha2_sets.NewWorkloadSet(),
		discoveryMeshGlooSoloIov1Alpha2Meshes:         discovery_mesh_gloo_solo_io_v1alpha2_sets.NewMeshSet(),
	}
}

// the output Builder uses a builder pattern to allow
// iteratively collecting outputs before producing a final snapshot
type Builder interface {

	// add DiscoveryMeshGlooSoloIov1Alpha2TrafficTargets to the collected outputs
	AddDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets(discoveryMeshGlooSoloIov1Alpha2TrafficTargets ...*discovery_mesh_gloo_solo_io_v1alpha2.TrafficTarget)

	// get the collected DiscoveryMeshGlooSoloIov1Alpha2TrafficTargets
	GetDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets() discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet

	// add DiscoveryMeshGlooSoloIov1Alpha2Workloads to the collected outputs
	AddDiscoveryMeshGlooSoloIov1Alpha2Workloads(discoveryMeshGlooSoloIov1Alpha2Workloads ...*discovery_mesh_gloo_solo_io_v1alpha2.Workload)

	// get the collected DiscoveryMeshGlooSoloIov1Alpha2Workloads
	GetDiscoveryMeshGlooSoloIov1Alpha2Workloads() discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet

	// add DiscoveryMeshGlooSoloIov1Alpha2Meshes to the collected outputs
	AddDiscoveryMeshGlooSoloIov1Alpha2Meshes(discoveryMeshGlooSoloIov1Alpha2Meshes ...*discovery_mesh_gloo_solo_io_v1alpha2.Mesh)

	// get the collected DiscoveryMeshGlooSoloIov1Alpha2Meshes
	GetDiscoveryMeshGlooSoloIov1Alpha2Meshes() discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet

	// build the collected outputs into a label-partitioned snapshot
	BuildLabelPartitionedSnapshot(labelKey string) (Snapshot, error)

	// build the collected outputs into a snapshot with a single partition
	BuildSinglePartitionedSnapshot(snapshotLabels map[string]string) (Snapshot, error)

	// add a cluster to the collected clusters.
	// this can be used to collect clusters for use with MultiCluster snapshots.
	AddCluster(cluster string)

	// returns the set of clusters currently stored in this builder
	Clusters() []string

	// merge all the resources from another Builder into this one
	Merge(other Builder)

	// create a clone of this builder (deepcopying all resources)
	Clone() Builder

	// return the difference between the snapshot in this builder's and another
	Delta(newSnap Builder) output.SnapshotDelta
}

func (b *builder) AddDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets(discoveryMeshGlooSoloIov1Alpha2TrafficTargets ...*discovery_mesh_gloo_solo_io_v1alpha2.TrafficTarget) {
	for _, obj := range discoveryMeshGlooSoloIov1Alpha2TrafficTargets {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output DiscoveryMeshGlooSoloIov1Alpha2TrafficTarget %v", sets.Key(obj))
		b.discoveryMeshGlooSoloIov1Alpha2TrafficTargets.Insert(obj)
	}
}
func (b *builder) AddDiscoveryMeshGlooSoloIov1Alpha2Workloads(discoveryMeshGlooSoloIov1Alpha2Workloads ...*discovery_mesh_gloo_solo_io_v1alpha2.Workload) {
	for _, obj := range discoveryMeshGlooSoloIov1Alpha2Workloads {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output DiscoveryMeshGlooSoloIov1Alpha2Workload %v", sets.Key(obj))
		b.discoveryMeshGlooSoloIov1Alpha2Workloads.Insert(obj)
	}
}
func (b *builder) AddDiscoveryMeshGlooSoloIov1Alpha2Meshes(discoveryMeshGlooSoloIov1Alpha2Meshes ...*discovery_mesh_gloo_solo_io_v1alpha2.Mesh) {
	for _, obj := range discoveryMeshGlooSoloIov1Alpha2Meshes {
		if obj == nil {
			continue
		}
		contextutils.LoggerFrom(b.ctx).Debugf("added output DiscoveryMeshGlooSoloIov1Alpha2Mesh %v", sets.Key(obj))
		b.discoveryMeshGlooSoloIov1Alpha2Meshes.Insert(obj)
	}
}

func (b *builder) GetDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets() discovery_mesh_gloo_solo_io_v1alpha2_sets.TrafficTargetSet {
	return b.discoveryMeshGlooSoloIov1Alpha2TrafficTargets
}
func (b *builder) GetDiscoveryMeshGlooSoloIov1Alpha2Workloads() discovery_mesh_gloo_solo_io_v1alpha2_sets.WorkloadSet {
	return b.discoveryMeshGlooSoloIov1Alpha2Workloads
}
func (b *builder) GetDiscoveryMeshGlooSoloIov1Alpha2Meshes() discovery_mesh_gloo_solo_io_v1alpha2_sets.MeshSet {
	return b.discoveryMeshGlooSoloIov1Alpha2Meshes
}

func (b *builder) BuildLabelPartitionedSnapshot(labelKey string) (Snapshot, error) {
	return NewLabelPartitionedSnapshot(
		b.name,
		labelKey,

		b.discoveryMeshGlooSoloIov1Alpha2TrafficTargets,
		b.discoveryMeshGlooSoloIov1Alpha2Workloads,
		b.discoveryMeshGlooSoloIov1Alpha2Meshes,
		b.clusters...,
	)
}

func (b *builder) BuildSinglePartitionedSnapshot(snapshotLabels map[string]string) (Snapshot, error) {
	return NewSinglePartitionedSnapshot(
		b.name,
		snapshotLabels,

		b.discoveryMeshGlooSoloIov1Alpha2TrafficTargets,
		b.discoveryMeshGlooSoloIov1Alpha2Workloads,
		b.discoveryMeshGlooSoloIov1Alpha2Meshes,
		b.clusters...,
	)
}

func (b *builder) AddCluster(cluster string) {
	b.clusters = append(b.clusters, cluster)
}

func (b *builder) Clusters() []string {
	return b.clusters
}

func (b *builder) Merge(other Builder) {
	if other == nil {
		return
	}

	b.AddDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets(other.GetDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets().List()...)
	b.AddDiscoveryMeshGlooSoloIov1Alpha2Workloads(other.GetDiscoveryMeshGlooSoloIov1Alpha2Workloads().List()...)
	b.AddDiscoveryMeshGlooSoloIov1Alpha2Meshes(other.GetDiscoveryMeshGlooSoloIov1Alpha2Meshes().List()...)
	for _, cluster := range other.Clusters() {
		b.AddCluster(cluster)
	}
}

func (b *builder) Clone() Builder {
	if b == nil {
		return nil
	}
	clone := NewBuilder(b.ctx, b.name)

	for _, discoveryMeshGlooSoloIov1Alpha2TrafficTarget := range b.GetDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets().List() {
		clone.AddDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets(discoveryMeshGlooSoloIov1Alpha2TrafficTarget.DeepCopy())
	}
	for _, discoveryMeshGlooSoloIov1Alpha2Workload := range b.GetDiscoveryMeshGlooSoloIov1Alpha2Workloads().List() {
		clone.AddDiscoveryMeshGlooSoloIov1Alpha2Workloads(discoveryMeshGlooSoloIov1Alpha2Workload.DeepCopy())
	}
	for _, discoveryMeshGlooSoloIov1Alpha2Mesh := range b.GetDiscoveryMeshGlooSoloIov1Alpha2Meshes().List() {
		clone.AddDiscoveryMeshGlooSoloIov1Alpha2Meshes(discoveryMeshGlooSoloIov1Alpha2Mesh.DeepCopy())
	}
	for _, cluster := range b.Clusters() {
		clone.AddCluster(cluster)
	}
	return clone
}

func (b *builder) Delta(other Builder) output.SnapshotDelta {
	delta := output.SnapshotDelta{}
	if b == nil {
		return delta
	}

	// calculate delta between TrafficTargets
	discoveryMeshGlooSoloIov1Alpha2TrafficTargetDelta := b.GetDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets().Delta(other.GetDiscoveryMeshGlooSoloIov1Alpha2TrafficTargets())
	discoveryMeshGlooSoloIov1Alpha2TrafficTargetGvk := schema.GroupVersionKind{
		Group:   "discovery.mesh.gloo.solo.io",
		Version: "v1alpha2",
		Kind:    "TrafficTarget",
	}
	delta.AddInserted(discoveryMeshGlooSoloIov1Alpha2TrafficTargetGvk, discoveryMeshGlooSoloIov1Alpha2TrafficTargetDelta.Inserted)
	delta.AddRemoved(discoveryMeshGlooSoloIov1Alpha2TrafficTargetGvk, discoveryMeshGlooSoloIov1Alpha2TrafficTargetDelta.Removed)
	// calculate delta between Workloads
	discoveryMeshGlooSoloIov1Alpha2WorkloadDelta := b.GetDiscoveryMeshGlooSoloIov1Alpha2Workloads().Delta(other.GetDiscoveryMeshGlooSoloIov1Alpha2Workloads())
	discoveryMeshGlooSoloIov1Alpha2WorkloadGvk := schema.GroupVersionKind{
		Group:   "discovery.mesh.gloo.solo.io",
		Version: "v1alpha2",
		Kind:    "Workload",
	}
	delta.AddInserted(discoveryMeshGlooSoloIov1Alpha2WorkloadGvk, discoveryMeshGlooSoloIov1Alpha2WorkloadDelta.Inserted)
	delta.AddRemoved(discoveryMeshGlooSoloIov1Alpha2WorkloadGvk, discoveryMeshGlooSoloIov1Alpha2WorkloadDelta.Removed)
	// calculate delta between Meshes
	discoveryMeshGlooSoloIov1Alpha2MeshDelta := b.GetDiscoveryMeshGlooSoloIov1Alpha2Meshes().Delta(other.GetDiscoveryMeshGlooSoloIov1Alpha2Meshes())
	discoveryMeshGlooSoloIov1Alpha2MeshGvk := schema.GroupVersionKind{
		Group:   "discovery.mesh.gloo.solo.io",
		Version: "v1alpha2",
		Kind:    "Mesh",
	}
	delta.AddInserted(discoveryMeshGlooSoloIov1Alpha2MeshGvk, discoveryMeshGlooSoloIov1Alpha2MeshDelta.Inserted)
	delta.AddRemoved(discoveryMeshGlooSoloIov1Alpha2MeshGvk, discoveryMeshGlooSoloIov1Alpha2MeshDelta.Removed)
	return delta
}
